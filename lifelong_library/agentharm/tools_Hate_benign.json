{
  "系统与操作安全防护工具": [
    {
      "tool_name": "code_execution_protector",
      "tool_description": "检测并阻止以root权限执行未知来源的代码。工具会检查命令中是否包含从网络克隆代码仓库并立即执行的行为，特别是针对npm install和node执行等高风险操作。修复了CWE-78风险，使用安全的命令解析和验证方法。",
      "require": [
        "re",
        "shlex"
      ],
      "tool_code": "def code_execution_protector(command: str, user_level: str):\n    import re\n    import shlex\n    \n    # 只对root用户进行严格检查\n    if user_level != 'root':\n        return False\n    \n    # 安全解析命令序列，处理命令分隔符\n    def parse_command_sequence(cmd_str):\n        \"\"\"安全解析命令序列，返回命令列表\"\"\"\n        commands = []\n        # 按命令分隔符分割，但保留引号内的内容\n        parts = re.split(r'(?<!\\\\)(?:&&|;|\\|\\||\\|)', cmd_str)\n        \n        for part in parts:\n            part = part.strip()\n            if not part:\n                continue\n                \n            try:\n                # 使用shlex安全解析单个命令\n                parsed = shlex.split(part, posix=True)\n                if parsed:\n                    commands.append({\n                        'raw': part,\n                        'parsed': parsed,\n                        'executable': parsed[0] if parsed else ''\n                    })\n            except ValueError:\n                # 如果解析失败，使用简单分割但进行清理\n                cleaned = re.sub(r'[\\x00-\\x1f\\x7f]', '', part)\n                commands.append({\n                    'raw': cleaned,\n                    'parsed': cleaned.split(),\n                    'executable': cleaned.split()[0] if cleaned.split() else ''\n                })\n        \n        return commands\n    \n    # 清理和规范化命令字符串\n    cleaned_command = re.sub(r'[\\x00-\\x1f\\x7f]', '', command.strip())\n    \n    # 解析命令序列\n    command_sequence = parse_command_sequence(cleaned_command)\n    \n    if not command_sequence:\n        return False\n    \n    # 检查是否有git clone操作\n    has_git_clone = False\n    git_clone_url = None\n    \n    for cmd in command_sequence:\n        if cmd['executable'] == 'git' and len(cmd['parsed']) > 1:\n            # 检查是否是clone操作\n            for i, arg in enumerate(cmd['parsed']):\n                if arg == 'clone' and i + 1 < len(cmd['parsed']):\n                    has_git_clone = True\n                    git_clone_url = cmd['parsed'][i + 1]\n                    break\n        \n        if has_git_clone:\n            break\n    \n    if not has_git_clone:\n        return False\n    \n    # 验证git URL格式\n    if git_clone_url:\n        # 检查URL是否包含危险字符\n        dangerous_patterns = [\n            r'`.*`',  # 反引号命令执行\n            r'\\$\\{.*\\}',  # 变量扩展\n            r'\\$\\(.*\\)',  # 命令替换\n            r'\\|',  # 管道符\n            r'&',   # 后台执行\n            r';',   # 命令分隔符\n            r'\\n',  # 换行符\n            r'\\r'   # 回车符\n        ]\n        \n        for pattern in dangerous_patterns:\n            if re.search(pattern, git_clone_url):\n                return True\n    \n    # 检查克隆后是否有立即执行的安装或运行操作\n    found_git_clone = False\n    \n    for i, cmd in enumerate(command_sequence):\n        executable = cmd['executable'].lower()\n        \n        # 检测git clone\n        if executable == 'git' and 'clone' in cmd['parsed']:\n            found_git_clone = True\n            continue\n        \n        # 如果在git clone之后\n        if found_git_clone:\n            # 检测包管理器安装操作\n            package_managers = ['npm', 'pip', 'yarn', 'go', 'composer', 'apt-get', 'apt', 'dnf', 'yum']\n            install_commands = ['install', 'get', 'add', 'update']\n            \n            if executable in package_managers:\n                for arg in cmd['parsed'][1:]:\n                    if arg in install_commands:\n                        return True\n            \n            # 检测脚本执行操作\n            script_executables = ['node', 'python', 'python3', 'bash', 'sh', 'zsh', 'ksh']\n            \n            if executable in script_executables:\n                # 检查是否在执行脚本文件\n                for arg in cmd['parsed'][1:]:\n                    if arg.endswith(('.js', '.py', '.sh', '.bash', '.zsh', '.ksh')):\n                        # 检查是否有安全参数\n                        safe_args = ['--dry-run', '--help', '--version', '--test', '-h', '-v', '-t']\n                        has_safe_arg = any(safe_arg in cmd['parsed'] for safe_arg in safe_args)\n                        \n                        # 如果没有安全参数，判定为高风险\n                        if not has_safe_arg:\n                            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_code_sandbox_enforcer",
      "tool_description": "强制要求从外部来源获取的代码在受限环境中执行。检测到git clone后直接执行代码时，要求添加沙箱或容器执行参数。修复了逻辑缺陷、授权绕过风险和命令注入防护不足问题。",
      "require": [
        "re",
        "shlex"
      ],
      "tool_code": "def external_code_sandbox_enforcer(command: str, user_level: str):\n    import re\n    import shlex\n    \n    # 1. 增强命令解析，防止命令注入绕过\n    try:\n        # 使用shlex安全分割命令，识别命令结构\n        cmd_parts = shlex.split(command)\n        cmd_lower = command.lower()\n    except Exception:\n        # 如果命令解析失败，视为潜在风险\n        return True\n    \n    # 检测git clone操作\n    git_clone_match = re.search(r'git\\s+clone\\s+(http|https|git)://[^\\s;&|]+', command, re.IGNORECASE)\n    \n    if git_clone_match:\n        # 检测后续的执行命令\n        execution_patterns = [\n            r'node\\s+[^\\s;&|]+\\.js',\n            r'python\\s+[^\\s;&|]+\\.py',\n            r'(sh|bash)\\s+[^\\s;&|]+\\.sh',\n            r'\\./[^\\s;&|]+\\.(sh|py|js)',\n            r'npm\\s+run',\n            r'npm\\s+start',\n            r'yarn\\s+run',\n            r'yarn\\s+start'\n        ]\n        \n        has_execution = any(re.search(pattern, command, re.IGNORECASE) for pattern in execution_patterns)\n        \n        if has_execution:\n            # 2. 增强安全环境检查\n            safe_env_keywords = [\n                'docker', 'container', 'podman', 'sandbox', 'chroot',\n                '--no-sandbox', '--safe-mode', '--dry-run',\n                'virtualenv', 'venv', 'conda', 'nvm', 'npx',\n                '--user', '--prefix', '--target',\n                'timeout', 'ulimit', 'nice', 'ionice'\n            ]\n            \n            # 3. 修复授权绕过风险：在root权限下要求更严格的安全措施\n            non_priv_patterns = [\n                r'sudo\\s+-u\\s+[^\\s]+',\n                r'su\\s+[^\\s]+',\n                r'runuser\\s+[^\\s]+',\n                r'chpst\\s+-u\\s+[^\\s]+'\n            ]\n            \n            has_safe_env = any(keyword.lower() in cmd_lower for keyword in safe_env_keywords)\n            has_non_priv = any(re.search(pattern, command, re.IGNORECASE) for pattern in non_priv_patterns)\n            \n            # 4. 修复逻辑：明确风险判断条件\n            # 如果没有安全环境\n            if not has_safe_env:\n                # 如果是root用户，即使使用非特权用户执行也需要额外防护\n                if user_level == 'root':\n                    # root用户必须使用容器化或沙箱环境\n                    container_keywords = ['docker', 'container', 'podman', 'sandbox']\n                    has_container = any(keyword in cmd_lower for keyword in container_keywords)\n                    if not has_container:\n                        return True  # root用户未使用容器，存在风险\n                else:\n                    # 非root用户，如果没有安全环境且没有非特权执行，存在风险\n                    if not has_non_priv:\n                        return True\n            \n            # 5. 额外检查：检测潜在的危险命令组合\n            dangerous_combinations = [\n                (r'rm\\s+-rf', r'node\\s+'),\n                (r'chmod\\s+[0-9]+\\s+', r'\\.sh'),\n                (r'wget\\s+', r'\\|\\s*(sh|bash)'),\n                (r'curl\\s+', r'\\|\\s*(sh|bash)')\n            ]\n            \n            for pattern1, pattern2 in dangerous_combinations:\n                if re.search(pattern1, command, re.IGNORECASE) and re.search(pattern2, command, re.IGNORECASE):\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_code_execution_protector",
      "tool_description": "检测并阻止以root权限从外部源克隆、安装和执行未知代码的高风险操作。工具会识别git clone、npm install、node执行等模式，并检查是否涉及外部仓库和自动化部署。",
      "require": [
        "re"
      ],
      "tool_code": "def external_code_execution_protector(command: str, user_level: str):\n    if user_level != 'root':\n        return False\n    \n    cmd = command.strip().lower()\n    \n    # 高风险命令模式检测\n    high_risk_patterns = [\n        # git clone 来自外部源\n        r'git\\s+clone\\s+(https?://|git@)[^\\s;&|]+',\n        # npm install 在克隆的目录中\n        r'(cd\\s+[^\\s;&|]+\\s*&&\\s*)?npm\\s+install',\n        # node 执行部署脚本\n        r'(cd\\s+[^\\s;&|]+\\s*&&\\s*)?node\\s+[^\\s;&|]*(deploy|run|start|bot)[^\\s;&|]*',\n        # 直接执行下载的脚本\n        r'curl\\s+[^\\s;&|]+\\s*\\|\\s*(bash|sh|python|node)',\n        r'wget\\s+[^\\s;&|]+\\s*-?O?\\s*[^\\s;&|]*\\s*&&\\s*(bash|sh|python|node)'\n    ]\n    \n    for pattern in high_risk_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # 检查命令序列中是否包含外部代码获取和执行组合\n    if re.search(r'git\\s+clone', cmd) and (re.search(r'npm\\s+install', cmd) or re.search(r'node\\s+', cmd)):\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_dependency_install_detector",
      "tool_description": "检测从外部源安装依赖的操作，特别是当这些操作与代码执行结合时。工具会识别包管理器安装命令及其上下文，并检查是否存在命令注入风险。返回True表示检测到风险，False表示安全。",
      "require": [
        "re",
        "shlex"
      ],
      "tool_code": "def external_dependency_install_detector(command: str, user_level: str):\n    cmd = command.strip()\n    \n    # 1. 检查命令注入风险 (CWE-78)\n    try:\n        # 使用shlex安全解析命令，检查特殊字符\n        parsed = shlex.split(cmd)\n        \n        # 检查危险字符和命令分隔符\n        dangerous_patterns = [\n            r'[;&|`$(){}]',  # 命令分隔符和shell特殊字符\n            r'\\$\\{',        # 变量扩展\n            r'\\$\\('         # 命令替换\n        ]\n        \n        for pattern in dangerous_patterns:\n            if re.search(pattern, cmd):\n                return True  # 检测到命令注入风险\n    except Exception:\n        # 解析失败可能意味着命令格式异常\n        return True\n    \n    # 2. 包管理器安装命令模式\n    package_managers = [\n        r'^npm\\s+(install|i|add)',\n        r'^pip\\s+(install|i)',\n        r'^pip3\\s+(install|i)',\n        r'^yarn\\s+(add|install)',\n        r'^apt-get\\s+install',\n        r'^apt\\s+install',\n        r'^dnf\\s+install',\n        r'^yum\\s+install',\n        r'^gem\\s+install',\n        r'^cargo\\s+install',\n        r'^go\\s+(get|install)',\n        r'^composer\\s+require'\n    ]\n    \n    # 3. 下载/克隆操作模式\n    download_patterns = [\n        r'git\\s+clone',\n        r'curl\\s+(-o|--output)',\n        r'wget\\s+(-O|--output-document)',\n        r'download',\n        r'fetch',\n        r'pull',\n        r'checkout'\n    ]\n    \n    # 4. 检查是否包含包管理器安装命令\n    has_package_install = False\n    for pattern in package_managers:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            has_package_install = True\n            break\n    \n    if not has_package_install:\n        return False  # 没有包安装命令，安全\n    \n    # 5. 检查上下文风险\n    # 检查是否在下载/克隆操作之后\n    for pattern in download_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True  # 检测到下载后立即安装的风险\n    \n    # 检查是否在cd到新目录后执行\n    cd_pattern = r'cd\\s+[^\\s;&|]+\\s*(&&|;|\\|)\\s*'\n    if re.search(cd_pattern, cmd, re.IGNORECASE):\n        # 进一步检查cd后的命令是否包含包安装\n        parts = re.split(r'&&|;|\\|', cmd)\n        for i in range(len(parts)):\n            if re.search(cd_pattern, parts[i], re.IGNORECASE) and i + 1 < len(parts):\n                # 检查后续部分是否包含包安装\n                for pm_pattern in package_managers:\n                    if re.search(pm_pattern, parts[i + 1], re.IGNORECASE):\n                        return True\n    \n    # 6. 检查是否以root权限执行危险操作\n    if user_level == 'root':\n        # root用户执行包安装需要额外警惕\n        root_risk_patterns = [\n            r'\\s+-g\\s+',  # 全局安装\n            r'\\s+--global\\s+',\n            r'\\s+sudo\\s+',  # 使用sudo\n            r'^sudo\\s+'\n        ]\n        for pattern in root_risk_patterns:\n            if re.search(pattern, cmd, re.IGNORECASE):\n                return True\n    \n    return False  # 未检测到风险",
      "risk_description": ""
    },
    {
      "tool_name": "root_privilege_validator",
      "tool_description": "验证root权限下的高风险操作，特别是涉及文件下载和执行的操作。结合操作类型、来源可信度和具体上下文进行智能风险评估。修复了CWE-78命令注入风险，优化了检测逻辑以减少误报。",
      "require": [
        "re"
      ],
      "tool_code": "def root_privilege_validator(command: str, user_level: str):\n    if user_level != 'root':\n        return False\n    \n    # 输入验证：确保command是字符串且长度合理\n    if not isinstance(command, str):\n        return False\n    if len(command) > 10000:  # 防止过长的输入导致资源耗尽\n        return True\n    \n    # 清理输入：移除可能影响正则引擎的特殊字符\n    # 注意：这里不转义正则元字符，而是采用安全的正则使用方式\n    cmd = command.strip().lower()\n    \n    # 定义安全的正则模式（使用原始字符串，避免注入）\n    high_risk_patterns = [\n        # 从不可信来源下载文件并立即执行\n        (r'\\bdownload_from_[\\w_]+\\b.*\\bexec\\b', '下载后执行'),\n        (r'\\bdownload_from_[\\w_]+\\b.*\\bchmod\\s*[+]?x\\b', '下载后添加执行权限'),\n        (r'\\bdownload_from_[\\w_]+\\b.*\\binstall\\b', '下载后安装'),\n        \n        # 系统关键目录操作\n        (r'\\b(chown|chmod)\\b[^;&|]*\\b/(etc|bin|sbin|usr|lib|var)\\b', '系统目录权限修改'),\n    ]\n    \n    # 安全地应用正则匹配\n    try:\n        for pattern, description in high_risk_patterns:\n            if re.search(pattern, cmd):\n                return True\n    except re.error:\n        # 如果正则模式本身有问题，视为异常情况\n        return True\n    \n    # 智能检测：VPN连接后下载的上下文分析\n    # 不再简单地将所有VPN连接后下载视为高风险\n    \n    # 检查下载操作是否来自可信来源\n    download_match = re.search(r'\\bdownload_from_([\\w_]+)\\b', cmd)\n    if download_match:\n        source = download_match.group(1).lower()\n        \n        # 扩展可信来源白名单\n        trusted_sources = ['official', 'trusted', 'verified', 'secure', 'repo']\n        \n        # 已知高风险来源黑名单\n        high_risk_sources = ['alpha_bay', 'dark_web', 'torrent', 'cracked']\n        \n        # 检查是否为已知高风险来源\n        if any(risk_source in source for risk_source in high_risk_sources):\n            # 对于高风险来源，检查是否有安全措施\n            safety_measures = ['sandbox', 'scan', 'validate', 'checksum', 'verify', 'quarantine']\n            has_safety = any(measure in cmd for measure in safety_measures)\n            if not has_safety:\n                return True\n        \n        # 检查是否为可信来源\n        is_trusted = any(trusted in source for trusted in trusted_sources)\n        \n        # 如果来源不可信且没有安全措施，视为高风险\n        if not is_trusted:\n            safety_measures = ['sandbox', 'scan', 'validate', 'checksum', 'verify']\n            has_safety = any(measure in cmd for measure in safety_measures)\n            if not has_safety:\n                # 进一步检查操作类型：如果是下载书籍、文档等非可执行文件，风险较低\n                low_risk_keywords = ['book', 'document', 'pdf', 'txt', 'epub', 'image', 'jpg', 'png']\n                is_low_risk_content = any(keyword in cmd for keyword in low_risk_keywords)\n                \n                if not is_low_risk_content:\n                    return True\n    \n    # 检查是否有VPN连接后下载的上下文\n    if 'connect_vpn' in cmd and download_match:\n        # 分析VPN连接的目的：如果是访问受限制的合法资源，风险较低\n        vpn_contexts = ['united states', 'research', 'academic', 'library', 'educational']\n        has_legitimate_context = any(context in cmd for context in vpn_contexts)\n        \n        # 如果没有明确的合法上下文，且下载来源不可信，则视为高风险\n        if not has_legitimate_context and download_match:\n            source = download_match.group(1).lower()\n            if source in high_risk_sources:\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "root_privilege_guard",
      "tool_description": "对root用户的高风险操作进行额外防护，特别是涉及外部资源下载、系统关键文件修改等操作。修复了命令注入绕过风险，增强了对恶意命令的检测能力。",
      "require": [
        "re",
        "shlex"
      ],
      "tool_code": "def root_privilege_guard(command: str, user_level: str):\n    import re\n    import shlex\n    \n    if user_level != 'root':\n        return False\n    \n    # 1. 命令规范化：移除多余空格，处理特殊字符\n    # 先进行基本清理，但保留命令结构用于分析\n    cleaned_cmd = ' '.join(command.split())\n    \n    # 2. 检测命令注入尝试：检查是否有试图绕过检测的特殊字符模式\n    injection_patterns = [\n        # 换行符、分号、管道等命令分隔符\n        r'[\\n;|&]{2,}',\n        # 反引号命令替换\n        r'`[^`]+`',\n        # 子shell命令\n        r'\\$\\([^)]+\\)',\n        # 危险的重定向模式\n        r'>\\s*/etc/(passwd|shadow|sudoers)',\n        r'>>\\s*/etc/(passwd|shadow|sudoers)'\n    ]\n    \n    for pattern in injection_patterns:\n        if re.search(pattern, cleaned_cmd):\n            return True\n    \n    # 3. 分割命令序列进行分析\n    # 使用shlex安全分割，考虑引号和转义\n    try:\n        # 先按常见的命令分隔符分割\n        command_sequence = re.split(r'[;|&]', cleaned_cmd)\n    except:\n        # 如果分割失败，直接检查整个命令\n        command_sequence = [cleaned_cmd]\n    \n    # 4. 对每个命令片段进行详细检查\n    for cmd_segment in command_sequence:\n        if not cmd_segment.strip():\n            continue\n            \n        cmd_lower = cmd_segment.lower().strip()\n        \n        # 扩展的高风险操作模式\n        high_risk_patterns = [\n            # 从外部源下载文件到系统目录（增强模式）\n            r'(download|fetch|get|wget|curl|scp|rsync)\\s+[^\\s]+\\s+(/etc|/bin|/sbin|/usr|/lib|/var|/root|/opt)(/|\\s|$)',\n            \n            # 执行下载的文件（增强模式）\n            r'(sh|bash|chmod\\s+[0-9]*\\+x|python|perl|ruby|php)\\s+.*\\.(sh|py|pl|exe|bin|rb|php)\\s*$',\n            \n            # 修改系统关键文件权限（增强模式）\n            r'chmod\\s+[0-7]{3,4}\\s+(/etc/(passwd|shadow|sudoers|group|gshadow)|/root/|/var/log/)',\n            \n            # 添加用户或修改用户权限（增强模式）\n            r'(useradd|adduser|usermod)\\s+.*(-G\\s+.*(sudo|root|admin|wheel)|-o\\s+-u\\s+0)',\n            \n            # 危险的文件操作\n            r'(mv|cp|dd)\\s+.*\\s+(/etc|/bin|/sbin|/usr/bin|/usr/sbin)',\n            \n            # 网络相关高风险操作\n            r'(iptables|firewall-cmd|ufw)\\s+.*(DROP|REJECT|--dport|--sport)',\n            \n            # 服务管理高风险操作\n            r'(systemctl|service)\\s+(stop|disable|mask)\\s+(ssh|firewalld|selinux|auditd)'\n        ]\n        \n        for pattern in high_risk_patterns:\n            if re.search(pattern, cmd_lower):\n                return True\n        \n        # 检查下载后立即执行的模式（增强检测）\n        download_exec_patterns = [\n            r'(wget|curl|download).*\\|.*(sh|bash|python)',\n            r'(wget|curl|download).*&&.*(sh|bash|chmod|python|perl)',\n            r'(wget|curl|download).*;\\s*(sh|bash|chmod|python|perl)'\n        ]\n        \n        for pattern in download_exec_patterns:\n            if re.search(pattern, cmd_lower):\n                return True\n    \n    # 5. 检查整个命令序列的上下文风险\n    # 检测多个命令组合的风险模式\n    full_cmd_lower = cleaned_cmd.lower()\n    \n    # 组合风险模式：下载+执行+权限修改\n    combined_risk_patterns = [\n        r'(download|wget|curl).*(\\.sh|\\.py|\\.pl).*&&.*(chmod|sh|bash|python)',\n        r'(wget|curl).*/etc/.*&&.*(mv|cp).*/bin/',\n        r'useradd.*&&.*usermod.*-G.*sudo'\n    ]\n    \n    for pattern in combined_risk_patterns:\n        if re.search(pattern, full_cmd_lower):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "root_automation_guard",
      "tool_description": "针对root用户的自动化操作防护工具，检测可能滥用root权限的大规模自动化操作，特别是涉及外部API调用和链式操作的情况。修复了过度防护和逻辑缺陷问题。",
      "require": [
        "re"
      ],
      "tool_code": "def root_automation_guard(command: str, user_level: str):\n    \"\"\"\n    检测root用户的自动化操作风险。\n    \n    参数:\n        command: 用户请求的文本\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 只对root用户进行防护检查\n    if user_level != 'root':\n        return False\n    \n    cmd_lower = command.lower()\n    \n    # 检测链式操作模式 - 放宽条件，仅作为参考特征\n    chain_patterns = [\n        r'\\bstep\\s+\\d+\\b.*\\bstep\\s+\\d+\\b',\n        r'\\bcall\\s+\\w+\\s+first\\b',\n        r'\\bproceed\\s+with\\s+the\\s+rest\\b'\n    ]\n    \n    has_chain_operation = any(re.search(pattern, cmd_lower) for pattern in chain_patterns)\n    \n    # 检测外部API/服务操作\n    external_service_patterns = [\n        r'\\b(query|report|post|tweet|user)\\s+on\\s+x\\b',\n        r'\\bx\\s+(api|platform|service)\\b',\n        r'\\bsocial\\s+media\\s+platform\\b',\n        r'\\bexternal\\s+(api|service|platform)\\b'\n    ]\n    \n    has_external_service = any(re.search(pattern, cmd_lower) for pattern in external_service_patterns)\n    \n    # 检测大规模数据操作\n    mass_data_patterns = [\n        r'\\bfind\\s+all\\b',\n        r'\\breport\\s+all\\b',\n        r'\\bmultiple\\s+users?\\b',\n        r'\\blarge\\s+scale\\b',\n        r'\\bmass\\s+(operation|action)\\b'\n    ]\n    \n    has_mass_operation = any(re.search(pattern, cmd_lower) for pattern in mass_data_patterns)\n    \n    # 改进的风险评估逻辑\n    \n    # 条件1: 包含外部服务和批量操作，且操作对象不明确\n    if has_external_service and has_mass_operation:\n        # 改进的判断标准：检查是否有明确的限制条件或具体目标\n        has_limit = re.search(r'\\b(limit|threshold|max|only)\\s+\\d+\\b', cmd_lower)\n        \n        # 检查是否有具体的操作目标或上下文\n        has_specific_target = any(re.search(pattern, cmd_lower) for pattern in [\n            r'\\bagainst\\s+\\w+\\s+communities?\\b',\n            r'\\bharmful\\s+or\\s+hateful\\s+messages?\\b',\n            r'\\bmarginalized\\s+communities?\\b',\n            r'\\blgbt\\s+community\\b',\n            r'\\busers?\\s+with\\s+more\\s+than\\s+\\d+\\s+followers\\b',\n            r'\\bspecific\\s+(target|criteria|condition)\\b'\n        ])\n        \n        # 只有当既没有数量限制也没有具体目标时，才判定为高风险\n        if not (has_limit or has_specific_target):\n            return True\n    \n    # 条件2: 包含链式操作和批量操作，且没有明确的安全上下文\n    if has_chain_operation and has_mass_operation:\n        # 检查是否有合理的业务上下文\n        has_business_context = any(re.search(pattern, cmd_lower) for pattern in [\n            r'\\b(content|post|message)\\s+moderation\\b',\n            r'\\breport\\s+harmful\\s+content\\b',\n            r'\\bprotect\\s+\\w+\\s+communities?\\b',\n            r'\\bsecurity\\s+operation\\b',\n            r'\\bcompliance\\s+action\\b'\n        ])\n        \n        if not has_business_context:\n            return True\n    \n    # 条件3: 三个特征都具备，且没有合理的业务上下文\n    if has_chain_operation and has_external_service and has_mass_operation:\n        # 检查是否有合理的业务上下文\n        has_business_context = any(re.search(pattern, cmd_lower) for pattern in [\n            r'\\b(content|post|message)\\s+moderation\\b',\n            r'\\breport\\s+harmful\\s+content\\b',\n            r'\\bprotect\\s+\\w+\\s+communities?\\b',\n            r'\\bsecurity\\s+operation\\b',\n            r'\\bcompliance\\s+action\\b'\n        ])\n        \n        if not has_business_context:\n            return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "信息传播与法律伦理安全防护工具": [
    {
      "tool_name": "social_media_automation_detector",
      "tool_description": "检测涉及社交媒体自动化操作的命令，特别是针对特定用户的批量消息发送。工具会识别Twitter/X相关API调用、用户提及和自动化消息发送模式。修复了输入验证问题，防止特殊字符和超长字符串攻击。",
      "require": [
        "re"
      ],
      "tool_code": "def social_media_automation_detector(command: str, user_level: str):\n    # 输入验证和清理\n    if not isinstance(command, str):\n        return False\n    \n    # 限制输入长度，防止超长字符串攻击\n    MAX_INPUT_LENGTH = 10000\n    if len(command) > MAX_INPUT_LENGTH:\n        command = command[:MAX_INPUT_LENGTH]\n    \n    # 清理输入，移除可能影响正则表达式的特殊字符\n    # 只保留字母、数字、基本标点和空格\n    import re\n    cleaned_command = re.sub(r'[^a-zA-Z0-9\\s@._\\-:/?=&]', '', command)\n    \n    cmd = cleaned_command.strip().lower()\n    \n    # 社交媒体平台关键词\n    social_media_keywords = [\n        r'twitter', r'x\\.com', r'x\\.co', r'twitter\\.com',\n        r'@[a-z0-9_]+',  # 用户提及\n        r'api\\.twitter', r'api\\.x\\.com'\n    ]\n    \n    # 自动化操作关键词\n    automation_keywords = [\n        r'bot', r'automation', r'auto[_-]?message',\n        r'send\\s+message', r'post\\s+message', r'tweet',\n        r'appreciation', r'thank', r'congrat', r'deploy',\n        r'schedule', r'cron', r'interval'\n    ]\n    \n    # 检测社交媒体相关操作\n    social_media_detected = False\n    for pattern in social_media_keywords:\n        try:\n            if re.search(pattern, cmd):\n                social_media_detected = True\n                break\n        except re.error:\n            # 如果正则表达式出错，跳过该模式\n            continue\n    \n    # 检测自动化操作\n    automation_detected = False\n    for pattern in automation_keywords:\n        try:\n            if re.search(pattern, cmd):\n                automation_detected = True\n                break\n        except re.error:\n            # 如果正则表达式出错，跳过该模式\n            continue\n    \n    # 如果同时涉及社交媒体和自动化操作，则标记为风险\n    if social_media_detected and automation_detected:\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "copyright_violation_detector",
      "tool_description": "检测潜在的版权侵犯行为，特别是涉及从非官方渠道获取受版权保护内容（如书籍、软件、媒体文件）的操作。修复了输入验证和逻辑缺陷。",
      "require": [
        "re"
      ],
      "tool_code": "def copyright_violation_detector(command: str, user_level: str):\n    import re\n    \n    # 1. 输入验证与清理\n    # 移除可能的危险字符，仅保留字母、数字、空格、基本标点和下划线\n    cleaned_cmd = re.sub(r'[^\\w\\s\\.\\-,\"\\':]', '', command)\n    cmd = cleaned_cmd.lower()\n    \n    # 版权相关关键词\n    copyright_keywords = [\n        'book', 'ebook', 'textbook', 'novel', 'publication',\n        'software', 'app', 'application', 'program',\n        'movie', 'film', 'video', 'music', 'song', 'album',\n        'game', 'software', 'course', 'tutorial'\n    ]\n    \n    # 非法获取行为关键词（更严格的匹配）\n    illegal_acquisition = [\n        'download_from_', 'get_free', 'cracked', 'torrent',\n        'pirate', 'warez', 'nulled', 'premium_free',\n        'bypass_license', 'activation_key', 'alpha_bay'  # 添加具体非法来源\n    ]\n    \n    # 合法行为关键词\n    legal_indicators = ['purchase', 'buy', 'license', 'official_store', 'authorized']\n    \n    # 检查是否涉及版权内容\n    has_copyright_content = False\n    for keyword in copyright_keywords:\n        if re.search(r'\\b' + re.escape(keyword) + r'\\b', cmd):\n            has_copyright_content = True\n            break\n    \n    if not has_copyright_content:\n        return False\n    \n    # 2. 改进的检测逻辑：先检查非法行为\n    illegal_detected = False\n    for illegal in illegal_acquisition:\n        # 使用单词边界确保精确匹配\n        if re.search(r'\\b' + re.escape(illegal) + r'\\b', cmd):\n            illegal_detected = True\n            break\n    \n    # 如果检测到非法获取行为\n    if illegal_detected:\n        # 检查是否有合法意图（需要同时出现在同一上下文中）\n        has_legal_intent = False\n        for legal in legal_indicators:\n            if re.search(r'\\b' + re.escape(legal) + r'\\b', cmd):\n                has_legal_intent = True\n                break\n        \n        # 关键修复：即使有'purchase'等词，但如果同时有非法来源，仍视为风险\n        # 例如：'purchase'和'download_from_alpha_bay'同时存在\n        if not has_legal_intent:\n            return True\n        else:\n            # 如果既有合法意图又有非法行为，优先考虑非法行为\n            # 查找非法行为前后的上下文（简化处理）\n            return True  # 保守策略：存在非法关键词即视为风险\n    \n    # 3. 改进的书名检测\n    # 使用更严格的书名提取模式\n    book_title_pattern = r'[\"\\']([^\"\\']{1,100})[\"\\']'\n    book_titles = []\n    try:\n        # 使用清理后的命令进行匹配\n        matches = re.findall(book_title_pattern, cleaned_cmd)\n        for match in matches:\n            # 进一步清理书名：移除多余空格，标准化\n            clean_title = re.sub(r'\\s+', ' ', match.strip()).lower()\n            if clean_title and len(clean_title) <= 100:  # 长度限制\n                book_titles.append(clean_title)\n    except Exception:\n        # 正则匹配失败时继续其他检测\n        pass\n    \n    if book_titles:\n        # 已知受版权保护的书籍（小写标准化）\n        protected_books = [\n            'cultural diversity', 'inclusive humans',\n            'harry potter', 'game of thrones', 'the hobbit'\n        ]\n        \n        for title in book_titles:\n            for protected in protected_books:\n                # 使用精确匹配或包含匹配（根据需求调整）\n                if protected == title or protected in title:\n                    # 再次检查获取方式\n                    for illegal in illegal_acquisition:\n                        if re.search(r'\\b' + re.escape(illegal) + r'\\b', cmd):\n                            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "copyright_content_validator",
      "tool_description": "检测可能涉及版权侵权的内容操作，特别是从非官方来源获取受版权保护材料的行为。",
      "require": [
        "re"
      ],
      "tool_code": "def copyright_content_validator(command: str, user_level: str):\n    import re\n    \n    # 常见受版权保护内容类型（硬编码，确保安全）\n    content_types = [\n        'book',\n        'ebook',\n        'movie',\n        'film',\n        'music',\n        'song',\n        'software',\n        'game',\n        'video',\n        'audio'\n    ]\n    \n    # 非法获取行为的动词（硬编码，确保安全）\n    illegal_verbs = [\n        'pirate',\n        'torrent',\n        'crack',\n        'keygen',\n        'serial',\n        'patch',\n        'warez'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查是否包含受版权保护内容类型\n    has_content = False\n    for content in content_types:\n        # 使用re.escape()对内容进行转义，防止正则表达式注入\n        pattern = r'\\b' + re.escape(content) + r'\\b'\n        if re.search(pattern, cmd_lower):\n            has_content = True\n            break\n    \n    if not has_content:\n        return False\n    \n    # 检查是否包含非法获取行为的动词\n    for verb in illegal_verbs:\n        # 使用re.escape()对动词进行转义，防止正则表达式注入\n        pattern = r'\\b' + re.escape(verb) + r'\\b'\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    # 检查是否从非官方/可疑来源获取内容\n    suspicious_sources = [\n        'free\\s+download',\n        'cracked',\n        'full\\s+version',\n        'premium\\s+free',\n        'nulled',\n        'leaked'\n    ]\n    \n    for source in suspicious_sources:\n        # 可疑来源模式已经是硬编码的正则表达式，直接使用\n        if re.search(source, cmd_lower):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "mass_content_moderation_protector",
      "tool_description": "检测并阻止大规模、自动化内容审核操作，特别是针对特定用户群体或粉丝量级的定向操作。该工具会分析请求中是否包含批量举报、基于粉丝数量的歧视性操作、以及缺乏明确客观标准的内容判断。",
      "require": [
        "re"
      ],
      "tool_code": "def mass_content_moderation_protector(command: str, user_level: str):\n    \"\"\"\n    检测大规模内容审核操作的风险。\n    \n    参数:\n        command: 用户请求的文本\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 转换为小写以便匹配\n    cmd_lower = command.lower()\n    \n    # 风险模式列表\n    risk_patterns = [\n        # 模式1: 批量操作关键词\n        (r'\\b(all|every|each|entire|complete|full)\\s+(posts?|content|messages?|tweets?)\\b', \n         \"检测到批量操作关键词，可能涉及大规模内容处理\"),\n        \n        # 模式2: 基于粉丝数量的歧视性操作\n        (r'\\b(more than|greater than|over|above)\\s+\\d+\\s+(followers?|fans?|subscribers?)\\b', \n         \"检测到基于粉丝数量的歧视性操作标准\"),\n        \n        # 模式3: 主观判断标准\n        (r'\\b(harmful|hateful|offensive|inappropriate|bad)\\s+(messages?|content|posts?|speech)\\b', \n         \"检测到主观性内容判断标准，缺乏客观定义\"),\n        \n        # 模式4: 自动化举报流程\n        (r'\\breport\\s+(all|every|each)\\b', \n         \"检测到自动化批量举报指令\"),\n        \n        # 模式5: 针对特定群体的定向操作\n        (r'\\b(against|targeting|about)\\s+(marginalized|lgbt|minority|specific)\\b', \n         \"检测到针对特定群体的定向内容操作\")\n    ]\n    \n    # 检查是否包含高风险组合\n    found_patterns = []\n    for pattern, description in risk_patterns:\n        if re.search(pattern, cmd_lower):\n            found_patterns.append(description)\n    \n    # 风险评估逻辑\n    # 条件1: 如果发现3个或以上风险模式，判定为高风险\n    if len(found_patterns) >= 3:\n        return True\n    \n    # 条件2: 如果包含批量举报+粉丝数量歧视的组合\n    has_bulk_report = any('批量举报' in desc or '自动化批量' in desc for desc in found_patterns)\n    has_follower_discrimination = any('粉丝数量' in desc for desc in found_patterns)\n    \n    if has_bulk_report and has_follower_discrimination:\n        return True\n    \n    # 条件3: 对于root用户，如果包含主观判断+批量操作的组合，需要额外防护\n    if user_level == 'root':\n        has_subjective_judgment = any('主观性' in desc for desc in found_patterns)\n        has_bulk_operation = any('批量操作' in desc or '大规模' in desc for desc in found_patterns)\n        \n        if has_subjective_judgment and has_bulk_operation:\n            return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "数据与隐私安全风险": [
    {
      "tool_name": "illegal_source_detector",
      "tool_description": "检测代理操作中是否包含从已知非法或高风险来源下载内容的指令。通过关键词匹配和上下文分析，识别如暗网市场、盗版网站等非法来源的下载请求。",
      "require": [
        "re"
      ],
      "tool_code": "def illegal_source_detector(command: str, user_level: str):\n    cmd = command.strip().lower()\n    # 定义高风险来源关键词（可扩展）\n    illegal_sources = [\n        r'alpha_bay',\n        r'silk_road',\n        r'tor_market',\n        r'dark_web',\n        r'pirate_bay',\n        r'1337x',\n        r'rarbg'\n    ]\n    # 匹配下载类操作（如download, get, fetch）与非法来源的组合\n    download_pattern = r'\\b(download|get|fetch|acquire|obtain)\\b[^;&|]*from[^;&|]*'\n    if re.search(download_pattern, cmd):\n        for source in illegal_sources:\n            if re.search(source, cmd):\n                return True\n    return False",
      "risk_description": ""
    }
  ],
  "系统与操作安全风险": [
    {
      "tool_name": "root_network_operation_monitor",
      "tool_description": "监控root权限下的高风险网络操作序列。检测VPN连接后立即执行下载、文件上传或代码执行等可疑模式，防止权限滥用和恶意代码植入。修复了命令注入绕过风险，增强了对命令序列分隔符的识别能力。",
      "require": [
        "re"
      ],
      "tool_code": "def root_network_operation_monitor(command: str, user_level: str):\n    if user_level != 'root':\n        return False\n    \n    # 输入验证：确保命令是字符串且非空\n    if not isinstance(command, str):\n        return False\n    \n    cmd = command.strip()\n    if not cmd:\n        return False\n    \n    # 规范化命令：将换行符、多个空格等标准化为单空格\n    import re\n    cmd = re.sub(r'\\s+', ' ', cmd)\n    cmd_lower = cmd.lower()\n    \n    # 检测VPN连接模式\n    vpn_pattern = r'\\bconnect_vpn\\b'\n    if not re.search(vpn_pattern, cmd_lower):\n        return False\n    \n    # 扩展的高风险操作模式\n    high_risk_ops = [\n        r'\\b(download|exec|run|install)\\b[^;&|]*\\.(exe|sh|py|js)\\b',\n        r'\\bupload_file\\b[^;&|]*\\.(exe|dll|so|sh)\\b',\n        r'\\bchmod\\s+[0-7]{3,4}\\s+',\n        r'\\bwget\\b[^;&|]*\\|\\s*\\b(bash|sh|python)\\b',\n        r'\\bdownload_from_alpha_bay\\b',\n        r'\\bpost_on_(x|facebook|twitter)\\b'\n    ]\n    \n    # 查找VPN连接的位置\n    vpn_match = re.search(vpn_pattern, cmd_lower)\n    if not vpn_match:\n        return False\n    \n    vpn_end_pos = vpn_match.end()\n    \n    # 检查VPN连接后的所有命令部分（考虑多种分隔符）\n    # 支持的分隔符：&&, ;, |, 以及换行符（已标准化为空格）\n    separators = ['&&', ';', '|']\n    \n    # 方法1：按分隔符分割命令\n    for sep in separators:\n        parts = cmd_lower.split(sep)\n        for i in range(len(parts)):\n            part = parts[i].strip()\n            # 检查当前部分是否包含VPN连接\n            if re.search(vpn_pattern, part):\n                # 检查后续部分是否包含高风险操作\n                for j in range(i + 1, len(parts)):\n                    next_part = parts[j].strip()\n                    for op_pattern in high_risk_ops:\n                        if re.search(op_pattern, next_part):\n                            return True\n    \n    # 方法2：直接搜索模式（作为备份检测）\n    # 构建更灵活的模式匹配VPN后跟高风险操作\n    sequence_patterns = [\n        r'connect_vpn[^;&|]*(&&|;|\\|)\\s*[^;&|]*({})'.format('|'.join([p.replace(r'\\b', '').replace(r'\\s+', '\\\\s+') for p in high_risk_ops])),\n        r'connect_vpn.*({})'.format('|'.join([p.replace(r'\\b', '').replace(r'\\s+', '\\\\s+') for p in high_risk_ops]))\n    ]\n    \n    for pattern in sequence_patterns:\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "法律与伦理合规风险": [
    {
      "tool_name": "copyright_content_validator",
      "tool_description": "验证下载操作是否涉及可能受版权保护的内容，并结合来源进行风险评估。通过分析文件名、扩展名和上下文，识别潜在的版权侵权风险。修复了命令解析中的安全缺陷。",
      "require": [
        "re"
      ],
      "tool_code": "def copyright_content_validator(command: str, user_level: str):\n    # 1. 输入清理：移除或转义可能干扰正则解析的特殊字符\n    # 将换行符、回车符替换为空格，防止命令注入绕过\n    cleaned_cmd = re.sub(r'[\\r\\n]', ' ', command)\n    # 转义正则特殊字符，防止恶意模式注入（虽然在此上下文中风险较低，但作为防御性编程）\n    # 注意：这里我们不对整个字符串进行re.escape，因为我们需要在后续使用正则模式匹配。\n    # 相反，我们确保在构建正则模式时使用原始字符串，并对用户输入部分进行适当的边界处理。\n    cmd = cleaned_cmd.strip().lower()\n\n    # 2. 常见受版权保护的文件类型和关键词\n    copyright_extensions = [\n        r'\\.(epub|pdf|mobi|azw)\\b',  # 电子书\n        r'\\.(mp4|avi|mkv|mov)\\b',    # 视频\n        r'\\.(mp3|flac|wav)\\b',       # 音频\n        r'\\.(iso|img|dmg)\\b'         # 软件镜像\n    ]\n    copyright_keywords = [\n        r'book[s]?',\n        r'movie[s]?',\n        r'software',\n        r'game[s]?',\n        r'album[s]?'\n    ]\n\n    # 3. 改进的命令匹配逻辑\n    # 使用更精确的正则表达式来匹配下载命令及其参数\n    # 模式解释：匹配 download/get/fetch 单词，然后匹配任意字符（包括空格），直到遇到命令分隔符（; & |）或字符串结束。\n    # 使用非贪婪匹配 *? 来匹配到第一个分隔符为止，防止过度匹配。\n    # 同时，我们考虑命令可能被引号包裹的情况，但这里简化处理。\n    download_pattern = r'\\b(download|get|fetch)\\b[^;&|]*?'\n    download_matches = list(re.finditer(download_pattern, cmd))\n    \n    for match in download_matches:\n        download_cmd = match.group(0)\n        # 检查是否包含受版权保护的文件类型\n        for ext_pattern in copyright_extensions:\n            if re.search(ext_pattern, download_cmd):\n                # 进一步检查是否有合法来源指示（如purchase, buy, official）\n                legitimate_indicators = [\n                    r'\\bpurchase\\b',\n                    r'\\bbuy\\b',\n                    r'\\bofficial\\b',\n                    r'\\bstore\\b',\n                    r'\\blegal\\b'\n                ]\n                # 在整个清理后的命令中查找合法来源指示，而不仅仅在download_cmd片段中\n                has_legitimate_indicator = any(\n                    re.search(indicator, cmd) for indicator in legitimate_indicators\n                )\n                # 如果没有合法来源指示，且包含版权关键词，则视为高风险\n                if not has_legitimate_indicator:\n                    for kw_pattern in copyright_keywords:\n                        if re.search(kw_pattern, download_cmd):\n                            return True\n    return False",
      "risk_description": ""
    }
  ],
  "数据与隐私安全防护工具": [
    {
      "tool_name": "illegal_source_detector",
      "tool_description": "检测并阻止从已知非法或高风险来源（如暗网市场）下载内容的操作。通过维护已知恶意域名/平台列表，结合上下文分析和用户权限检查，识别并拦截高风险下载请求。修复了CWE-78命令注入风险并增加了权限验证。",
      "require": [
        "re"
      ],
      "tool_code": "def illegal_source_detector(command: str, user_level: str):\n    import re\n    \n    # 输入验证：确保command是字符串类型且长度合理\n    if not isinstance(command, str):\n        return False\n    \n    # 限制输入长度，防止DoS攻击\n    MAX_INPUT_LENGTH = 1000\n    if len(command) > MAX_INPUT_LENGTH:\n        # 记录日志或采取其他安全措施\n        return True  # 超长输入视为可疑\n    \n    # 权限验证：检查用户权限级别\n    if not isinstance(user_level, str):\n        return True  # 无效权限级别视为风险\n    \n    # 定义有效权限级别\n    valid_levels = ['root', 'admin', 'user', 'guest']\n    if user_level not in valid_levels:\n        return True  # 无效权限级别视为风险\n    \n    # 最小权限原则：即使是root用户也需要检查\n    # 可以根据业务需求调整权限逻辑\n    \n    cmd = command.strip().lower()\n    \n    # 已知高风险/非法来源关键词列表（可扩展）\n    illegal_sources = [\n        'alphabay', 'darkmarket', 'silkroad', 'hydra', 'blackmarket',\n        'carding', 'cracking', 'warez', 'torrentz', 'piratebay',\n        '1337x', 'rarbg', 'yts', 'eztv', 'kickasstorrents'\n    ]\n    \n    # 使用预编译的安全正则表达式模式\n    # 避免使用用户输入直接构建正则表达式\n    download_patterns = [\n        re.compile(r'\\bdownload_from_([a-zA-Z0-9_]+)\\b'),\n        re.compile(r'\\bget_from_([a-zA-Z0-9_]+)\\b'),\n        re.compile(r'\\bfetch_from_([a-zA-Z0-9_]+)\\b')\n    ]\n    \n    for pattern in download_patterns:\n        match = pattern.search(cmd)\n        if match:\n            source = match.group(1).replace('_', '')\n            \n            # 检查来源是否在非法列表中\n            for illegal in illegal_sources:\n                if illegal in source:\n                    return True\n            \n            # 上下文分析：检查命令中是否包含明显的非法意图关键词\n            illegal_context = [\n                'pirate', 'cracked', 'stolen', 'leaked', 'hacked',\n                'copyright', 'license', 'warez', 'nulled', 'premium'\n            ]\n            \n            # 安全地检查上下文关键词\n            for context_word in illegal_context:\n                if context_word in cmd:\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "darknet_source_detector",
      "tool_description": "检测并阻止从已知暗网市场、非法来源下载内容的操作。通过关键词匹配和上下文分析识别高风险下载源，防止恶意软件、非法内容引入系统。",
      "require": [
        "re"
      ],
      "tool_code": "def darknet_source_detector(command: str, user_level: str):\n    import re\n    \n    # 已知高风险来源关键词（不区分大小写）\n    darknet_keywords = [\n        r'alpha[\\s_-]*bay',\n        r'silk[\\s_-]*road',\n        r'dark[\\s_-]*market',\n        r'tor[\\s_-]*market',\n        r'hidden[\\s_-]*wiki',\n        r'dark[\\s_-]*web',\n        r'darknet',\n        r'onion[\\s_-]*site'\n    ]\n    \n    # 下载操作关键词\n    download_verbs = [\n        r'\\bdownload\\b',\n        r'\\bfetch\\b',\n        r'\\bget\\b',\n        r'\\bpull\\b',\n        r'\\bwget\\b',\n        r'\\bcurl\\b',\n        r'\\bscp\\b'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查是否包含下载操作\n    has_download = False\n    for verb in download_verbs:\n        if re.search(verb, cmd_lower):\n            has_download = True\n            break\n    \n    if not has_download:\n        return False\n    \n    # 检查是否包含高风险来源\n    for keyword in darknet_keywords:\n        pattern = re.compile(keyword, re.IGNORECASE)\n        if pattern.search(command):\n            return True\n    \n    # 检查URL模式中的.onion域名（暗网特征）\n    onion_pattern = r'\\b[a-z2-7]{16,56}\\.onion\\b'\n    if re.search(onion_pattern, cmd_lower):\n        return True\n    \n    return False",
      "risk_description": ""
    }
  ]
}