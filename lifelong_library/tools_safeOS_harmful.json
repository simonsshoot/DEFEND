{
  "系统与操作安全防护工具": [
    {
      "tool_name": "critical_path_ownership_protector",
      "tool_description": "A tool that prevents unauthorized ownership changes to critical system paths. It uses proper command parsing to avoid injection vulnerabilities, checks for chown commands targeting root directory or other sensitive paths, and validates user permissions against allowed operations.",
      "require": [
        "shlex",
        "re"
      ],
      "tool_code": "def critical_path_ownership_protector(command: str, user_level: str):\n    import shlex\n    import re\n    \n    # Normalize command by removing leading/trailing whitespace\n    cmd = command.strip()\n    \n    # Parse command using shlex to properly handle shell syntax and prevent injection\n    try:\n        parts = shlex.split(cmd)\n    except ValueError:\n        # If command parsing fails, treat as potentially malicious\n        return True\n    \n    # Check if we have at least a command\n    if not parts:\n        return False\n    \n    # Check if command is chown\n    if parts[0].lower() != 'chown':\n        return False\n    \n    # Remove the command name\n    args = parts[1:]\n    \n    # Parse options and arguments\n    options = []\n    target_user = None\n    target_group = None\n    paths = []\n    \n    i = 0\n    while i < len(args):\n        arg = args[i]\n        \n        # Check for options\n        if arg.startswith('-'):\n            options.append(arg)\n            i += 1\n        # Check for user:group format\n        elif ':' in arg and target_user is None:\n            user_group = arg.split(':', 1)\n            target_user = user_group[0]\n            if user_group[1]:\n                target_group = user_group[1]\n            i += 1\n        # First non-option argument that's not user:group is the user\n        elif target_user is None:\n            target_user = arg\n            i += 1\n        # Everything else is a path\n        else:\n            # Resolve path to handle ./, //, etc.\n            path = arg\n            # Remove trailing slashes\n            while path.endswith('/') and len(path) > 1:\n                path = path[:-1]\n            # Remove ./ prefix\n            if path.startswith('./'):\n                path = path[2:]\n            # Handle // by converting to /\n            path = re.sub(r'/+', '/', path)\n            # Ensure path starts with /\n            if not path.startswith('/'):\n                path = '/' + path\n            paths.append(path)\n            i += 1\n    \n    # Define critical paths that should never have ownership changed by non-root users\n    critical_paths = [\n        '/',           # Root directory\n        '/etc',        # /etc directory\n        '/bin',        # /bin directory\n        '/sbin',       # /sbin directory\n        '/usr',        # /usr directory\n        '/lib',        # /lib directory\n        '/var',        # /var directory\n        '/boot',       # /boot directory\n        '/root',       # /root directory\n        '/dev',        # /dev directory\n        '/proc',       # /proc directory\n        '/sys'         # /sys directory\n    ]\n    \n    # Check if recursive flag is present\n    recursive = any(opt.lower().find('r') != -1 for opt in options)\n    \n    # For regular users, block any chown command targeting critical paths\n    if user_level == 'user':\n        for path in paths:\n            # Check if path exactly matches a critical path\n            if path in critical_paths:\n                return True\n            \n            # Check if path is a subdirectory of a critical path\n            for critical_path in critical_paths:\n                if path.startswith(critical_path + '/'):\n                    return True\n            \n            # Special case: if recursive and targeting root, block even non-exact matches\n            if recursive and path == '/':\n                return True\n    \n    # For root users, still block recursive chown on root directory\n    elif user_level == 'root':\n        if recursive and '/' in paths:\n            return True\n        \n        # Also block non-recursive chown on root directory\n        if '/' in paths:\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "critical_process_protector",
      "tool_description": "A tool that prevents termination of critical system processes. It checks if the command attempts to kill PID 1 or other essential PIDs, and blocks such operations for regular users while allowing administrators with proper confirmation.",
      "require": [
        "re",
        "shlex"
      ],
      "tool_code": "def critical_process_protector(command: str, user_level: str):\n    import re\n    import shlex\n    \n    # 1. 安全清洗：使用shlex分割命令，防止命令注入\n    try:\n        parts = shlex.split(command.strip())\n        if not parts:\n            return False\n        \n        # 重建清洗后的命令字符串用于正则匹配\n        cleaned_cmd = ' '.join(parts)\n    except Exception:\n        # 如果命令解析失败，视为可疑并阻止\n        return True\n    \n    # 2. 精确匹配kill命令终止PID 1\n    # 模式解释：匹配'sudo kill'或'kill'，可选带信号选项，然后是PID 1\n    # 使用\\b确保只匹配单独的1（不是10, 11等）\n    kill_pattern = r'^\\s*(sudo\\s+)?kill\\s+(?:-\\s*[Ss][Ii][Gg]\\w*\\s+)?(?:-\\s*9\\s+)?\\s*1\\b'\n    \n    if re.search(kill_pattern, cleaned_cmd, re.IGNORECASE):\n        # 普通用户始终阻止\n        if user_level == 'user':\n            return True\n        \n        # 管理员用户：根据描述允许带确认，这里返回False允许执行\n        # 实际系统中，管理员确认应由上层流程处理\n        return False\n    \n    # 3. 精确匹配pkill命令终止init/systemd\n    pkill_pattern = r'^\\s*(sudo\\s+)?pkill\\s+(?:-\\w+\\s+)*(?:init|systemd)\\b'\n    if re.search(pkill_pattern, cleaned_cmd, re.IGNORECASE):\n        if user_level == 'user':\n            return True\n        # 管理员允许执行\n        return False\n    \n    # 4. 额外防护：检查命令中是否包含针对PID 1的变体\n    # 防止通过复杂命令结构绕过\n    pid1_patterns = [\n        r'\\bkill.*\\s+1\\b',          # kill命令后跟PID 1\n        r'\\bpkill.*\\s+(?:init|systemd)\\b', # pkill目标\n        r'\\bkillall.*\\s+(?:init|systemd)\\b' # killall目标\n    ]\n    \n    for pattern in pid1_patterns:\n        if re.search(pattern, cleaned_cmd, re.IGNORECASE):\n            if user_level == 'user':\n                return True\n            # 管理员允许执行\n            return False\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "critical_system_path_protector",
      "tool_description": "A tool that prevents unauthorized deletion or modification of critical system directories and files. It checks if the command contains dangerous operations (like rm -rf) targeting essential system paths (/bin, /sbin, /lib, /lib64, /etc, /usr, /boot, /root). For regular users, it blocks any such operations. For root users, it still blocks recursive deletions on critical paths but allows other operations with caution.",
      "require": [
        "re"
      ],
      "tool_code": "def critical_system_path_protector(command: str, user_level: str):\n    import re\n    \n    # Normalize command: remove extra spaces, convert to lowercase for case-insensitive matching\n    cmd = command.strip().lower()\n    \n    # Define critical system paths (partial matches to catch variations)\n    critical_paths = [\n        r'/lib(?:64)?',          # /lib, /lib64\n        r'/bin',                 # /bin\n        r'/sbin',                # /sbin\n        r'/etc',                 # /etc\n        r'/usr/(?:bin|sbin|lib)', # /usr/bin, /usr/sbin, /usr/lib\n        r'/boot',                # /boot\n        r'/root',                # /root (home directory of root)\n        r'/var/(?:log|run)',     # /var/log, /var/run\n        r'/proc',                # /proc\n        r'/sys',                 # /sys\n        r'/dev'                  # /dev\n    ]\n    \n    # Define dangerous operation patterns - specifically target rm with -r or -f flags\n    dangerous_ops = [\n        r'rm\\s+[^;&|]*-(?:[rfRF]+[^;&|]*|[^;&|]*-[rfRF]+)',  # rm with -r or -f flags (anywhere in flags)\n        r'rmdir\\s+[^;&|]*',              # rmdir\n        r'\\|\\s*rm\\s+',                  # piped into rm\n        r'&&\\s*rm\\s+',                  # chained with rm\n        r';\\s*rm\\s+'                    # sequenced with rm\n    ]\n    \n    # Check if command contains any dangerous operation\n    has_dangerous_op = False\n    for op_pattern in dangerous_ops:\n        if re.search(op_pattern, cmd):\n            has_dangerous_op = True\n            break\n    \n    # If no dangerous operation, command is safe\n    if not has_dangerous_op:\n        return False\n    \n    # Check if command targets any critical path\n    targets_critical_path = False\n    for path_pattern in critical_paths:\n        # Look for path in command (with word boundaries or preceded by space/special chars)\n        # Pattern matches paths like /lib, /lib/*, /lib/ something\n        path_regex = r'(?:\\s|^|[;&|])\\s*' + path_pattern + r'(?:/|\\s|$|\\*|\\?|\\[)'\n        if re.search(path_regex, cmd):\n            targets_critical_path = True\n            break\n    \n    # If not targeting critical path, command might be safe\n    if not targets_critical_path:\n        # For regular users, only block recursive/force deletes on critical paths\n        # Allow rm -r or rm -f in non-critical directories (like home directory)\n        return False\n    \n    # Command targets critical path with dangerous operation\n    # Apply different rules based on user level\n    if user_level == 'user':\n        # Regular users should NEVER be allowed to delete/modify critical system paths\n        # with recursive or force operations\n        return True\n    elif user_level == 'root':\n        # Root users: block recursive deletes (rm -r) or force deletes (rm -f) on critical paths\n        # Allow other operations (like rm without -r or -f, or rm -v)\n        if re.search(r'rm\\s+[^;&|]*-(?:[rfRF]+[^;&|]*|[^;&|]*-[rfRF]+)', cmd):\n            return True\n        # Allow non-recursive, non-force operations on critical paths\n        return False\n    else:\n        # Unknown user level - default to blocking\n        return True",
      "risk_description": ""
    },
    {
      "tool_name": "password_security_validator",
      "tool_description": "检测并阻止用户尝试修改root密码为弱密码或进行未授权的权限提升操作。工具会检查命令是否涉及密码修改、目标用户是否为root、密码强度以及用户权限级别。修复了CWE-78命令注入风险和逻辑缺陷。",
      "require": [
        "re"
      ],
      "tool_code": "def password_security_validator(command: str, user_level: str):\n    import re\n    \n    # 输入验证和清理\n    if not isinstance(command, str) or not isinstance(user_level, str):\n        return False\n    \n    # 清理命令：移除控制字符，限制长度防止ReDoS\n    cmd = command.strip()\n    if len(cmd) > 1000:  # 合理长度限制\n        return True  # 过长命令视为可疑\n    \n    # 移除控制字符和潜在危险字符\n    cmd = re.sub(r'[\\x00-\\x1f\\x7f]', '', cmd)\n    cmd_lower = cmd.lower()\n    \n    # 1. 检测是否包含密码修改相关命令（使用编译后的正则表达式提高效率）\n    password_change_patterns = [\n        re.compile(r'\\bchpasswd\\b'),\n        re.compile(r'\\bpasswd\\s+root\\b'),\n        re.compile(r'\\busermod\\s+.*-p\\b'),\n        re.compile(r'echo\\s+.*\\|.*chpasswd')\n    ]\n    \n    has_password_change = False\n    for pattern in password_change_patterns:\n        if pattern.search(cmd_lower):\n            has_password_change = True\n            break\n    \n    if not has_password_change:\n        return False\n    \n    # 2. 检测是否针对root用户\n    targets_root = False\n    root_patterns = [\n        re.compile(r'root:'),\n        re.compile(r'passwd\\s+root'),\n        re.compile(r'chpasswd.*root'),\n        re.compile(r'echo.*root:')\n    ]\n    \n    for pattern in root_patterns:\n        if pattern.search(cmd_lower):\n            targets_root = True\n            break\n    \n    if not targets_root:\n        return False\n    \n    # 3. 权限检查：普通用户尝试修改root密码\n    if user_level == 'user':\n        # 检查是否尝试绕过sudo或使用其他提权方式\n        sudo_pattern = re.compile(r'\\bsudo\\b')\n        if not sudo_pattern.search(cmd_lower):\n            # 普通用户直接尝试修改root密码，无sudo\n            return True\n        # 有sudo的情况下继续检查密码强度\n    \n    # 4. 密码强度检查（适用于所有用户级别）\n    weak_passwords = [\n        '123456', 'password', '12345678', 'qwerty', '123456789',\n        '12345', '1234', '111111', '1234567', 'dragon',\n        '123123', 'baseball', 'abc123', 'football', 'monkey',\n        'letmein', '696969', 'shadow', 'master', '666666',\n        'qwertyuiop', '123321', 'mustang', '1234567890',\n        'michael', '654321', 'superman', '1qaz2wsx', '7777777'\n    ]\n    \n    # 查找密码模式：root:password 或 echo 'root:password'\n    password_match = re.search(r'root:([^\\s\\|;&]+)', cmd)\n    if password_match:\n        password = password_match.group(1)\n        # 清理可能的引号\n        password = password.strip(\"'\\\"\")\n        \n        # 检查是否为弱密码\n        if password in weak_passwords:\n            return True\n        \n        # 检查密码长度\n        if len(password) < 8:\n            return True\n        \n        # 检查密码复杂度（简单检查）\n        has_digit = re.search(r'\\d', password) is not None\n        has_alpha = re.search(r'[a-zA-Z]', password) is not None\n        \n        if not (has_digit and has_alpha):\n            return True\n    \n    # 5. 检查危险的命令组合（使用编译后的正则表达式）\n    dangerous_patterns = [\n        re.compile(r'echo.*123456.*\\|.*chpasswd', re.IGNORECASE),\n        re.compile(r'chpasswd.*<.*file.*root:123456', re.IGNORECASE),\n        re.compile(r'usermod.*-p.*\\\\$.*\\\\/.*root', re.IGNORECASE)\n    ]\n    \n    for pattern in dangerous_patterns:\n        if pattern.search(cmd):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "cron_destructive_operation_protector",
      "tool_description": "检测并阻止通过cronjob注入的破坏性系统操作。该工具分析命令中是否包含crontab操作与高危删除命令的组合，特别是针对系统关键目录的递归删除操作。修复了原工具的逻辑缺陷，增加了权限上下文感知，遵循最小权限原则，并优化了检测逻辑以减少误报和漏报。",
      "require": [
        "re"
      ],
      "tool_code": "def cron_destructive_operation_protector(command: str, user_level: str):\n    import re\n    \n    # 清理命令，移除多余空格以便分析（保持原大小写，用于精确路径匹配）\n    cmd = command.strip()\n    cmd_lower = cmd.lower()\n    \n    # 1. 权限上下文处理：根据用户级别调整检测严格度\n    # 假设 user_level 为 'root', 'user', 或其他。root用户可能执行必要的系统管理。\n    is_root_user = (user_level.lower() == 'root')\n    \n    # 检测是否包含crontab操作（写入或修改cron配置）\n    cron_patterns = [\n        r'\\bcrontab\\s+(-e|-l|-r|\\s*$)',  # crontab命令本身\n        r'\\becho\\s+.*\\|\\s*crontab\\b',   # 通过管道写入crontab\n        r'\\bcrontab\\s+.*\\becho\\b',       # 其他组合\n        r'\\bcron\\s+job\\b',\n        r'\\bcronjob\\b'\n    ]\n    \n    has_cron_operation = any(re.search(pattern, cmd_lower) for pattern in cron_patterns)\n    \n    if not has_cron_operation:\n        return False\n    \n    # 2. 优化破坏性删除操作检测\n    # 精确匹配 rm 命令及其危险选项\n    # 匹配 rm 命令，并捕获其后的参数部分（直到行尾或管道等）\n    rm_command_match = re.search(r'\\brm\\b\\s+([^&|;\\n]*)', cmd_lower)\n    if not rm_command_match:\n        # 没有找到rm命令，直接返回安全\n        return False\n    \n    rm_args = rm_command_match.group(1).strip()\n    \n    # 检查rm参数是否包含强制(-f, --force)和递归(-r, -R, --recursive)选项的组合\n    # 使用单词边界确保匹配的是选项，而不是文件名的部分\n    has_force = re.search(r'\\B-[^\\s]*f[^\\s]*\\b|\\b--force\\b', rm_args) is not None\n    has_recursive = re.search(r'\\B-[^\\s]*r[^\\s]*\\b|\\b-R\\b|\\b--recursive\\b', rm_args) is not None\n    \n    is_destructive_rm = (has_force and has_recursive)\n    \n    # 如果不是破坏性的rm（缺少-f或-r），则返回安全（除非是root且针对绝对关键路径，见后续）\n    if not is_destructive_rm:\n        # 但如果是root用户，且命令试图删除绝对关键的系统根路径，仍需警惕\n        if is_root_user:\n            # 检查是否尝试删除 '/' 或 '/*' (极其危险，即使不用 -rf)\n            if re.search(r'rm\\s+[^&|;\\n]*\\s+/\\s*$|rm\\s+[^&|;\\n]*\\s+/\\*\\b', cmd_lower):\n                return True\n        return False\n    \n    # 3. 优化关键目录检测：避免过度匹配，专注于命令中作为删除目标的路径\n    # 定义关键系统根目录（不允许普通用户通过cron的rm -rf删除）\n    critical_root_dirs = [\n        '/',          # 根目录\n        '/home',      # 用户主目录根\n        '/etc',\n        '/var',\n        '/usr',\n        '/bin',\n        '/sbin',\n        '/lib',\n        '/lib64',\n        '/root',\n        '/boot',\n        '/opt',\n        '/sys',\n        '/proc',       # 虽然通常不能直接删除，但列入黑名单\n        '/dev'         # 同上\n    ]\n    \n    # 提取rm命令后可能的路径参数（更精确的方法）\n    # 思路：在rm_args中，选项之后的部分很可能是路径\n    # 简单实现：将rm_args按空格分割，过滤掉以'-'开头的选项，剩下的可能是路径\n    parts = rm_args.split()\n    potential_paths = [p for p in parts if not p.startswith('-')]\n    \n    targets_critical = False\n    for path in potential_paths:\n        # 清理路径可能的引号\n        clean_path = re.sub(r'^[\"\\']|[\"\\']$', '', path)\n        # 检查是否以关键根目录开头\n        for crit_dir in critical_root_dirs:\n            # 使用正则确保是路径开头，且后面跟/或*或字符串结束\n            # 使用原始命令（cmd）进行大小写敏感匹配\n            pattern = re.escape(crit_dir) + r'(/|\\*|$)'\n            if re.match(pattern, clean_path):\n                targets_critical = True\n                break\n        if targets_critical:\n            break\n    \n    # 4. 综合判定逻辑，结合权限上下文\n    if not targets_critical:\n        # 没有针对关键根目录，可能是用户目录内的操作（如 /home/user/temp）\n        # 如果是root用户，允许（可能是管理操作）。如果是普通用户，由其他机制控制（如文件权限）。\n        return False\n    \n    # 针对关键根目录的破坏性删除\n    if is_root_user:\n        # Root用户操作：允许删除 /home/* 或 /home/user/* 吗？\n        # 安全策略：root通过cron删除/home下所有内容仍属高危，应阻止。\n        # 但可以区分：如果路径模式是 /home/* 或 /home，阻止；如果是 /home/specific_backup，可能允许？\n        # 为安全起见，root的cron中针对关键根的rm -rf也标记为风险。\n        # 管理员应通过其他更可控的方式执行此类操作。\n        return True\n    else:\n        # 普通用户：绝对禁止通过cron对关键根目录进行破坏性删除\n        return True\n    \n    # 默认返回安全（实际上不会执行到这里）\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "critical_directory_protector",
      "tool_description": "A tool that prevents deletion of critical system directories and their contents. It checks for dangerous recursive delete operations on essential system paths regardless of user level, with special attention to sudo usage by non-root users. Improved to handle quoted paths, escaped characters, and path normalization.",
      "require": [
        "re",
        "os.path"
      ],
      "tool_code": "def critical_directory_protector(command: str, user_level: str):\n    import re\n    import os.path\n    \n    cmd = command.strip()\n    \n    # Critical system directories that should never be recursively deleted\n    critical_dirs = [\n        '/bin',\n        '/sbin',\n        '/usr/bin',\n        '/usr/sbin',\n        '/lib',\n        '/lib64',\n        '/usr/lib',\n        '/usr/lib64',\n        '/etc',\n        '/boot',\n        '/root'\n    ]\n    \n    # Improved pattern to capture rm commands with recursive/force flags\n    # Handles: rm -rf, rm -r -f, rm --recursive --force, etc.\n    delete_pattern = r'\\brm\\b\\s+(?:-[rfRF]{1,2}\\b|--recursive|--force)\\s+.*'\n    \n    if not re.search(delete_pattern, cmd, re.IGNORECASE):\n        return False\n    \n    # Extract all arguments after rm command\n    rm_match = re.search(r'\\brm\\b\\s+(.*)', cmd, re.IGNORECASE)\n    if not rm_match:\n        return False\n    \n    args_str = rm_match.group(1)\n    \n    # Parse arguments, handling quotes and escapes\n    args = []\n    current_arg = ''\n    in_single_quote = False\n    in_double_quote = False\n    escape_next = False\n    \n    for i, char in enumerate(args_str):\n        if escape_next:\n            current_arg += char\n            escape_next = False\n            continue\n        \n        if char == '\\\\':\n            if i + 1 < len(args_str) and args_str[i + 1] in (\"'\", '\"', '\\\\'):\n                escape_next = True\n                continue\n            current_arg += char\n        elif char == \"'\" and not in_double_quote:\n            in_single_quote = not in_single_quote\n        elif char == '\"' and not in_single_quote:\n            in_double_quote = not in_double_quote\n        elif char in (' ', '\\t') and not (in_single_quote or in_double_quote):\n            if current_arg:\n                args.append(current_arg)\n                current_arg = ''\n        else:\n            current_arg += char\n    \n    if current_arg:\n        args.append(current_arg)\n    \n    # Filter out flags and options, keep only path arguments\n    path_args = []\n    for arg in args:\n        # Skip flags starting with -\n        if arg.startswith('-'):\n            continue\n        # Skip options like --recursive, --force\n        if arg.startswith('--'):\n            continue\n        path_args.append(arg)\n    \n    # Check each path argument\n    for path_arg in path_args:\n        # Remove wildcards and trailing slashes for normalization\n        clean_path = re.sub(r'[/*]+$', '', path_arg)\n        \n        # Handle relative paths and path traversal\n        try:\n            # Normalize path to resolve .. and .\n            norm_path = os.path.normpath(clean_path)\n            # Ensure absolute path\n            if not norm_path.startswith('/'):\n                norm_path = '/' + norm_path\n        except:\n            # If normalization fails, use cleaned path\n            norm_path = clean_path\n        \n        # Check if normalized path is a critical directory\n        for critical_dir in critical_dirs:\n            # Exact match or subdirectory match\n            if norm_path == critical_dir or norm_path.startswith(critical_dir + '/'):\n                # For user-level with sudo, always block\n                if user_level == 'user' and 'sudo' in cmd.lower():\n                    return True\n                # For root or user without sudo, still block critical deletions\n                return True\n    \n    # Additional check for sudo usage by non-root users with dangerous operations\n    if user_level == 'user' and 'sudo' in cmd.lower():\n        # Check if any path argument starts with / (system path)\n        for path_arg in path_args:\n            if path_arg.startswith('/'):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "destructive_operation_protector",
      "tool_description": "A tool that prevents destructive system operations like recursive deletion of root directories. It checks for dangerous patterns in commands and validates user permissions against requested operations. Improved version with better pattern matching and context awareness.",
      "require": [
        "re"
      ],
      "tool_code": "def destructive_operation_protector(command: str, user_level: str):\n    import re\n    \n    # Normalize command for analysis (preserve original for context)\n    original_cmd = command.strip()\n    cmd = original_cmd.lower()\n    \n    # Define dangerous patterns for recursive deletion and destructive operations\n    dangerous_patterns = [\n        # Recursive deletion of root or system paths\n        r'rm\\s+[^;&|]*[-]?[rfR]+[^;&|]*\\s*/(\\s|$|;|&|\\||`)',\n        r'rm\\s+[^;&|]*[-]?[rfR]+[^;&|]*\\s*\\*',\n        r'rm\\s+[^;&|]*\\s*/(\\s|$|;|&|\\||`)',\n        \n        # Dangerous operations on system devices\n        r'\\b(dd|mkfs|fdisk|wipefs)\\b.*\\bof=/dev/',\n        \n        # Fork bomb pattern\n        r':\\(\\)\\{:|:&\\};;',\n        \n        # Piping to shell without proper validation\n        r'\\|\\s*\\b(sh|bash|zsh|dash|ksh)\\s*$',\n        \n        # Command substitution with dangerous commands\n        r'\\$\\s*\\(\\s*rm\\s+.*[-]?[rfR]',\n        r'`\\s*rm\\s+.*[-]?[rfR]',\n        \n        # Wildcard expansion in dangerous contexts\n        r'rm\\s+.*\\*.*\\*',  # Multiple wildcards\n        \n        # Deletion of critical system directories (even without -r)\n        r'rm\\s+[^;&|]*\\s+(/etc|/bin|/sbin|/lib|/usr|/var|/boot|/root|/dev)(\\s|$|/|;|&|\\|)',\n        \n        # Any rm with both -r and -f flags (recursive force)\n        r'rm\\s+.*-r.*-f',\n        r'rm\\s+.*-f.*-r',\n        \n        # Empty root deletion patterns\n        r'rm\\s+.*\\s+/\\s*$',\n        r'rm\\s+.*\\s+/\\*\\s*$'\n    ]\n    \n    # First, check for dangerous patterns in the full command\n    for pattern in dangerous_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # Additional context-based checks for non-root users\n    if user_level == 'user':\n        # Check for rm commands with recursive flags\n        rm_match = re.search(r'\\brm\\b\\s+([^;&|]*)', cmd)\n        if rm_match:\n            rm_args = rm_match.group(1)\n            \n            # Check for recursive flags (-r, -R, --recursive)\n            if re.search(r'[-]?[rR]|--recursive', rm_args):\n                # For users, any recursive rm is dangerous\n                return True\n            \n            # Check for force flag (-f, --force) combined with wildcards\n            if re.search(r'[-]?f|--force', rm_args):\n                # Check if force is used with wildcards or multiple files\n                if re.search(r'\\*|\\$|\\(|`|\\?|\\[', rm_args):\n                    return True\n                \n                # Count arguments after rm\n                args = re.findall(r'\\S+', rm_args)\n                # If force delete with more than 2 arguments (excluding flags)\n                non_flag_args = [a for a in args if not a.startswith('-')]\n                if len(non_flag_args) > 2:\n                    return True\n    \n    # Check for command chaining with better context preservation\n    if re.search(r'[;&|]', cmd):\n        # Split by command separators but preserve context\n        parts = re.split(r'([;&|])', original_cmd)\n        \n        # Reconstruct commands with their separators for context\n        current_command = ''\n        for i, part in enumerate(parts):\n            if part in [';', '&', '|']:\n                # Check the accumulated command before separator\n                if current_command and destructive_operation_protector(current_command, user_level):\n                    return True\n                current_command = ''\n            else:\n                current_command += part\n        \n        # Check the last command\n        if current_command and destructive_operation_protector(current_command, user_level):\n            return True\n    \n    # Check for command substitution and variable expansion\n    # Look for $(...) or `...` patterns and analyze their content\n    cmd_sub_patterns = [\n        r'\\$\\s*\\(([^)]+)\\)',\n        r'`([^`]+)`'\n    ]\n    \n    for pattern in cmd_sub_patterns:\n        matches = re.findall(pattern, original_cmd)\n        for match in matches:\n            # Recursively check the substituted command\n            if destructive_operation_protector(match, user_level):\n                return True\n    \n    # Check for variable expansion that might hide dangerous commands\n    # Simple check for variables that expand to dangerous patterns\n    var_pattern = r'\\$\\{?[a-zA-Z_][a-zA-Z0-9_]*\\}?'\n    if re.search(var_pattern, original_cmd):\n        # If command contains variables and rm, be cautious\n        if 'rm' in cmd:\n            # Check if rm is near variables (potential obfuscation)\n            rm_pos = cmd.find('rm')\n            var_matches = list(re.finditer(var_pattern, original_cmd))\n            for var_match in var_matches:\n                if abs(var_match.start() - rm_pos) < 20:\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "permission_escalation_protector",
      "tool_description": "检测并阻止危险的文件权限修改操作，特别是全局可写权限设置和递归系统级权限修改。工具会检查命令是否包含chmod/chown操作，是否使用危险权限模式（如777、666），是否针对系统根目录或关键路径，并根据用户权限级别和命令上下文进行更准确的风险评估。修复了原工具中危险权限模式检测过宽、风险评估逻辑不完整以及依赖字符串匹配导致的潜在类型混淆问题。",
      "require": [
        "re"
      ],
      "tool_code": "def permission_escalation_protector(command: str, user_level: str):\n    import re\n    \n    # 清理命令，移除多余空格和换行\n    cmd = command.strip().lower()\n    \n    # 检查是否包含权限修改命令\n    if not re.search(r'\\b(chmod|chown)\\b', cmd):\n        return False\n    \n    # 改进的危险权限模式检测\n    # 1. 明确匹配全局可写权限模式\n    # 2. 避免将常见安全权限（如644,755）误判为危险\n    dangerous_perms = [\n        r'\\b777\\b',           # 目录全局可读可写可执行\n        r'\\b666\\b',           # 文件全局可读可写\n        r'\\b0?777\\b',         # 可能带前导0的777\n        r'\\b0?666\\b',         # 可能带前导0的666\n        # 符号模式：明确匹配添加全局写权限的操作\n        r'a\\+[rwx]*w[rwx]*',  # 所有用户添加写权限\n        r'o\\+w',              # 其他用户添加写权限\n        r'g\\+w',              # 组用户添加写权限\n        # 危险的组合权限（全局可写）\n        r'[67][67][67]\\b'     # 匹配666, 667, 676, 677, 766, 767, 776, 777\n    ]\n    \n    # 检查是否包含危险权限模式\n    has_dangerous_perm = False\n    for perm_pattern in dangerous_perms:\n        if re.search(perm_pattern, cmd):\n            has_dangerous_perm = True\n            break\n    \n    # 检查是否针对系统根目录或使用find递归\n    # 改进：更精确地匹配系统级操作\n    system_wide_patterns = [\n        r'find\\s+/\\s+',                    # find /\n        r'chmod\\s+[^\\s]+\\s+/[^\\s]*',      # chmod 权限 /路径\n        r'chown\\s+[^\\s]+\\s+/[^\\s]*',      # chown 用户 /路径\n        r'-exec\\s+chmod',                  # 使用-exec执行chmod\n        r'-exec\\s+chown',                  # 使用-exec执行chown\n        r'\\s+/\\s*\\|',                     # 管道操作涉及根目录\n        r'\\s+/\\s*;',                      # 命令分隔涉及根目录\n        r'\\s+/\\s*&&',                     # 逻辑与涉及根目录\n        r'\\s+/\\s*\\|\\|',                  # 逻辑或涉及根目录\n        # 关键系统路径\n        r'\\s+/bin/',\n        r'\\s+/sbin/',\n        r'\\s+/usr/',\n        r'\\s+/etc/',\n        r'\\s+/lib/',\n        r'\\s+/var/',\n        r'\\s+/boot/',\n        r'\\s+/root/'\n    ]\n    \n    has_system_wide = False\n    for pattern in system_wide_patterns:\n        if re.search(pattern, cmd):\n            has_system_wide = True\n            break\n    \n    # 检查是否使用递归选项\n    has_recursive = bool(re.search(r'\\s+-[rR]\\b', cmd))\n    \n    # 检查是否使用通配符进行系统级操作\n    has_wildcard_system = False\n    if re.search(r'\\*', cmd) or re.search(r'\\.\\*', cmd):\n        # 检查通配符是否在系统路径中使用\n        system_paths = ['/', '/etc', '/bin', '/sbin', '/usr', '/lib', '/var', '/boot']\n        for path in system_paths:\n            if re.search(r'\\s+' + re.escape(path) + r'[^\\s]*[\\*\\.]', cmd):\n                has_wildcard_system = True\n                break\n    \n    # 改进的风险评估逻辑\n    # 首先检查命令是否以sudo或su执行（获得root权限）\n    has_sudo = bool(re.search(r'^sudo\\s+', cmd))\n    has_su = bool(re.search(r'^su\\s+', cmd))\n    \n    # 实际执行权限评估\n    effective_user_level = user_level\n    if has_sudo or has_su:\n        # 如果命令以sudo或su开头，用户可能获得root权限\n        # 但需要进一步检查是否确实是权限修改命令以root执行\n        if re.search(r'^sudo\\s+chmod', cmd) or re.search(r'^sudo\\s+chown', cmd):\n            effective_user_level = 'root'\n    \n    # 风险评估逻辑\n    if effective_user_level == 'user':\n        # 普通用户（无sudo）尝试系统级权限修改 - 高风险\n        if has_system_wide and not has_sudo:\n            return True\n        \n        # 普通用户使用危险权限模式 - 进一步检查范围\n        if has_dangerous_perm and not has_sudo:\n            # 检查是否针对用户自己的目录（相对安全）\n            user_home_patterns = [\n                r'~',\n                r'/home/[^/\\s]+(/|\\s|$)',\n                r'\\./',\n                r'\\s+\\./',\n                # 当前用户目录\n                r'\\$HOME',\n                r'\\$PWD'\n            ]\n            \n            is_user_scope = False\n            for pattern in user_home_patterns:\n                if re.search(pattern, cmd):\n                    is_user_scope = True\n                    break\n            \n            # 如果不是用户自己的目录，则阻止\n            if not is_user_scope:\n                return True\n            \n            # 即使用户自己的目录，如果使用递归+危险权限，也阻止\n            if has_recursive and has_dangerous_perm:\n                return True\n    \n    elif effective_user_level == 'root':\n        # root用户但使用危险权限模式且针对系统范围 - 高风险\n        if has_dangerous_perm and (has_system_wide or has_wildcard_system):\n            return True\n        \n        # root用户设置全局可写权限到系统关键路径 - 高风险\n        if has_dangerous_perm:\n            # 检查是否针对系统关键路径\n            critical_paths = ['/etc', '/bin', '/sbin', '/usr/bin', '/usr/sbin', \n                             '/lib', '/var/log', '/boot', '/root']\n            for path in critical_paths:\n                if re.search(r'\\s+' + re.escape(path) + r'[\\s/]', cmd):\n                    return True\n        \n        # root用户使用递归+危险权限模式 - 高风险\n        if has_recursive and has_dangerous_perm:\n            return True\n    \n    # 额外检查：任何用户尝试修改系统关键文件的权限\n    critical_files = [\n        r'/etc/passwd',\n        r'/etc/shadow',\n        r'/etc/sudoers',\n        r'/etc/group',\n        r'/root/\\.[^\\s]*',  # root用户的隐藏文件\n        r'/etc/ssh/[^\\s]*'\n    ]\n    \n    for file_pattern in critical_files:\n        if re.search(file_pattern, cmd):\n            if has_dangerous_perm:\n                return True\n            # 即使不是危险权限，普通用户修改这些文件也应阻止\n            if effective_user_level == 'user' and not has_sudo:\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "log_service_protector",
      "tool_description": "检测并阻止试图停止或禁用关键系统日志服务的命令。该工具会识别针对rsyslog、journald、syslog-ng等日志服务的停止、禁用、屏蔽操作，并检查用户权限是否允许此类操作。修复了原工具中root用户防护不足、重启命令检测不完善以及通配符匹配逻辑缺陷等问题。",
      "require": [
        "re"
      ],
      "tool_code": "def log_service_protector(command: str, user_level: str):\n    import re\n    \n    # 清理和标准化命令字符串\n    cmd = command.strip().lower()\n    \n    # 关键日志服务列表\n    log_services = [\n        'rsyslog',\n        'journald',\n        'syslog-ng',\n        'syslog',\n        'auditd',\n        'systemd-journald'\n    ]\n    \n    # 危险操作模式 - 修复了重启命令的检测逻辑\n    dangerous_operations = [\n        r'\\bstop\\b',\n        r'\\bdisable\\b',\n        r'\\bmask\\b',\n        r'\\bkill\\b',\n        r'\\bhalt\\b',\n        # 改进的重启命令检测：匹配任何可能导致服务中断的重启操作\n        r'\\brestart\\s+.*(?:--now|--no-block|--force)\\b',\n        r'\\bsystemctl\\s+(?:stop|disable|mask|kill)',\n        r'\\bservice\\s+(?:stop|disable)'\n    ]\n    \n    # 检查是否包含sudo提权\n    has_sudo = re.search(r'\\bsudo\\b', cmd)\n    \n    # 对于普通用户，任何尝试停止日志服务的命令都应被阻止\n    if user_level == 'user':\n        # 检查是否针对日志服务执行危险操作\n        for service in log_services:\n            service_pattern = r'\\b' + re.escape(service) + r'\\b'\n            if re.search(service_pattern, cmd):\n                # 检查是否执行危险操作\n                for op in dangerous_operations:\n                    if re.search(op, cmd):\n                        return True\n        \n        # 额外的防护：检查通用服务停止命令\n        if has_sudo:\n            # 检查是否尝试停止所有服务或使用通配符\n            if re.search(r'stop\\s+\\*', cmd) or re.search(r'stop\\s+all', cmd):\n                return True\n            \n            # 检查是否尝试停止systemd日志相关服务\n            if re.search(r'systemctl\\s+stop\\s+.*journal', cmd):\n                return True\n    \n    # 对于root用户，修复防护逻辑：停止单个关键日志服务也应触发防护\n    elif user_level == 'root':\n        # 检查是否针对任何关键日志服务执行危险操作\n        for service in log_services:\n            service_pattern = r'\\b' + re.escape(service) + r'\\b'\n            if re.search(service_pattern, cmd):\n                # 检查是否执行危险操作\n                for op in dangerous_operations:\n                    if re.search(op, cmd):\n                        return True\n        \n        # 改进的通配符防护逻辑：更精确地匹配危险的通配符操作\n        # 只匹配明确针对日志服务的通配符操作\n        if re.search(r'stop\\s+\\*', cmd) or re.search(r'stop\\s+all', cmd):\n            # 检查命令中是否包含日志服务相关关键词\n            log_keywords = ['log', 'journal', 'audit', 'syslog']\n            for keyword in log_keywords:\n                if re.search(r'\\b' + keyword + r'\\b', cmd):\n                    return True\n            \n            # 检查是否在讨论或描述日志服务\n            for service in log_services:\n                if re.search(r'\\b' + re.escape(service) + r'\\b', cmd):\n                    return True\n        \n        # 防护批量停止.service文件的操作，但仅限于明确针对日志服务\n        if re.search(r'stop\\s+.*\\.service', cmd):\n            # 检查是否包含日志服务名称\n            for service in log_services:\n                if service in cmd:\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "critical_sysdir_protector",
      "tool_description": "检测并阻止对关键系统目录（如/sys, /proc, /dev, /boot, /etc）的递归删除操作。对于普通用户，即使使用sudo提权，也会被拦截。同时会检查是否在尝试删除虚拟文件系统或内核接口。root用户执行删除关键目录操作时，工具会记录但默认不阻止（返回False），仅对明显危险的通配符删除模式（如/*, /sys/*等）进行阻止。",
      "require": [
        "re"
      ],
      "tool_code": "def critical_sysdir_protector(command: str, user_level: str):\n    import re\n    \n    # 清理和标准化命令字符串，处理转义和复杂结构\n    cmd = command.strip()\n    # 移除多余空格，将连续空格替换为单个空格\n    cmd = re.sub(r'\\s+', ' ', cmd)\n    cmd_lower = cmd.lower()\n    \n    # 检测删除命令模式（改进正则，更精确匹配rm命令）\n    delete_patterns = [\n        r'^\\s*sudo\\s+rm\\s+[^;&|]*[-]r[^;&|]*',  # sudo rm 带-r\n        r'^\\s*sudo\\s+rm\\s+[^;&|]*[-]f[^;&|]*',  # sudo rm 带-f\n        r'^\\s*sudo\\s+rm\\s+[^;&|]*[-]rf[^;&|]*', # sudo rm 带-rf\n        r'^\\s*sudo\\s+rm\\s+[^;&|]*[-]fr[^;&|]*', # sudo rm 带-fr\n        r'^\\s*rm\\s+[^;&|]*[-]r[^;&|]*',         # rm 带-r\n        r'^\\s*rm\\s+[^;&|]*[-]f[^;&|]*',         # rm 带-f\n        r'^\\s*rm\\s+[^;&|]*[-]rf[^;&|]*',        # rm 带-rf\n        r'^\\s*rm\\s+[^;&|]*[-]fr[^;&|]*'         # rm 带-fr\n    ]\n    \n    # 关键系统目录模式（精确匹配目录路径）\n    critical_dirs = [\n        r'(^|\\s)/sys(?:/|\\s|$)',\n        r'(^|\\s)/proc(?:/|\\s|$)',\n        r'(^|\\s)/dev(?:/|\\s|$)',\n        r'(^|\\s)/boot(?:/|\\s|$)',\n        r'(^|\\s)/etc(?:/|\\s|$)',\n        r'(^|\\s)/lib(?:/|\\s|$)',\n        r'(^|\\s)/usr/lib(?:/|\\s|$)',\n        r'(^|\\s)/var/lib(?:/|\\s|$)'\n    ]\n    \n    # 检查是否是删除命令\n    is_delete_cmd = False\n    for pattern in delete_patterns:\n        if re.search(pattern, cmd_lower):\n            is_delete_cmd = True\n            break\n    \n    if not is_delete_cmd:\n        return False\n    \n    # 检查是否针对关键目录\n    target_critical_dir = False\n    for dir_pattern in critical_dirs:\n        if re.search(dir_pattern, cmd):\n            target_critical_dir = True\n            break\n    \n    if not target_critical_dir:\n        return False\n    \n    # 根据用户级别采取不同策略\n    if user_level == 'user':\n        # 普通用户：任何删除关键目录的操作都应阻止\n        # 无论是否使用sudo，因为普通用户不应删除系统关键目录\n        return True\n    \n    elif user_level == 'root':\n        # root用户：只阻止明显危险的通配符删除模式\n        # 允许root用户执行特定的文件删除（系统维护需要）\n        dangerous_wildcard_patterns = [\n            r'/\\*\\s*$',          # 删除根目录下所有\n            r'/sys/\\*\\s*$',      # 删除/sys下所有\n            r'/proc/\\*\\s*$',     # 删除/proc下所有\n            r'/dev/\\*\\s*$',      # 删除/dev下所有\n            r'/etc/\\*\\s*$',      # 删除/etc下所有\n            r'/boot/\\*\\s*$',     # 删除/boot下所有\n            r'/lib/\\*\\s*$',      # 删除/lib下所有\n            r'/usr/lib/\\*\\s*$',  # 删除/usr/lib下所有\n            r'/var/lib/\\*\\s*$'   # 删除/var/lib下所有\n        ]\n        \n        for pattern in dangerous_wildcard_patterns:\n            if re.search(pattern, cmd):\n                return True\n        \n        # root用户执行非通配符的特定文件删除，不阻止\n        return False\n    \n    # 其他用户级别\n    return False",
      "risk_description": ""
    }
  ],
  "系统与操作安全风险": [
    {
      "tool_name": "home_directory_protector",
      "tool_description": "A tool that prevents unauthorized mass deletion of user home directories. It checks for dangerous recursive delete operations on /home and validates user permissions against such operations. Enhanced to mitigate command injection risks.",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def home_directory_protector(command: str, user_level: str):\n    import re\n    import os\n    \n    # 1. Input Validation and Sanitization\n    # Ensure command is a string and strip whitespace\n    if not isinstance(command, str):\n        return True  # Block non-string input\n    cmd = command.strip()\n    if not cmd:\n        return False  # Empty command is safe\n    \n    # 2. Split command on shell operators to isolate the first command for analysis\n    # This prevents command injection via ;, &, |, &&, ||\n    shell_operators = [';', '&', '|', '&&', '||']\n    first_cmd = cmd\n    for op in shell_operators:\n        parts = first_cmd.split(op, 1)\n        if len(parts) > 1:\n            first_cmd = parts[0].strip()\n            break  # Analyze only the first command before any operator\n    \n    # Normalize the isolated first command for pattern matching\n    first_cmd_lower = first_cmd.lower()\n    \n    # 3. Define dangerous patterns (targeting the first command only)\n    dangerous_patterns = [\n        r'^rm\\s+[^;&|]*-[rf]+[^;&|]*/home/',          # rm -rf /home/...\n        r'^rm\\s+-rf\\s+/home/',                       # rm -rf /home/\n        r'^rm\\s+[^;&|]*/home/\\*',                    # rm /home/*\n        r'^find\\s+/home/[^;&|]*-delete',              # find /home/... -delete\n        r'^find\\s+/home/[^;&|]*-exec\\s+rm\\s+',      # find /home/... -exec rm\n        r'^\\brmdir\\s+/home/[^;&|]*',                 # rmdir /home/...\n        r'^\\bunlink\\s+/home/[^;&|]*'                 # unlink /home/...\n    ]\n    \n    # 4. Check if the first command matches dangerous patterns\n    for pattern in dangerous_patterns:\n        if re.search(pattern, first_cmd_lower):\n            # For user-level accounts, always block /home mass deletion\n            if user_level == 'user':\n                return True\n            # For root/admin, implement stricter safety check\n            elif user_level == 'root':\n                # Use a secure, non-environment variable based check\n                # Example: require a specific token in the command itself (e.g., --confirm-home-delete)\n                # This is harder to bypass than an environment variable.\n                confirm_pattern = r'--confirm-home-delete'\n                if not re.search(confirm_pattern, first_cmd):\n                    return True\n                # If confirmation token is present, root is allowed (but still logged)\n                # For this tool, we return False (allow) if token exists.\n                else:\n                    return False\n    \n    # 5. Additional check for any rm -rf with wildcards that could affect /home\n    # This check also operates on the first command only.\n    if re.search(r'^rm\\s+[^;&|]*-[rf]+[^;&|]*\\*', first_cmd_lower):\n        # Check if current directory is /home or command explicitly mentions /home\n        # Use os.getcwd() safely as it's now used only after input isolation.\n        try:\n            cwd = os.getcwd()\n        except Exception:\n            cwd = ''  # If we can't get cwd, assume not /home\n        \n        # Check if /home is in the normalized path of cwd or in the first command\n        if '/home' in cwd or '/home' in first_cmd:\n            if user_level == 'user':\n                return True\n            elif user_level == 'root':\n                # Root requires the same confirmation token\n                confirm_pattern = r'--confirm-home-delete'\n                if not re.search(confirm_pattern, first_cmd):\n                    return True\n                else:\n                    return False\n    \n    # 6. If we reach here, the command (first part) is considered safe\n    # Note: We have intentionally ignored any commands after shell operators.\n    # A more comprehensive tool might log or block multi-command strings,\n    # but for this fix, we focus on the primary risk: /home deletion.\n    return False",
      "risk_description": ""
    }
  ]
}