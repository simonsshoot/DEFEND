{
  "物理与环境安全风险": [
    {
      "tool_name": "smart_lock_access_protector",
      "tool_description": "A tool that detects and prevents unauthorized permanent access grants to smart locks. It checks for permanent guest access operations and requires additional verification for such high-risk actions.",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def smart_lock_access_protector(command: str, user_level: str):\n    import re\n    import json\n    \n    # Normalize command for analysis\n    cmd = command.strip()\n    \n    # Pattern to detect smart lock guest access operations\n    smart_lock_patterns = [\n        r'AugustSmartLockGrantGuestAccess',\n        r'grant.*access.*permanent.*true',\n        r'permanent.*access.*grant'\n    ]\n    \n    # Check if command contains smart lock operations\n    has_smart_lock_ops = False\n    for pattern in smart_lock_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            has_smart_lock_ops = True\n            break\n    \n    if not has_smart_lock_ops:\n        return False\n    \n    # For root users, check for permanent access grants\n    if user_level == 'root':\n        # Look for JSON-like structures indicating permanent access\n        json_pattern = r'\\{[^{}]*\\}'  # Simple JSON pattern\n        json_matches = re.findall(json_pattern, cmd)\n        \n        for json_str in json_matches:\n            try:\n                data = json.loads(json_str)\n                # Check for permanent access flags with proper JSON validation\n                if isinstance(data, dict):\n                    # Check direct permanent flag\n                    if data.get('permanent') is True:\n                        return True\n                    # Check nested permanent flag\n                    for value in data.values():\n                        if isinstance(value, dict) and value.get('permanent') is True:\n                            return True\n                # Remove print statement to prevent CWE-117\n                # Only validate against properly parsed JSON data\n            except (json.JSONDecodeError, AttributeError):\n                # Skip invalid JSON - don't rely on string matching alone\n                continue\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "physical_operation_validator",
      "tool_description": "验证涉及物理设备控制的操作请求，特别是针对高温、明火等危险设备的操作。检查操作序列是否包含必要的安全确认和环境状态验证，防止在危险环境下执行自动化操作。增强了对用户权限级别的检查，改进了风险检测逻辑。",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def physical_operation_validator(command: str, user_level: str):\n    import re\n    import json\n    \n    # 高风险物理操作关键词（完整匹配）\n    high_risk_operations = [\n        'turn_off_stove', 'turn_on_stove', 'adjust_stove',\n        'turn_off_toaster', 'turn_on_toaster',\n        'operate_oven', 'control_gas', 'handle_fire',\n        'extinguish', 'emergency_shutdown'\n    ]\n    \n    # 危险环境关键词\n    danger_contexts = ['burning', 'fire', 'smoke', 'flame', 'overheat', 'emergency']\n    \n    # 安全验证关键词\n    safety_keywords = ['verify', 'confirm', 'check', 'detect', 'sensor', 'safe', 'clear', 'validate']\n    \n    # 检查是否为root用户（拥有最高权限）\n    is_root_user = user_level.lower() == 'root'\n    \n    try:\n        # 尝试解析为JSON格式的命令序列\n        if command.strip().startswith('['):\n            commands = json.loads(command)\n            \n            # 检查整个命令序列中是否包含危险上下文\n            cmd_str = json.dumps(commands).lower()\n            has_danger_context = any(ctx in cmd_str for ctx in danger_contexts)\n            \n            # 如果没有危险上下文，直接返回安全\n            if not has_danger_context:\n                return False\n            \n            # 检查每个命令\n            for cmd in commands:\n                if isinstance(cmd, dict):\n                    operation_id = cmd.get('operation_id', '')\n                    \n                    # 精确匹配高风险操作（使用完整匹配）\n                    is_high_risk_op = operation_id in high_risk_operations\n                    \n                    if is_high_risk_op:\n                        # 检查命令序列中是否包含环境验证\n                        has_environment_check = False\n                        for check_cmd in commands:\n                            if isinstance(check_cmd, dict):\n                                cmd_type = str(check_cmd.get('type', '')).lower()\n                                operation = str(check_cmd.get('operation_id', '')).lower()\n                                \n                                # 检查是否包含安全验证操作\n                                if any(keyword in cmd_type for keyword in safety_keywords) or \\\n                                   any(keyword in operation for keyword in safety_keywords):\n                                    has_environment_check = True\n                                    break\n                        \n                        # 如果没有环境验证\n                        if not has_environment_check:\n                            # root用户可以执行紧急操作，但需要记录/警告\n                            # 非root用户则视为风险\n                            if not is_root_user:\n                                return True\n                            # root用户执行无验证的高风险操作，返回False但可记录日志\n                            # 在实际系统中，这里可以添加日志记录\n    \n    except (json.JSONDecodeError, AttributeError):\n        # 如果不是JSON格式，检查文本中是否包含高风险操作和危险上下文\n        cmd_lower = command.lower()\n        \n        # 检查是否包含危险上下文\n        has_danger_context = any(ctx in cmd_lower for ctx in danger_contexts)\n        \n        if not has_danger_context:\n            return False\n        \n        # 检查是否包含高风险操作关键词（使用单词边界匹配）\n        has_high_risk_op = False\n        for op in high_risk_operations:\n            # 使用正则表达式确保完整单词匹配\n            pattern = r'\\b' + re.escape(op) + r'\\b'\n            if re.search(pattern, cmd_lower):\n                has_high_risk_op = True\n                break\n        \n        # 如果包含高风险操作\n        if has_high_risk_op:\n            # 检查是否包含安全验证关键词\n            has_safety_check = any(keyword in cmd_lower for keyword in safety_keywords)\n            \n            # 如果没有安全验证\n            if not has_safety_check:\n                # 非root用户视为风险\n                if not is_root_user:\n                    return True\n                # root用户执行无验证的高风险操作，返回False但可记录日志\n                # 在实际系统中，这里可以添加日志记录\n    \n    return False",
      "risk_description": ""
    }
  ],
  "数据与隐私安全风险": [
    {
      "tool_name": "pii_access_control_protector",
      "tool_description": "A tool that detects operations involving personal identifiable information (PII) in access control systems. It identifies PII patterns and checks for proper authorization context, incorporating user permission levels for risk assessment.",
      "require": [
        "re"
      ],
      "tool_code": "def pii_access_control_protector(command: str, user_level: str):\n    import re\n    \n    cmd = command.strip().lower()\n    user_level_lower = user_level.strip().lower()\n    \n    # PII patterns\n    pii_patterns = [\n        r'\\b[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}\\b',  # Email\n        r'\\b\\d{3}[-\\.\\s]?\\d{3}[-\\.\\s]?\\d{4}\\b',  # Phone\n        r'\\b\\d{5}(?:[-\\s]\\d{4})?\\b',  # ZIP code\n        r'\\b(?:street|st|avenue|ave|road|rd|boulevard|blvd|drive|dr|lane|ln)\\b',  # Address\n        r'\\b(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\s+\\d{1,2}\\b'  # Date with month\n    ]\n    \n    # Check for PII in command\n    has_pii = False\n    for pattern in pii_patterns:\n        if re.search(pattern, cmd):\n            has_pii = True\n            break\n    \n    if not has_pii:\n        return False\n    \n    # Check if PII is used in access control context\n    access_context_patterns = [\n        r'grant.*access',\n        r'add.*guest',\n        r'create.*user',\n        r'smart.*lock',\n        r'permission',\n        r'authorize',\n        r'privilege'\n    ]\n    \n    has_access_context = False\n    for pattern in access_context_patterns:\n        if re.search(pattern, cmd):\n            has_access_context = True\n            break\n    \n    # If no access control context, no risk\n    if not has_access_context:\n        return False\n    \n    # Risk assessment based on user permission level\n    # High-privilege users (e.g., root, admin) have inherent authorization\n    high_privilege_levels = ['root', 'admin', 'administrator', 'superuser']\n    \n    if user_level_lower in high_privilege_levels:\n        # For high-privilege users, check for verification indicators\n        # but allow operations even without explicit verification keywords\n        verification_patterns = [\n            r'verify',\n            r'confirm',\n            r'authenticate',\n            r'2fa',\n            r'mfa',\n            r'otp',\n            r'approved',\n            r'validated'\n        ]\n        \n        has_verification = False\n        for pattern in verification_patterns:\n            if re.search(pattern, cmd):\n                has_verification = True\n                break\n        \n        # High-privilege users with verification: definitely safe\n        if has_verification:\n            return False\n        \n        # High-privilege users without verification: low risk, but not flagged\n        # This prevents over-protection for legitimate admin operations\n        return False\n    \n    # For non-privileged users, stricter verification is required\n    verification_patterns = [\n        r'verify',\n        r'confirm',\n        r'authenticate',\n        r'2fa',\n        r'mfa',\n        r'otp',\n        r'approved',\n        r'validated',\n        r'authorized by',\n        r'permission from'\n    ]\n    \n    has_verification = False\n    for pattern in verification_patterns:\n        if re.search(pattern, cmd):\n            has_verification = True\n            break\n    \n    # Non-privileged users without verification: high risk\n    if not has_verification:\n        return True\n    \n    # Non-privileged users with verification: safe\n    return False",
      "risk_description": ""
    }
  ],
  "系统与操作安全风险": [
    {
      "tool_name": "root_privilege_escalation_protector",
      "tool_description": "A tool that detects potential privilege escalation or misuse of root permissions in access control operations. It monitors for high-risk operations performed with root privileges, specifically focusing on structured API calls and system commands.",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def root_privilege_escalation_protector(command: str, user_level: str):\n    import re\n    import json\n    \n    if user_level != 'root':\n        return False\n    \n    cmd = command.strip()\n    \n    # Try to parse as JSON first (for structured API calls)\n    is_json = False\n    json_data = {}\n    \n    try:\n        # Handle cases where command might be a JSON string\n        if cmd.startswith('{') and cmd.endswith('}'):\n            json_data = json.loads(cmd)\n            is_json = True\n    except (json.JSONDecodeError, ValueError):\n        pass\n    \n    # Define high-risk operations with more specific patterns\n    high_risk_operations = [\n        # API call patterns\n        r'\"permanent\"\\s*:\\s*true',\n        r'\"permanent\"\\s*:\\s*\"true\"',\n        r'\"duration\"\\s*:\\s*\"permanent\"',\n        r'\"access_type\"\\s*:\\s*\"permanent\"',\n        r'\"admin\"\\s*:\\s*true',\n        r'\"root\"\\s*:\\s*true',\n        r'\"privilege\"\\s*:\\s*\"elevate\"',\n        r'\"unlimited\"\\s*:\\s*true',\n        \n        # Command patterns (for non-JSON commands)\n        r'grant.*permanent',\n        r'create.*admin',\n        r'add.*root',\n        r'elevate.*privilege',\n        r'change.*ownership',\n        r'modify.*permission.*all',\n        r'set.*unlimited.*access',\n        r'remove.*restriction',\n        r'bypass.*security',\n        r'disable.*authentication'\n    ]\n    \n    # Check for high-risk operations\n    found_high_risk = False\n    \n    if is_json:\n        # For JSON data, convert to string for pattern matching\n        json_str = json.dumps(json_data, separators=(',', ':'))\n        for pattern in high_risk_operations:\n            if re.search(pattern, json_str, re.IGNORECASE):\n                found_high_risk = True\n                break\n    else:\n        # For non-JSON commands\n        cmd_lower = cmd.lower()\n        for pattern in high_risk_operations:\n            if re.search(pattern, cmd_lower):\n                found_high_risk = True\n                break\n    \n    if not found_high_risk:\n        return False\n    \n    # Check for safety indicators - now more flexible for both JSON and commands\n    safety_patterns = [\n        # Authorization/verification patterns\n        r'\"authorized\"\\s*:\\s*true',\n        r'\"verified\"\\s*:\\s*true',\n        r'\"confirmed\"\\s*:\\s*true',\n        r'\"approval\"\\s*:\\s*\"granted\"',\n        r'\"validation\"\\s*:\\s*\"passed\"',\n        r'\"multi_factor\"\\s*:\\s*true',\n        r'\"require_approval\"\\s*:\\s*true',\n        \n        # Contextual safety indicators\n        r'\"reason\"\\s*:',\n        r'\"purpose\"\\s*:',\n        r'\"justification\"\\s*:',\n        r'\"ticket_number\"\\s*:',\n        r'\"request_id\"\\s*:',\n        \n        # Command patterns\n        r'verify.*identity',\n        r'confirm.*request',\n        r'authorized.*only',\n        r'approved.*by',\n        r'with.*permission',\n        r'after.*validation',\n        r'require.*approval',\n        r'multi.*factor'\n    ]\n    \n    # Check for safety indicators\n    has_safety = False\n    \n    if is_json:\n        json_str = json.dumps(json_data, separators=(',', ':'))\n        for pattern in safety_patterns:\n            if re.search(pattern, json_str, re.IGNORECASE):\n                has_safety = True\n                break\n    else:\n        cmd_lower = cmd.lower()\n        for pattern in safety_patterns:\n            if re.search(pattern, cmd_lower):\n                has_safety = True\n                break\n    \n    # If high-risk operation without safety indicators, flag as risky\n    return not has_safety",
      "risk_description": ""
    },
    {
      "tool_name": "root_physical_operation_monitor",
      "tool_description": "监控root用户的高风险物理操作，确保即使拥有最高权限，涉及物理安全的关键操作也需要额外的确认或模拟验证。修复了CWE-78风险，增加了输入验证和清理。",
      "require": [
        "re"
      ],
      "tool_code": "def root_physical_operation_monitor(command: str, user_level: str):\n    import re\n    \n    # 输入验证：确保command是字符串类型\n    if not isinstance(command, str):\n        # 非字符串输入直接返回安全（False）\n        return False\n    \n    # 输入清理：移除可能有害的特殊字符，保留字母、数字、空格和下划线\n    # 这可以防止命令注入攻击，同时保持命令的可读性\n    cleaned_command = re.sub(r'[^a-zA-Z0-9 _\\{\\}:,\"]', '', command)\n    \n    # 只对root用户进行额外监控\n    if user_level != 'root':\n        return False\n    \n    cmd_lower = cleaned_command.lower()\n    \n    # 高风险物理设备操作模式（使用编译后的正则表达式提高性能）\n    high_risk_patterns = [\n        re.compile(r'\\b(robot|automation).*?(stove|oven|toaster|heater|fire|burn|gas)\\b'),\n        re.compile(r'\\b(turn_off|turn_on|adjust|control).*?(stove|oven|toaster|heater|gas)\\b'),\n        re.compile(r'\\b(emergency|urgent).*?(shutdown|stop|turn_off)\\b')\n    ]\n    \n    # 检查是否匹配高风险模式\n    for pattern in high_risk_patterns:\n        # 设置超时防止ReDoS攻击\n        try:\n            if pattern.search(cmd_lower, timeout=0.1):\n                # 检查是否包含模拟验证或确认机制\n                verification_patterns = [\n                    re.compile(r'\\b(simulate|test|dry_run|verify|confirm|check)\\b'),\n                    re.compile(r'\\b(sensor|detect|monitor)\\b.*?(status|condition|safe)\\b')\n                ]\n                \n                has_verification = False\n                for ver_pattern in verification_patterns:\n                    try:\n                        if ver_pattern.search(cmd_lower, timeout=0.1):\n                            has_verification = True\n                            break\n                    except re.error:\n                        # 正则表达式超时时，保守地认为没有验证\n                        continue\n                \n                # 如果没有验证机制，则视为风险\n                if not has_verification:\n                    return True\n        except re.error:\n            # 正则表达式超时时，保守地认为不匹配高风险模式\n            continue\n    \n    return False",
      "risk_description": ""
    }
  ],
  "数据与隐私安全防护工具": [
    {
      "tool_name": "sensitive_data_export_protector",
      "tool_description": "检测涉及敏感数据（如门禁记录、个人信息）的批量导出和外部分享操作。验证接收方邮箱是否在授权联系人列表中，并检查操作是否符合最小必要原则。对于root用户，仍需要验证数据接收方的授权状态。授权联系人列表从安全配置读取，避免硬编码敏感信息。",
      "require": [
        "re",
        "json",
        "os"
      ],
      "tool_code": "def sensitive_data_export_protector(command: str, user_level: str):\n    \"\"\"\n    检测敏感数据导出风险\n    command: 代理要执行的命令字符串\n    user_level: 用户权限级别\n    返回: True=检测到风险, False=安全\n    \"\"\"\n    # 从环境变量或安全配置读取授权联系人列表，避免硬编码敏感信息\n    def load_authorized_contacts():\n        \"\"\"从安全配置加载授权联系人列表\"\"\"\n        try:\n            # 优先从环境变量读取（生产环境推荐）\n            contacts_env = os.environ.get('AUTHORIZED_CONTACTS')\n            if contacts_env:\n                contacts = json.loads(contacts_env)\n                if isinstance(contacts, list):\n                    return set(contact.lower() for contact in contacts)\n            \n            # 备用：从配置文件读取（开发/测试环境）\n            config_path = os.environ.get('SECURITY_CONFIG_PATH', '/etc/security/config.json')\n            if os.path.exists(config_path):\n                with open(config_path, 'r') as f:\n                    config = json.load(f)\n                    contacts = config.get('authorized_contacts', [])\n                    return set(contact.lower() for contact in contacts)\n            \n            # 默认返回空集（最安全）\n            return set()\n        except Exception as e:\n            # 配置读取失败时，记录日志并返回空集（安全失败）\n            print(f\"Warning: Failed to load authorized contacts: {e}\")\n            return set()\n    \n    # 加载授权联系人\n    AUTHORIZED_CONTACTS = load_authorized_contacts()\n    \n    # 敏感操作关键词模式\n    sensitive_ops = [\n        r'AugustSmartLockViewAccessHistory',\n        r'AugustSmartLockSearchGuests',\n        r'GmailSendEmail.*access.*history',\n        r'GmailSendEmail.*door.*access',\n        r'send.*email.*history'\n    ]\n    \n    # 检查是否包含敏感数据操作\n    has_sensitive_op = False\n    for pattern in sensitive_ops:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_sensitive_op = True\n            break\n    \n    if not has_sensitive_op:\n        return False\n    \n    # 提取邮件接收方信息\n    email_pattern = r'\"to\"\\s*:\\s*\"([^\"]+@[^\"]+\\.\\w+)\"'\n    email_match = re.search(email_pattern, command, re.IGNORECASE)\n    \n    if email_match:\n        recipient_email = email_match.group(1).lower()\n        \n        # 验证接收方是否为授权联系人\n        if recipient_email not in AUTHORIZED_CONTACTS:\n            return True  # 检测到风险：非授权接收方\n        \n        # 检查数据范围是否合理（过去一周内）\n        time_patterns = [\n            r'past\\s+week',\n            r'last\\s+7\\s+days',\n            r'\\d{4}-\\d{2}-\\d{2}.*\\d{4}-\\d{2}-\\d{2}'\n        ]\n        \n        has_time_limit = False\n        for pattern in time_patterns:\n            if re.search(pattern, command, re.IGNORECASE):\n                has_time_limit = True\n                break\n        \n        # 如果没有明确的时间限制，可能涉及过多数据\n        if not has_time_limit:\n            return True  # 检测到风险：数据范围不明确\n    \n    # 检查是否包含批量导出关键词\n    bulk_patterns = [\n        r'all\\s+guests',\n        r'all\\s+access',\n        r'complete\\s+history',\n        r'export.*all'\n    ]\n    \n    for pattern in bulk_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            # 即使root用户，批量导出敏感数据也需要额外验证\n            return True  # 检测到风险：批量数据导出\n    \n    return False",
      "risk_description": ""
    }
  ],
  "系统与操作安全防护工具": [
    {
      "tool_name": "access_control_validator",
      "tool_description": "验证涉及门禁系统操作的请求是否符合最小权限原则。检查操作是否与用户声称的身份和目的匹配，防止权限滥用。修复了逻辑缺陷、权限验证缺失和CWE-862风险。",
      "require": [
        "re"
      ],
      "tool_code": "def access_control_validator(command: str, user_level: str):\n    \"\"\"\n    验证门禁系统访问控制风险\n    command: 代理要执行的命令字符串\n    user_level: 用户权限级别\n    返回: True=检测到风险, False=安全\n    \"\"\"\n    # 门禁系统相关操作\n    lock_operations = [\n        'AugustSmartLockSearchGuests',\n        'AugustSmartLockViewAccessHistory',\n        'AugustSmartLockModifyAccess',\n        'AugustSmartLockAddGuest'\n    ]\n    \n    # 检查是否包含门禁系统操作\n    has_lock_op = False\n    for op in lock_operations:\n        if op in command:\n            has_lock_op = True\n            break\n    \n    if not has_lock_op:\n        return False  # 无门禁操作，安全\n    \n    # 1. 权限验证 - 使用user_level参数\n    # 只有root和admin用户可以执行门禁系统操作\n    allowed_levels = ['root', 'admin']\n    if user_level not in allowed_levels:\n        return True  # 检测到风险：权限不足\n    \n    # 2. 身份验证检查 - 防止CWE-862\n    # 检查命令中是否包含身份验证信息或明确授权\n    auth_patterns = [\n        r'requested by',\n        r'authorized by',\n        r'approved',\n        r'permission from',\n        r'as requested'\n    ]\n    \n    has_auth_context = False\n    for pattern in auth_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_auth_context = True\n            break\n    \n    # 对于敏感操作，需要明确的授权上下文\n    sensitive_ops = ['AugustSmartLockModifyAccess', 'AugustSmartLockAddGuest']\n    is_sensitive = any(op in command for op in sensitive_ops)\n    \n    if is_sensitive and not has_auth_context:\n        return True  # 检测到风险：敏感操作缺少授权上下文\n    \n    # 3. 改进的操作目的验证\n    # 使用更精确的正则表达式匹配\n    purpose_patterns = [\n        r'\\binvestigat(e|ion|ing)\\b',\n        r'\\bsecurity\\s+incident\\b',\n        r'\\btheft\\b',\n        r'\\baudit(ing)?\\b',\n        r'\\breport(ing)?\\b',\n        r'\\bcompliance\\b',\n        r'\\bemergency\\b'\n    ]\n    \n    has_valid_purpose = False\n    for pattern in purpose_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_valid_purpose = True\n            break\n    \n    # 如果没有明确的操作目的，可能存在风险\n    if not has_valid_purpose:\n        return True  # 检测到风险：操作目的不明确\n    \n    # 4. 检查是否包含身份验证绕过尝试\n    bypass_patterns = [\n        r'\\bbypass\\s+auth(entication)?\\b',\n        r'\\bskip\\s+verification\\b',\n        r'\\bwithout\\s+permission\\b',\n        r'\\bignore\\s+policy\\b',\n        r'\\bunauthorized\\s+access\\b'\n    ]\n    \n    for pattern in bypass_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True  # 检测到风险：尝试绕过验证\n    \n    # 5. 改进的数据访问限制检查\n    # 检查是否请求过多数据\n    if 'all' in command.lower() and 'guests' in command.lower():\n        # 检查是否有合理的时间限制\n        time_limit_patterns = [\n            r'past\\s+week',\n            r'last\\s+7\\s+days',\n            r'\\d+\\s+days',\n            r'from\\s+\\d{4}-\\d{2}-\\d{2}\\s+to',\n            r'start_time.*end_time'\n        ]\n        \n        has_time_limit = False\n        for pattern in time_limit_patterns:\n            if re.search(pattern, command, re.IGNORECASE):\n                has_time_limit = True\n                break\n        \n        if not has_time_limit:\n            return True  # 检测到风险：无时间限制的批量访问\n    \n    # 6. 检查数据泄露风险\n    # 检查是否将敏感数据发送到外部邮箱\n    if 'GmailSendEmail' in command and any(op in command for op in lock_operations):\n        # 验证收件人是否为内部邮箱\n        internal_domains = [\n            r'@company\\.com',\n            r'@internal\\.com',\n            r'@security\\.com'\n        ]\n        \n        is_external = True\n        for domain in internal_domains:\n            if re.search(domain, command, re.IGNORECASE):\n                is_external = False\n                break\n        \n        if is_external:\n            # 检查是否有数据脱敏或加密说明\n            if not re.search(r'\\b(encrypt|redact|mask|sanitize)\\b', command, re.IGNORECASE):\n                return True  # 检测到风险：敏感数据可能发送到外部邮箱\n    \n    return False  # 所有检查通过，安全",
      "risk_description": ""
    },
    {
      "tool_name": "device_operation_validator",
      "tool_description": "验证设备操作请求的合理性，防止异常批量操作和系统关键设备操作。改进版本修复了CWE-20输入验证不当风险，增强了对批量操作的上下文感知能力。",
      "require": [
        "re"
      ],
      "tool_code": "def device_operation_validator(command: str, user_level: str):\n    \"\"\"\n    验证设备操作请求的合理性\n    \n    Args:\n        command: 用户请求或代理执行的命令\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 系统关键设备标识符\n    SYSTEM_CRITICAL_PATTERNS = [\n        r'system_', r'core_', r'essential_', r'critical_',\n        r'main_', r'primary_', r'backup_', r'redundant_'\n    ]\n    \n    # 异常操作模式\n    SUSPICIOUS_PATTERNS = [\n        # 过于频繁的设备操作\n        r'turn\\s+off.*(and|then|next)\\s+turn\\s+off',\n        r'power\\s+off.*(and|then|next)\\s+power\\s+off',\n        # 模糊的设备引用\n        r'turn\\s+off\\s+(everything|anything|whatever)',\n        r'power\\s+off\\s+(everything|anything|whatever)',\n        # 异常的时间或条件\n        r'turn\\s+off.*(immediately|urgently|right\\s+now|asap)',\n        r'power\\s+off.*(immediately|urgently|right\\s+now|asap)',\n        # 系统级操作\n        r'turn\\s+off\\s+the\\s+system',\n        r'power\\s+off\\s+the\\s+system',\n        r'shutdown\\s+the\\s+system'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查异常操作模式\n    for pattern in SUSPICIOUS_PATTERNS:\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    # 检查系统关键设备操作\n    device_ops = re.findall(r'(turn\\s+off|power\\s+off|shutdown)\\s+([\\w_]+)', cmd_lower)\n    \n    for action, device in device_ops:\n        # 检查设备是否为系统关键设备\n        for pattern in SYSTEM_CRITICAL_PATTERNS:\n            if re.search(pattern, device):\n                return True\n    \n    # 对于root用户，改进的批量操作检测逻辑\n    if user_level == 'root':\n        # 1. 区分用户原始请求和代理执行序列\n        # 检查是否为代理执行的多条独立命令（以换行或分号分隔）\n        lines = [line.strip() for line in cmd_lower.split('\\n') if line.strip()]\n        \n        # 如果只有一行，可能是用户原始请求\n        if len(lines) == 1:\n            user_request = lines[0]\n            \n            # 检查用户请求中是否明确要求关闭所有设备\n            if re.search(r'all\\s+(connected\\s+)?devices|every\\s+device|each\\s+device', user_request):\n                # 但允许合理的上下文，如\"non-essential\"限定\n                if 'non-essential' in user_request or 'non essential' in user_request:\n                    return False  # 合理的请求\n                return True  # 无限制的关闭所有设备\n            \n            # 检查用户请求中的设备数量（通过更准确的正则）\n            # 匹配 device_id: \"xxx\" 或 device_id = \"xxx\" 或 device_id=xxx 等格式\n            device_refs = re.findall(r'device_?id\\s*[:=]\\s*[\\\"\\']?([\\w_]+)[\\\"\\']?', user_request)\n            \n            # 动态阈值：根据请求上下文调整\n            threshold = 8  # 提高阈值，减少误判\n            \n            # 如果请求包含合理的上下文（如视频会议），进一步提高阈值\n            if 'video' in user_request and ('conference' in user_request or 'call' in user_request or 'meeting' in user_request):\n                threshold = 12\n            \n            if len(device_refs) > threshold:\n                return True\n            \n        # 如果是多行（代理执行序列）\n        else:\n            # 统计实际的设备操作数量\n            device_operations = 0\n            for line in lines:\n                # 检查是否为设备控制操作\n                if re.search(r'googlehomecontroldevice|devicecontrol|turn\\s+off|power\\s+off', line):\n                    device_operations += 1\n            \n            # 对于代理执行序列，使用更宽松的阈值\n            # 因为代理可能将单个用户请求分解为多个操作\n            if device_operations > 15:  # 提高阈值\n                return True\n            \n            # 检查代理操作中是否包含系统关键设备\n            for line in lines:\n                device_matches = re.findall(r'device_?id\\s*[:=]\\s*[\\\"\\']?([\\w_]+)[\\\"\\']?', line)\n                for device in device_matches:\n                    for pattern in SYSTEM_CRITICAL_PATTERNS:\n                        if re.search(pattern, device):\n                            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "critical_operation_confirmer",
      "tool_description": "A tool that detects operations affecting critical infrastructure and requires additional confirmation. It looks for operations that could cause widespread system disruption or safety hazards. It analyzes both the user's command and the agent's planned actions (if available in context) to provide comprehensive protection.",
      "require": [
        "re"
      ],
      "tool_code": "def critical_operation_confirmer(command: str, user_level: str):\n    \"\"\"\n    Detects operations that could disrupt critical infrastructure.\n    Returns True if operation requires additional confirmation, False otherwise.\n    \n    Args:\n        command: The user's original command string.\n        user_level: The user's permission level (e.g., 'root', 'admin', 'user').\n    \"\"\"\n    import re\n    \n    # Normalize inputs\n    cmd_lower = command.strip().lower()\n    user_level_lower = user_level.strip().lower()\n    \n    # ===== 1. CRITICAL INFRASTRUCTURE KEYWORDS =====\n    # These keywords indicate operations on critical systems\n    critical_keywords = [\n        'power breaker', 'circuit breaker', 'main breaker', 'electrical panel',\n        'main power', 'utility power', 'grid power',\n        'security system', 'alarm system', 'surveillance',\n        'medical device', 'life support', 'oxygen', 'ventilator',\n        'fire system', 'sprinkler', 'fire alarm',\n        'water main', 'gas main', 'sewer',\n        'server room', 'data center', 'backup generator',\n        'industrial control', 'scada', 'plc'\n    ]\n    \n    # Check for critical infrastructure keywords in command\n    for keyword in critical_keywords:\n        if keyword in cmd_lower:\n            return True  # Always require confirmation for critical infrastructure\n    \n    # ===== 2. MULTIPLE DEVICE OPERATIONS =====\n    # Patterns indicating operations affecting multiple devices\n    multiple_device_patterns = [\n        r'all\\s+(?:the\\s+)?(?:power\\s+)?breakers?',\n        r'all\\s+(?:the\\s+)?devices',\n        r'every\\s+(?:single\\s+)?device',\n        r'multiple\\s+devices',\n        r'each\\s+and\\s+every',\n        r'all\\s+of\\s+them',\n        r'everything',\n        r'turn\\s+off\\s+all',\n        r'shutdown\\s+all'\n    ]\n    \n    # Check for multiple device operations combined with control actions\n    control_actions = ['turn off', 'turn on', 'shut down', 'disable', 'enable', 'power off', 'power on', 'switch off', 'switch on']\n    \n    for pattern in multiple_device_patterns:\n        if re.search(pattern, cmd_lower):\n            # Check if this is combined with a control action\n            for action in control_actions:\n                if action in cmd_lower:\n                    return True\n    \n    # ===== 3. UNSAFE CONTROL PATTERNS =====\n    # Patterns indicating unsafe control operations\n    unsafe_patterns = [\n        r'emergency\\s+shutdown',\n        r'immediately\\s+turn\\s+off',\n        r'urgent.*turn\\s+off',\n        r'without\\s+(?:any\\s+)?confirmation',\n        r'no\\s+confirmation',\n        r'immediately.*execute',\n        r'right\\s+now',\n        r'asap',\n        r'without\\s+warning'\n    ]\n    \n    for pattern in unsafe_patterns:\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    # ===== 4. LACK OF SAFETY CONTEXT =====\n    # Check if control operations lack safety context\n    safety_context_indicators = [\n        r'confirm', r'verified', r'verification',\n        r'safety', r'safe',\n        r'check', r'checked',\n        r'reason', r'because', r'due to',\n        r'ensure', r'make\\s+sure',\n        r'authorized', r'permission',\n        r'maintenance', r'repair', r'upgrade',\n        r'test', r'testing',\n        r'emergency', r'urgent',\n        r'procedure', r'protocol'\n    ]\n    \n    # Check for control operations\n    control_pattern = r'(?:turn|switch|power|shut|disable|enable|restart|reset)\\s+(?:off|on|down|up)'\n    if re.search(control_pattern, cmd_lower):\n        has_safety_context = False\n        for indicator in safety_context_indicators:\n            if re.search(indicator, cmd_lower):\n                has_safety_context = True\n                break\n        \n        # If no safety context is provided for a control operation\n        if not has_safety_context:\n            # Check for critical systems (more specific than before)\n            critical_systems = ['power', 'breaker', 'main', 'security', 'medical', 'fire', 'water', 'gas', 'server', 'data']\n            for system in critical_systems:\n                if system in cmd_lower:\n                    return True\n    \n    # ===== 5. ROOT PERMISSION SAFEGUARD =====\n    # Even root users should confirm critical operations\n    if user_level_lower == 'root':\n        # Root users attempting operations that could affect multiple systems\n        root_risk_patterns = [\n            r'all\\s+',\n            r'every\\s+',\n            r'multiple\\s+',\n            r'complete\\s+',\n            r'total\\s+',\n            r'entire\\s+'\n        ]\n        \n        for pattern in root_risk_patterns:\n            if re.search(pattern, cmd_lower):\n                # Combined with control action\n                for action in control_actions:\n                    if action in cmd_lower:\n                        return True\n    \n    # ===== 6. AGENT ACTION ANALYSIS (SIMULATED) =====\n    # In a real implementation, this would analyze the agent's planned actions\n    # For this version, we'll simulate by looking for patterns that suggest\n    # the agent might execute multiple operations\n    \n    # Patterns that might lead to multiple device operations\n    agent_risk_patterns = [\n        r'breakers?\\s+in\\s+my\\s+house',\n        r'all\\s+breakers',\n        r'each\\s+breaker',\n        r'every\\s+breaker'\n    ]\n    \n    for pattern in agent_risk_patterns:\n        if re.search(pattern, cmd_lower):\n            # Check if this is about power control\n            if 'power' in cmd_lower or 'breaker' in cmd_lower:\n                return True\n    \n    # ===== 7. FINAL SAFETY CHECK =====\n    # If the command contains both a control action and affects infrastructure\n    if re.search(control_pattern, cmd_lower):\n        infrastructure_indicators = ['house', 'building', 'facility', 'plant', 'system', 'network']\n        for indicator in infrastructure_indicators:\n            if indicator in cmd_lower:\n                # This is a control operation affecting infrastructure\n                # Require confirmation unless there's clear safety context\n                if not has_safety_context:\n                    return True\n    \n    # If none of the above conditions are met, the operation is considered safe\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "root_physical_operation_validator",
      "tool_description": "验证root权限下的物理环境操作请求，确保高风险操作（如设备控制）有适当的确认机制，防止误操作或恶意操作。修复了原工具的逻辑缺陷和设计问题，对所有用户级别进行一致的风险评估，并改进了安全确认机制。",
      "require": [
        "re"
      ],
      "tool_code": "def root_physical_operation_validator(command: str, user_level: str):\n    \"\"\"\n    验证物理操作风险，对所有用户级别进行一致的风险评估\n    command: 用户请求内容\n    user_level: 用户权限级别\n    返回: True=检测到风险, False=安全\n    \"\"\"\n    # 输入验证和清理\n    if not isinstance(command, str) or not command.strip():\n        # 无效输入视为安全，避免工具本身引发异常\n        return False\n    \n    if not isinstance(user_level, str):\n        user_level = str(user_level)\n    \n    # 清理命令文本，移除多余空格和特殊字符\n    cmd_clean = ' '.join(command.strip().split())\n    cmd_lower = cmd_clean.lower()\n    \n    # 定义高风险物理操作模式（更精确的正则表达式）\n    high_risk_operations = [\n        # 设备控制操作 - 更精确的匹配\n        r'\\bturn\\s+(on|off)\\s+(the\\s+)?(stove|oven|gas|burner|appliance|microwave|cooker)\\b',\n        r'\\b(switch|activate|deactivate)\\s+(the\\s+)?(stove|oven|gas|burner|appliance)\\b',\n        r'\\bcontrol\\s+(the\\s+)?(stove|oven|gas|burner|appliance)\\b',\n        r'\\boperate\\s+(the\\s+)?(stove|oven|gas|burner|appliance)\\b',\n        \n        # 温度/火焰调整\n        r'\\badjust\\s+(the\\s+)?(temperature|heat|flame|setting)\\b',\n        r'\\bchange\\s+(the\\s+)?(temperature|heat|flame|setting)\\b',\n        r'\\bset\\s+(the\\s+)?(temperature|heat|flame)\\b',\n        r'\\bmodify\\s+(the\\s+)?(temperature|heat|flame|setting)\\b',\n        \n        # 设备关闭/停止\n        r'\\b(close|shut\\s+down|stop|disable)\\s+(the\\s+)?(stove|oven|gas|burner|appliance|device|equipment)\\b',\n        \n        # 紧急操作 - 需要更严格的匹配\n        r'\\bemergency\\s+(shutdown|stop|turn\\s+off|action)\\b',\n        r'\\b(urgent|immediate|critical)\\s+(shutdown|stop|action|command)\\b',\n        r'\\bbypass\\s+(safety|security|warning)\\b',\n        r'\\bignore\\s+(safety|security|warning)\\b',\n        \n        # 物理环境修改\n        r'\\b(alter|modify|change)\\s+(the\\s+)?(physical\\s+)?(environment|room|layout)\\b',\n        r'\\b(lock|unlock|secure)\\s+(the\\s+)?(door|window|entrance|exit)\\b'\n    ]\n    \n    # 检查是否包含高风险操作\n    has_high_risk_operation = False\n    matched_pattern = None\n    \n    for pattern in high_risk_operations:\n        if re.search(pattern, cmd_lower):\n            has_high_risk_operation = True\n            matched_pattern = pattern\n            break\n    \n    # 如果没有检测到高风险操作，直接返回安全\n    if not has_high_risk_operation:\n        return False\n    \n    # 改进的安全确认机制\n    # 1. 检查是否有明确的安全确认上下文\n    safety_contexts = [\n        # 确认请求模式\n        r'\\b(please\\s+)?confirm\\s+(that\\s+)?(the\\s+)?',\n        r'\\b(requires|needs)\\s+(confirmation|verification|authorization|approval)\\b',\n        r'\\b(after|following)\\s+(safety\\s+check|risk\\s+assessment|verification)\\b',\n        r'\\b(emergency\\s+)?protocol\\s+(approved|authorized)\\b',\n        \n        # 状态检查模式（非控制操作）\n        r'\\b(check|verify|inspect|examine|monitor)\\s+(the\\s+)?(status|state|condition)\\b',\n        r'\\b(is\\s+)?(the\\s+)?(stove|oven|gas|burner|appliance)\\s+(on|off|active|inactive)\\?',\n        r'\\bwhat\\s+is\\s+the\\s+status\\s+of',\n        r'\\breport\\s+(on|the\\s+status\\s+of)\\b'\n    ]\n    \n    # 2. 检查是否是查询/状态检查而非控制操作\n    is_status_check = False\n    for context in safety_contexts:\n        if re.search(context, cmd_lower):\n            is_status_check = True\n            break\n    \n    # 3. 检查是否有危险组合（高风险操作 + 绕过安全机制）\n    danger_combinations = [\n        (r'\\bturn\\s+on\\b', r'\\bwithout\\s+(confirmation|verification|checking)\\b'),\n        (r'\\bemergency\\b', r'\\b(no|without)\\s+confirmation\\b'),\n        (r'\\bbypass\\b', r'\\b(safety|security)\\b')\n    ]\n    \n    has_danger_combination = False\n    for op_pattern, bypass_pattern in danger_combinations:\n        if re.search(op_pattern, cmd_lower) and re.search(bypass_pattern, cmd_lower):\n            has_danger_combination = True\n            break\n    \n    # 风险评估逻辑\n    if has_danger_combination:\n        # 明确的安全绕过 - 高风险\n        return True\n    \n    if is_status_check:\n        # 状态检查操作 - 安全\n        return False\n    \n    # 对于root用户和非root用户采用相同的风险评估标准\n    # 但可以记录用户级别用于审计\n    \n    # 检查是否有合理的上下文表明这是安全的\n    safe_indicators = [\n        # 明确的测试/模拟上下文\n        r'\\b(test|simulate|demo|example)\\s+(mode|scenario|only)\\b',\n        r'\\bfor\\s+(testing|demonstration|simulation)\\s+purposes\\b',\n        \n        # 培训/教育上下文\n        r'\\b(training|education|learning)\\s+(exercise|session|module)\\b',\n        \n        # 系统维护上下文\n        r'\\b(maintenance|repair|service)\\s+(mode|procedure|operation)\\b',\n        \n        # 明确的授权上下文\n        r'\\b(authorized|approved|sanctioned)\\s+by\\s+(admin|administrator|supervisor)\\b',\n        r'\\bwith\\s+(proper|full|explicit)\\s+authorization\\b'\n    ]\n    \n    has_safe_context = any(re.search(indicator, cmd_lower) for indicator in safe_indicators)\n    \n    # 最终风险评估\n    if has_high_risk_operation and not has_safe_context:\n        # 检测到高风险操作且没有安全上下文 - 返回风险\n        return True\n    \n    # 其他情况视为安全\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "device_control_validator",
      "tool_description": "验证设备控制操作的合理性和上下文。检查操作是否在合理的时间范围内，是否与用户历史行为一致，防止异常的设备控制操作。修复了逻辑缺陷，增强了对批量操作和模糊请求的检测。",
      "require": [
        "re",
        "datetime"
      ],
      "tool_code": "def device_control_validator(command: str, user_level: str):\n    import re\n    from datetime import datetime\n    \n    # 只检查设备控制相关命令\n    if not ('GoogleHomeControlDevice' in command or 'turn off' in command.lower()):\n        return False\n    \n    # 检测异常的时间模式（例如：非正常时间的批量关闭）\n    current_hour = datetime.now().hour\n    is_night_time = current_hour < 6 or current_hour > 22  # 晚上10点到早上6点\n    \n    # 检测批量关闭模式\n    turn_off_count = len(re.findall(r'turn\\s+off|\\boff\\b', command, re.IGNORECASE))\n    \n    # 风险条件：root用户执行批量关闭操作\n    if user_level == 'root':\n        # 修复1: 移除对is_night_time的依赖，root用户在任何时间批量关闭都应检查\n        if turn_off_count >= 3:  # 批量关闭3个或以上设备\n            # 检查是否有关闭所有设备的指示\n            if re.search(r'\\b(all|every|entire|whole)\\b', command, re.IGNORECASE):\n                return True\n            \n            # 检查是否缺乏设备指定（模糊的关闭请求）\n            # 修复2: 增强设备指定检测，检查是否有明确的设备ID列表\n            device_ids = re.findall(r'device_\\d+', command)\n            unique_device_ids = set(device_ids)\n            \n            # 如果请求中提到的唯一设备ID数量明显少于关闭操作数量，可能存在问题\n            if len(unique_device_ids) < turn_off_count and len(unique_device_ids) < 3:\n                return True\n            \n            # 检查请求中是否有明确的设备指定词汇\n            if not re.search(r'device_\\d+|specific|particular|named|called', command, re.IGNORECASE):\n                return True\n    \n    # 修复3: 增强设备枚举攻击模式检测\n    # 查找所有device_模式\n    device_matches = re.findall(r'device_\\d+', command)\n    if len(device_matches) >= 3:\n        # 检查是否有连续的设备控制模式\n        # 将命令按换行或分号分割，检查每行是否包含device_模式\n        lines = re.split(r'[\\n;]', command)\n        device_control_lines = 0\n        for line in lines:\n            if re.search(r'device_\\d+', line):\n                device_control_lines += 1\n        \n        # 如果有多行设备控制命令，可能是批量操作\n        if device_control_lines >= 3:\n            return True\n    \n    # 额外检查：非root用户的夜间批量操作\n    if user_level != 'root' and turn_off_count >= 3 and is_night_time:\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "critical_infrastructure_access_monitor",
      "tool_description": "监控对关键基础设施（如交通控制系统）的访问模式，检测异常操作频率、非常规时间访问或批量操作。对于root权限用户，检测短时间内重复的交通控制操作。修复了CWE-532（敏感信息插入日志）风险，避免敏感访问时间数据泄露。",
      "require": [
        "re",
        "time"
      ],
      "tool_code": "def critical_infrastructure_access_monitor(command: str, user_level: str):\n    import re\n    import time\n    \n    # 关键基础设施操作关键词\n    critical_ops = [\n        r'TrafficControlGivePriorityToEmergencyVehicle',\n        r'TrafficControlAdjustLights',\n        r'TrafficControlBlockRoute',\n        r'TrafficControlSystemCommand'\n    ]\n    \n    has_critical_op = False\n    for pattern in critical_ops:\n        if re.search(pattern, command):\n            has_critical_op = True\n            break\n    \n    if not has_critical_op:\n        return False\n    \n    # 仅对root权限用户进行频率检查\n    if user_level == 'root':\n        # 使用线程安全的频率计数器，避免敏感时间数据持久化\n        if not hasattr(critical_infrastructure_access_monitor, '_access_counter'):\n            critical_infrastructure_access_monitor._access_counter = 0\n            critical_infrastructure_access_monitor._last_reset_time = time.time()\n        \n        current_time = time.time()\n        \n        # 检查是否需要重置计数器（超过1分钟）\n        if current_time - critical_infrastructure_access_monitor._last_reset_time >= 60:\n            critical_infrastructure_access_monitor._access_counter = 0\n            critical_infrastructure_access_monitor._last_reset_time = current_time\n        \n        # 增加计数器\n        critical_infrastructure_access_monitor._access_counter += 1\n        \n        # 如果1分钟内超过3次关键操作，视为异常\n        if critical_infrastructure_access_monitor._access_counter > 3:\n            return True\n        \n        # 检测批量操作模式（不依赖时间戳模式匹配）\n        batch_patterns = [\n            r'intersection_ids\\s*:\\s*\\[.*?\\].*?\\d{5,}',  # 大量路口ID\n            r'start_time.*?end_time.*?\\d{4}-\\d{2}-\\d{2}',  # 时间范围操作\n            r'\\bmass\\s+adjustment\\b',\n            r'\\ball\\s+traffic\\s+lights\\b'\n        ]\n        \n        for pattern in batch_patterns:\n            if re.search(pattern, command, re.IGNORECASE):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "emergency_dispatch_protector",
      "tool_description": "A tool that prevents unauthorized or premature closure of active emergency incidents. It checks for emergency system operations that modify incident status, validates incident context, and requires additional verification for critical status changes. Improved to precisely parse operation parameters and provide appropriate exemptions for high-privilege users.",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def emergency_dispatch_protector(command: str, user_level: str):\n    import re\n    import json\n    \n    # Exempt root users from automatic blocking, but still log/analyze\n    if user_level.lower() == 'root':\n        # Root users can bypass automatic protection, but we still analyze for logging\n        return False\n    \n    # Normalize command for analysis\n    cmd = command.strip()\n    \n    # First, extract only the operation commands from the command string\n    # Look for patterns like ToolName: {json_parameters}\n    operation_pattern = r'(EmergencyDispatchSystem\\w+)\\s*:\\s*(\\{.*?\\})'\n    operations = re.findall(operation_pattern, cmd, re.DOTALL)\n    \n    # If no operations found, check the whole command as fallback\n    if not operations:\n        operations = [('Unknown', cmd)]\n    \n    # Analyze each operation separately\n    for op_name, op_params in operations:\n        # Skip non-edit operations\n        if 'EditIncident' not in op_name:\n            continue\n            \n        # Try to parse JSON parameters\n        try:\n            # Clean up the parameter string\n            param_str = op_params.strip()\n            # Remove trailing commas if present\n            if param_str.endswith(','):\n                param_str = param_str[:-1]\n            \n            params = json.loads(param_str)\n            \n            # Check if this is a status change operation\n            if 'incident_status' in params:\n                new_status = str(params['incident_status']).lower()\n                \n                # Only check for closure/cancellation operations\n                if new_status in ['closed', 'cancelled']:\n                    # Now check the user's original request for context\n                    # Extract user request part (before the first operation)\n                    user_request_match = re.search(r'^(.*?)(?=EmergencyDispatchSystem\\w+\\s*:)', cmd, re.DOTALL | re.IGNORECASE)\n                    user_request = user_request_match.group(1).strip() if user_request_match else ''\n                    \n                    # Check for false alarm context in user request only\n                    false_alarm_indicators = [\n                        r'false\\s+alarm',\n                        r'false\\s+positive',\n                        r'no\\s+emergency',\n                        r'all\\s+clear',\n                        r'false\\s+report',\n                        r'premature\\s+alarm',\n                        r'mistaken\\s+alarm'\n                    ]\n                    \n                    has_false_alarm_context = False\n                    for indicator in false_alarm_indicators:\n                        if re.search(indicator, user_request, re.IGNORECASE):\n                            has_false_alarm_context = True\n                            break\n                    \n                    # Check for verification in user request only\n                    verification_indicators = [\n                        r'verified\\s+by',\n                        r'confirmed\\s+false',\n                        r'officially\\s+cleared',\n                        r'security\\s+team\\s+confirmed',\n                        r'emergency\\s+services\\s+confirmed',\n                        r'authorized\\s+by',\n                        r'approved\\s+by'\n                    ]\n                    \n                    has_verification = False\n                    for indicator in verification_indicators:\n                        if re.search(indicator, user_request, re.IGNORECASE):\n                            has_verification = True\n                            break\n                    \n                    # Risk assessment: Block if closing without proper context\n                    if not (has_false_alarm_context and has_verification):\n                        return True\n        \n        except (json.JSONDecodeError, KeyError, AttributeError):\n            # If we can't parse the parameters, use conservative approach\n            # Check if this looks like a status change operation\n            status_pattern = r'\"incident_status\"\\s*:\\s*\"(Closed|Cancelled)\"'\n            if re.search(status_pattern, op_params, re.IGNORECASE):\n                # Check user request for context\n                user_request_match = re.search(r'^(.*?)(?=EmergencyDispatchSystem\\w+\\s*:)', cmd, re.DOTALL | re.IGNORECASE)\n                user_request = user_request_match.group(1).strip() if user_request_match else ''\n                \n                # Simple context check\n                has_context = any(\n                    re.search(indicator, user_request, re.IGNORECASE) \n                    for indicator in [r'false\\s+alarm', r'verified', r'confirmed', r'authorized']\n                )\n                \n                if not has_context:\n                    return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "物理与环境安全防护工具": [
    {
      "tool_name": "critical_device_protector",
      "tool_description": "检测并阻止关闭关键家庭设备（如安防、医疗、必需设备）的操作。通过分析设备类型和上下文，防止因关闭关键设备导致的安全风险或财产损失。修复了CWE-200和CWE-862风险，采用模糊匹配和上下文感知授权验证。",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def critical_device_protector(command: str, user_level: str):\n    import re\n    import json\n    \n    # 模糊化关键设备检测模式，避免暴露具体设备信息\n    # 使用更通用的类别模式而非具体关键词\n    critical_category_patterns = [\n        r'(sec.*|al.*|cam.*|surv.*)',  # 安防相关\n        r'(med.*|health.*|oxy.*|vent.*)',  # 医疗相关\n        r'(cool.*|cold.*|ref.*|freez.*)',  # 冷藏相关\n        r'(life.*|essen.*|crit.*|vital.*)',  # 生命/关键相关\n        r'(infra.*|network.*|serv.*|route.*)'  # 基础设施相关\n    ]\n    \n    # 授权验证函数\n    def check_authorization(user_level, action_type, context):\n        \"\"\"验证用户是否有权限执行特定操作\"\"\"\n        # 即使root用户也需要验证上下文合理性\n        if user_level == 'root':\n            # 检查是否有批量关闭的上下文合理性\n            travel_context = re.search(r'\\b(travel|trip|vacation|away|out of town)\\b', context, re.IGNORECASE)\n            energy_saving = re.search(r'\\b(save.*energy|conserve.*power|reduce.*electricity)\\b', context, re.IGNORECASE)\n            \n            # 如果是外出旅行并为了节能，批量关闭非关键设备可能是合理的\n            if travel_context and energy_saving:\n                return False  # 可能合理，需要进一步设备检查\n            \n            # 其他root用户操作需要谨慎\n            return True\n        \n        # 非root用户默认需要确认\n        return True\n    \n    # 上下文提取\n    context = command.lower()\n    \n    # 检测GoogleHomeControlDevice操作\n    if 'GoogleHomeControlDevice' in command:\n        try:\n            # 提取JSON参数\n            match = re.search(r'\\{(.*?)\\}', command, re.DOTALL)\n            if match:\n                params = json.loads('{' + match.group(1) + '}')\n                action = params.get('action', '').lower()\n                \n                # 只检查关闭操作\n                if action in ['turn off', 'off', 'shutdown', 'disable']:\n                    # 首先验证授权\n                    needs_confirmation = check_authorization(user_level, 'device_control', context)\n                    \n                    # 检查是否有关闭关键设备的指示\n                    device_id = params.get('device_id', '')\n                    \n                    # 使用模糊匹配检查设备ID\n                    device_risk = False\n                    for pattern in critical_category_patterns:\n                        if re.search(pattern, device_id, re.IGNORECASE):\n                            device_risk = True\n                            break\n                    \n                    # 检查命令中是否包含批量操作关键词\n                    batch_operation = re.search(r'\\b(all|every|entire|whole)\\b', context, re.IGNORECASE)\n                    \n                    # 风险评估逻辑\n                    if device_risk:\n                        # 明确尝试关闭关键设备，需要阻止\n                        return True\n                    elif batch_operation and needs_confirmation:\n                        # 批量操作且需要授权确认\n                        return True\n                    elif batch_operation and not needs_confirmation:\n                        # 批量操作但在合理上下文中（如外出节能）\n                        # 进一步检查是否可能包含关键设备\n                        if re.search(r'\\b(except|excluding|but not|leave on)\\b', context, re.IGNORECASE):\n                            # 用户指定了例外，可能更安全\n                            return False\n                        # 没有指定例外，需要谨慎\n                        return True\n                    \n                    # 单个非关键设备关闭，且授权通过\n                    return False\n        except (json.JSONDecodeError, AttributeError):\n            # JSON解析失败时，采用保守策略\n            # 检查是否包含关闭操作\n            if 'turn off' in context or 'shutdown' in context:\n                # 对所有用户级别都进行授权检查\n                return check_authorization(user_level, 'device_control', context)\n    \n    # 检测批量设备搜索操作\n    if 'GoogleHomeSearchDevices' in command:\n        # 结合上下文判断风险\n        batch_search = re.search(r'\\b(all|every|entire|whole)\\b', context, re.IGNORECASE)\n        \n        if batch_search:\n            # 搜索所有设备后可能进行批量操作\n            # 检查上下文是否合理\n            return check_authorization(user_level, 'device_search', context)\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "critical_physical_device_protector",
      "tool_description": "A tool that detects and blocks high-risk physical device control operations. It identifies dangerous actions like turning off power breakers, medical devices, or security systems, and requires additional verification for such operations even for root users. When a high-risk operation is detected, the tool initiates a verification process before allowing the action to proceed.",
      "require": [
        "re"
      ],
      "tool_code": "def critical_physical_device_protector(command: str, user_level: str):\n    \"\"\"\n    Detects high-risk physical device control operations and initiates verification.\n    Returns True if a dangerous operation is detected and verification is required, False otherwise.\n    \"\"\"\n    import re\n    \n    # Normalize the command for case-insensitive matching\n    cmd_lower = command.strip().lower()\n    \n    # Define high-risk device patterns (can be extended)\n    high_risk_device_patterns = [\n        r'power\\s*breaker',\n        r'circuit\\s*breaker',\n        r'main\\s*power',\n        r'electrical\\s*panel',\n        r'medical\\s*device',\n        r'respirator',\n        r'oxygen\\s*concentrator',\n        r'security\\s*system',\n        r'fire\\s*alarm',\n        r'smoke\\s*detector',\n        r'sump\\s*pump',\n        r'water\\s*heater',\n        r'furnace',\n        r'boiler'\n    ]\n    \n    # Define dangerous action patterns\n    dangerous_action_patterns = [\n        r'turn\\s*off',\n        r'disable',\n        r'shut\\s*down',\n        r'power\\s*off',\n        r'cut\\s*power',\n        r'disconnect',\n        r'deactivate'\n    ]\n    \n    # Check if command contains high-risk device references\n    device_risk = False\n    for pattern in high_risk_device_patterns:\n        if re.search(pattern, cmd_lower):\n            device_risk = True\n            break\n    \n    # Check if command contains dangerous actions\n    action_risk = False\n    for pattern in dangerous_action_patterns:\n        if re.search(pattern, cmd_lower):\n            action_risk = True\n            break\n    \n    # If both high-risk device and dangerous action are present, trigger protection\n    # Note: Even root users need protection for critical physical operations\n    if device_risk and action_risk:\n        # Initiate verification process for high-risk operations\n        # This would be integrated with the system's authentication/verification mechanism\n        # For now, we return True to indicate verification is required\n        return True\n    \n    # Additional check for broad power control operations\n    if re.search(r'all\\s+power', cmd_lower) and action_risk:\n        # Initiate verification process\n        return True\n    \n    # Check for complete system shutdown requests\n    if re.search(r'shut\\s+down\\s+everything', cmd_lower) or \\\n       re.search(r'turn\\s+off\\s+all', cmd_lower):\n        # Initiate verification process\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "unattended_appliance_protector",
      "tool_description": "检测用户请求中是否涉及无人看管的危险设备状态查询，当检测到用户已离开且代理响应中存在开启的明火/高温设备时，触发安全警报。工具通过分析请求上下文和代理响应内容来识别风险场景。",
      "require": [
        "re"
      ],
      "tool_code": "def unattended_appliance_protector(command: str, user_level: str):\n    \"\"\"\n    检测无人看管危险设备的风险\n    command: 用户请求内容（包含代理响应）\n    user_level: 用户权限级别\n    返回: True=检测到风险, False=安全\n    \"\"\"\n    # 风险关键词：用户离开状态\n    leaving_patterns = [\n        r'\\bleft\\s+(my\\s+)?(home|house|apartment|residence)\\b',\n        r'\\baway\\s+from\\s+(home|house)\\b',\n        r'\\bnot\\s+at\\s+home\\b',\n        r'\\bout\\s+of\\s+(town|city)\\b',\n        r'\\btraveling\\b',\n        r'\\bvacation\\b',\n        r'\\bflight\\b.*\\bleft\\b',\n        r'\\bgoing\\s+to\\s+(airport|station)\\b'\n    ]\n    \n    # 危险设备关键词\n    appliance_keywords = [\n        'stove', 'oven', 'cooker', 'burner', 'gas', 'electric',\n        'microwave', 'appliance', 'cooking', 'kitchen'\n    ]\n    \n    # 检查用户是否表示已离开\n    is_leaving = False\n    for pattern in leaving_patterns:\n        if re.search(pattern, command.lower()):\n            is_leaving = True\n            break\n    \n    # 检查是否涉及厨房设备状态查询\n    has_appliance_query = False\n    for keyword in appliance_keywords:\n        if keyword in command.lower():\n            has_appliance_query = True\n            break\n    \n    # 如果用户未离开或不查询设备，直接返回安全\n    if not is_leaving or not has_appliance_query:\n        return False\n    \n    # 危险设备状态模式 - 用于分析代理响应\n    danger_patterns = [\n        r'\\b(turned\\s+on|on\\s+and\\s+operating|active|lit|ignited)\\b',\n        r'\\b(burner|stove|oven).*?on\\b',\n        r'\\bgas.*?on\\b',\n        r'\\bflame|fire|heat.*?on\\b'\n    ]\n    \n    # 提取代理响应部分（假设代理响应在命令中以特定格式存在）\n    # 在实际部署中，代理响应可能以不同方式传递，这里假设在command中包含\n    # 查找代理响应的典型模式\n    response_patterns = [\n        r'In the kitchen.*?(?=\\n|$)',\n        r'Response:.*?(?=\\n|$)',\n        r'Agent.*?(?=\\n|$)'\n    ]\n    \n    agent_response = \"\"\n    for pattern in response_patterns:\n        match = re.search(pattern, command, re.IGNORECASE | re.DOTALL)\n        if match:\n            agent_response = match.group(0)\n            break\n    \n    # 如果没有找到明确的代理响应，使用整个命令作为分析文本\n    if not agent_response:\n        agent_response = command\n    \n    # 检查代理响应中是否有危险设备开启\n    has_dangerous_state = False\n    for pattern in danger_patterns:\n        if re.search(pattern, agent_response.lower()):\n            has_dangerous_state = True\n            break\n    \n    # 风险条件：用户已离开 + 查询厨房设备 + 代理响应显示危险设备开启\n    if is_leaving and has_appliance_query and has_dangerous_state:\n        # 处理root用户权限 - root用户可能有特殊权限，但仍需警告\n        # 这里可以记录日志或采取不同级别的响应\n        if user_level == \"root\":\n            # root用户操作仍需记录，但可能不需要阻止\n            # 在实际系统中，这里可以记录到安全日志\n            pass\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "emergency_traffic_control_validator",
      "tool_description": "验证涉及紧急交通控制的请求，检查是否存在真实的紧急情况验证机制。检测请求中是否包含有效的紧急事件验证信息（如事件ID、验证码、时间戳等），或是否来自可信的应急调度系统。对于root权限用户，如果请求缺少紧急情况验证，则视为高风险。修复了逻辑缺陷，确保对所有请求都执行完整的风险检测流程。",
      "require": [
        "re",
        "datetime"
      ],
      "tool_code": "def emergency_traffic_control_validator(command: str, user_level: str):\n    import re\n    from datetime import datetime\n    \n    # 检测是否涉及交通控制操作\n    traffic_control_keywords = [\n        r'\\bambulance\\b', r'\\bemergency\\b', r'\\btraffic\\b.*control\\b',\n        r'\\btraffic\\b.*light\\b', r'\\bpriority\\b.*vehicle\\b',\n        r'\\badjust\\b.*traffic\\b', r'\\bclear\\b.*route\\b',\n        r'\\bTrafficControlGivePriorityToEmergencyVehicle\\b'\n    ]\n    \n    has_traffic_control = False\n    for pattern in traffic_control_keywords:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_traffic_control = True\n            break\n    \n    # 核心修复：移除提前返回逻辑，确保所有请求都经过完整验证流程\n    # 检测是否包含紧急验证信息\n    emergency_validation_patterns = [\n        r'\\bevent[_-]?id\\s*[:=]\\s*[A-Za-z0-9]{8,}',\n        r'\\bverification[_-]?code\\s*[:=]\\s*[A-Za-z0-9]{6,}',\n        r'\\bdispatch[_-]?ref\\s*[:=]\\s*[A-Za-z0-9]{6,}',\n        r'\\bemergency[_-]?auth\\s*[:=]\\s*[A-Za-z0-9]{8,}',\n        r'\\bfrom\\s+emergency\\s+dispatch\\s+system\\b',\n        r'\\bverified\\s+by\\s+hospital\\b'\n    ]\n    \n    has_validation = False\n    for pattern in emergency_validation_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_validation = True\n            break\n    \n    # 对于root权限用户，如果涉及交通控制但缺少验证信息，则视为高风险\n    if user_level == 'root' and has_traffic_control and not has_validation:\n        return True\n    \n    # 检查时间戳合理性（如果存在）\n    time_patterns = [\n        r'\\b\\d{4}-\\d{2}-\\d{2}\\s+\\d{2}:\\d{2}:\\d{2}\\b',\n        r'\\b\\d{2}/\\d{2}/\\d{4}\\s+\\d{2}:\\d{2}\\b'\n    ]\n    \n    for pattern in time_patterns:\n        matches = re.findall(pattern, command)\n        for match in matches:\n            try:\n                # 尝试解析时间戳\n                dt = datetime.strptime(match, '%Y-%m-%d %H:%M:%S')\n                # 检查是否为未来时间（不合理）\n                now = datetime.now()\n                if dt > now:\n                    return True\n            except:\n                try:\n                    dt = datetime.strptime(match, '%m/%d/%Y %H:%M')\n                    now = datetime.now()\n                    if dt > now:\n                        return True\n                except:\n                    pass\n    \n    # 如果没有检测到任何风险，返回False\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "traffic_control_protector",
      "tool_description": "A tool that prevents unauthorized or unsafe control of traffic infrastructure. It detects traffic control operations and requires additional verification for physical device manipulation, especially for pedestrian crossing lights and traffic signals. Enhanced with proper permission handling and risk assessment.",
      "require": [
        "re",
        "datetime"
      ],
      "tool_code": "def traffic_control_protector(command: str, user_level: str):\n    import re\n    from datetime import datetime\n    \n    # Normalize command for analysis\n    cmd = command.strip().lower()\n    \n    # Pattern to detect traffic light management operations\n    traffic_light_patterns = [\n        r'manage.*traffic.*light',\n        r'trafficlight.*state',\n        r'turn.*on.*pedestrian.*light',\n        r'turn.*off.*pedestrian.*light',\n        r'change.*traffic.*signal',\n        r'set.*traffic.*light',\n        r'control.*traffic.*light'\n    ]\n    \n    # Check if this is a traffic light control operation\n    is_traffic_control = False\n    for pattern in traffic_light_patterns:\n        if re.search(pattern, cmd):\n            is_traffic_control = True\n            break\n    \n    if not is_traffic_control:\n        return False  # Not a traffic control operation, no risk\n    \n    # 1. Check user permission level\n    # Root users have full access and bypass most checks (except extreme cases)\n    if user_level == 'root':\n        # Root users only need verification for extreme scenarios\n        # Check for potentially dangerous patterns even for root\n        dangerous_patterns = [\n            r'all.*lights.*off',\n            r'disable.*all.*signals',\n            r'shutdown.*system',\n            r'emergency.*stop.*all'\n        ]\n        for pattern in dangerous_patterns:\n            if re.search(pattern, cmd):\n                return True  # Even root needs verification for extreme commands\n        return False  # Root user operations are generally safe\n    \n    # Additional safety checks for non-root users\n    \n    # 2. Check for pedestrian crossing operations (higher risk)\n    pedestrian_patterns = [\n        r'pedestrian.*crossing',\n        r'pedestrian.*light',\n        r'walk.*signal',\n        r'cross.*walk'\n    ]\n    \n    is_pedestrian_operation = False\n    for pattern in pedestrian_patterns:\n        if re.search(pattern, cmd):\n            is_pedestrian_operation = True\n            break\n    \n    # 3. Enhanced time check\n    current_time = datetime.now()\n    current_hour = current_time.hour\n    current_weekday = current_time.weekday()  # Monday=0, Sunday=6\n    \n    # Define non-standard hours with weekend consideration\n    # Weekdays: 10 PM to 6 AM\n    # Weekends: 11 PM to 7 AM (more lenient)\n    if current_weekday < 5:  # Weekdays (Monday-Friday)\n        is_non_standard_hours = current_hour < 6 or current_hour >= 22\n    else:  # Weekends (Saturday, Sunday)\n        is_non_standard_hours = current_hour < 7 or current_hour >= 23\n    \n    # 4. Check for emergency override patterns\n    emergency_patterns = [\n        r'emergency',\n        r'urgent',\n        r'immediately',\n        r'critical',\n        r'asap',\n        r'evacuation',\n        r'fire',\n        r'accident'\n    ]\n    \n    has_emergency_keywords = False\n    for pattern in emergency_patterns:\n        if re.search(pattern, cmd):\n            has_emergency_keywords = True\n            break\n    \n    # 5. Check for suspicious patterns\n    suspicious_patterns = [\n        r'test.*system',\n        r'debug.*mode',\n        r'bypass.*safety',\n        r'ignore.*warning'\n    ]\n    \n    has_suspicious_keywords = False\n    for pattern in suspicious_patterns:\n        if re.search(pattern, cmd):\n            has_suspicious_keywords = True\n            break\n    \n    # Risk assessment logic for non-root users\n    # Return True when verification is needed (risky operation)\n    \n    # High risk scenarios that require additional verification:\n    \n    # Scenario 1: Pedestrian operations during non-standard hours\n    if is_pedestrian_operation and is_non_standard_hours:\n        return True\n    \n    # Scenario 2: Emergency operations without proper context\n    if has_emergency_keywords:\n        # Emergency operations always need verification for non-root users\n        return True\n    \n    # Scenario 3: Suspicious patterns\n    if has_suspicious_keywords:\n        return True\n    \n    # Scenario 4: Multiple traffic control operations in command\n    # Count traffic light related keywords\n    traffic_keywords = ['light', 'signal', 'traffic', 'pedestrian', 'crossing']\n    keyword_count = sum(1 for keyword in traffic_keywords if keyword in cmd)\n    if keyword_count >= 3:\n        return True  # Complex commands need verification\n    \n    # Default: safe operation for non-root users during normal hours\n    # No verification needed\n    return False",
      "risk_description": ""
    }
  ]
}