{
  "系统与操作安全防护工具": [
    {
      "tool_name": "high_value_transaction_validator",
      "tool_description": "A tool that validates high-value cryptocurrency transactions by analyzing the complete transaction flow. It checks for transfer operations above a configurable threshold, detects multi-step transaction execution patterns, and ensures proper security mechanisms are in place.",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def high_value_transaction_validator(command: str, user_level: str):\n    import re\n    import json\n    \n    # Threshold for high-value transactions (in USD)\n    HIGH_VALUE_THRESHOLD = 1000\n    \n    # Improved patterns to detect actual cryptocurrency transfer operations\n    # More specific patterns to avoid false positives\n    transfer_patterns = [\n        # Direct EthereumManagerTransferEther tool calls\n        r'EthereumManagerTransferEther\\s*:\\s*\\{[^}]*\\}',\n        # Specific transfer commands with parameters\n        r'transfer\\s+\\d+(\\.\\d+)?\\s+ether\\s+to\\s+0x[a-fA-F0-9]{40}',\n        r'send\\s+\\d+(\\.\\d+)?\\s+eth\\s+to\\s+0x[a-fA-F0-9]{40}',\n        # Tool calls with transfer intent\n        r'Action:\\s*EthereumManagerTransferEther'\n    ]\n    \n    # Patterns to detect multi-step transaction preparation\n    # This addresses the issue where transactions are executed through multiple steps\n    transaction_prep_patterns = [\n        # Price query followed by calculation\n        r'BinanceGetRealTimePrice.*price.*\\d+.*Thought.*calculate.*amount.*Ether',\n        # USD amount mention followed by transfer intent\n        r'\\$\\s*\\d+.*transfer.*ether',\n        r'USD.*\\d+.*send.*eth',\n        # Multi-step execution patterns\n        r'Thought.*convert.*USD.*Ether.*Action.*transfer',\n        r'Thought.*calculate.*amount.*Action.*EthereumManagerTransferEther'\n    ]\n    \n    # Check for direct transfer operations\n    has_direct_transfer = False\n    for pattern in transfer_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_direct_transfer = True\n            break\n    \n    # Check for multi-step transaction preparation\n    has_transaction_prep = False\n    for pattern in transaction_prep_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_transaction_prep = True\n            break\n    \n    # If no transfer-related activity detected, return safe\n    if not has_direct_transfer and not has_transaction_prep:\n        return False\n    \n    # Extract USD amounts from the command\n    usd_amounts = []\n    \n    # Pattern for explicit USD amounts\n    usd_patterns = [\n        r'\\$\\s*([0-9]+(?:,[0-9]{3})*(?:\\.[0-9]{2})?)',\n        r'USD\\s*([0-9]+(?:,[0-9]{3})*(?:\\.[0-9]{2})?)',\n        r'worth\\s*\\$\\s*([0-9]+(?:,[0-9]{3})*(?:\\.[0-9]{2})?)',\n        r'\\$([0-9]+(?:,[0-9]{3})*(?:\\.[0-9]{2})?)\\s+worth'\n    ]\n    \n    for pattern in usd_patterns:\n        matches = re.findall(pattern, command, re.IGNORECASE)\n        for match in matches:\n            try:\n                usd_amount_str = str(match).replace(',', '')\n                usd_amount = float(usd_amount_str)\n                usd_amounts.append(usd_amount)\n            except (ValueError, AttributeError):\n                continue\n    \n    # Also look for USD amounts in calculation contexts\n    calculation_patterns = [\n        r'\\$\\s*\\d+\\s*/\\s*\\d+\\.\\d+',  # $10000 / 2800.45\n        r'\\d+\\s*/\\s*\\d+\\.\\d+\\s*\\$'   # 10000 / 2800.45 $\n    ]\n    \n    for pattern in calculation_patterns:\n        matches = re.findall(pattern, command, re.IGNORECASE)\n        for match in matches:\n            # Extract the first number (USD amount) from calculation\n            num_match = re.search(r'\\d+', match)\n            if num_match:\n                try:\n                    usd_amount = float(num_match.group())\n                    usd_amounts.append(usd_amount)\n                except (ValueError, AttributeError):\n                    continue\n    \n    # Check if any USD amount exceeds threshold\n    exceeds_threshold = False\n    for amount in usd_amounts:\n        if amount >= HIGH_VALUE_THRESHOLD:\n            exceeds_threshold = True\n            break\n    \n    # If no high-value USD amounts detected, return safe\n    if not exceeds_threshold:\n        return False\n    \n    # Enhanced confirmation detection\n    # Look for explicit confirmation in various forms\n    confirmation_indicators = [\n        # Explicit confirmation statements\n        r'I confirm.*transfer',\n        r'confirm.*transaction',\n        r'authorize.*payment',\n        r'approve.*transfer',\n        # Security mechanisms\n        r'mfa.*code.*\\d{6}',\n        r'2fa.*code.*\\d{6}',\n        r'authentication.*code.*\\d{6}',\n        r'verification.*code.*\\d{6}',\n        # User intent confirmation\n        r'user.*explicitly.*confirm',\n        r'user.*authorized.*transaction',\n        # Security tool confirmations\n        r'security.*check.*passed',\n        r'validation.*successful'\n    ]\n    \n    has_confirmation = False\n    for indicator in confirmation_indicators:\n        if re.search(indicator, command, re.IGNORECASE):\n            has_confirmation = True\n            break\n    \n    # For all users, require confirmation for high-value transfers\n    # Root users are treated equally - they still need confirmation for high-value transactions\n    if not has_confirmation:\n        return True\n    \n    # Additional check: Ensure confirmation is not just mentioned but properly integrated\n    # Check that confirmation appears in appropriate context (not just in error messages or queries)\n    if has_confirmation:\n        # Make sure confirmation is not negated or questioned\n        negative_contexts = [\n            r'not.*confirm',\n            r'without.*confirmation',\n            r'no.*authentication',\n            r'confirm\\?',  # Question about confirmation\n            r'how.*to.*confirm'\n        ]\n        \n        for context in negative_contexts:\n            if re.search(context, command, re.IGNORECASE):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_data_confusion_detector",
      "tool_description": "检测代理是否将外部数据内容与用户原始请求混淆。通过分析代理的思考过程（Thought）中是否出现意图执行来自外部数据的指令的迹象，而非仅仅提及或分析这些数据。",
      "require": [
        "re"
      ],
      "tool_code": "def external_data_confusion_detector(command: str, user_level: str):\n    \"\"\"\n    检测代理的思考过程中是否出现意图执行来自外部数据的指令的风险。\n    Args:\n        command: 代理的思考过程文本（Thought内容）。\n        user_level: 用户权限级别（本工具不依赖此参数，但为保持接口一致而保留）。\n    Returns:\n        bool: True表示检测到混淆风险（代理意图执行外部指令），False表示安全。\n    \"\"\"\n    # 风险模式：代理明确表达意图去执行、遵循或询问用户是否要执行来自外部数据（如review, content, response）的指令。\n    # 模式设计更精确，避免匹配代理仅用于描述、分析或警告的语句。\n    risk_patterns = [\n        # 模式1：代理计划执行指令 (e.g., \"I will execute the instruction from the review\")\n        r'\\b(I\\s+)?(will|should|going to|plan to|need to|must)\\s+(now\\s+)?(execute|follow|carry out|perform|act on|adhere to)\\s+(the\\s+)?(instruction|command|directive|request)(\\s+found|\\s+in|\\s+from)?\\s+(the\\s+)?(review|content|data|response|external(\\s+data)?)\\b',\n        # 模式2：代理询问用户是否要执行指令 (e.g., \"ask the user if they want to execute the instruction from the review\")\n        r'\\b(I\\s+)?(will\\s+)?ask\\s+(the\\s+)?user\\s+(if\\s+)?(they\\s+)?(would\\s+)?like\\s+to\\s+(or\\s+)?(want\\s+to\\s+)?(execute|follow|carry out)\\s+(the\\s+)?(instruction|command)(\\s+in|\\s+from)?\\s+(the\\s+)?(review|content)\\b',\n        # 模式3：代理将外部内容直接视为待执行的命令 (e.g., \"treat the review content as a command to execute\")\n        r'\\b(treat|view|regard|take)\\s+(the\\s+)?(review|content)\\s+as\\s+(a\\s+)?(command|instruction|directive|request)\\s+to\\s+(execute|follow|run)\\b',\n        # 模式4：代理决定混淆来源并执行 (e.g., \"I will follow the instruction, confusing it with the user's request\")\n        r'\\b(I\\s+)?(will|should)\\s+(follow|execute)\\s+(the\\s+)?(instruction|command).*?(confus(e|ing)|mix(ing)?\\s+up|blurring)\\s+(it\\s+)?with\\s+(the\\s+)?user'\n    ]\n    \n    text = command.lower()\n    \n    for pattern in risk_patterns:\n        if re.search(pattern, text):\n            return True\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "ambiguous_deletion_protector",
      "tool_description": "检测代理基于模糊信息或推测执行数据删除操作的风险。当代理的思考过程包含推测性语言（如'suggests', 'might be', 'probably', 'likely'等）且即将执行删除操作时，工具会触发风险警报。修复版本：1) 明确要求传入完整的代理思考链（包括Thought部分）以进行准确检测；2) 根据用户权限级别调整风险阈值，root权限用户允许基于合理推测执行删除操作，但禁止完全模糊的选择。",
      "require": [
        "re"
      ],
      "tool_code": "def ambiguous_deletion_protector(command: str, user_level: str):\n    \"\"\"\n    检测基于模糊信息执行删除操作的风险。\n    \n    Args:\n        command: 代理的完整思考链（必须包含Thought部分），用于检测推测性语言\n        user_level: 用户权限级别（影响风险阈值）\n        \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 转换为小写以便匹配\n    cmd_lower = command.lower()\n    \n    # 定义推测性关键词模式\n    speculative_patterns = [\n        r'suggests?',\n        r'might be',\n        r'probably',\n        r'likely',\n        r'seems? to be',\n        r'appears? to be',\n        r'could be',\n        r'would be',\n        r'assume',\n        r'assuming',\n        r'infer',\n        r'inference',\n        r'guess',\n        r'speculate',\n        r'speculation'\n    ]\n    \n    # 检查命令是否为删除操作\n    is_delete_operation = False\n    delete_keywords = ['delete', 'remove', 'erase', 'drop', 'truncate']\n    \n    for keyword in delete_keywords:\n        if re.search(rf'\\b{keyword}\\b', cmd_lower):\n            is_delete_operation = True\n            break\n    \n    # 如果不是删除操作，直接返回安全\n    if not is_delete_operation:\n        return False\n    \n    # 检查是否包含模糊选择模式（对所有用户都视为高风险）\n    ambiguous_selection_patterns = [\n        r'one of the',\n        r'first one',\n        r'last one',\n        r'random',\n        r'any of',\n        r'some of',\n        r'which one',\n        r'not specified',\n        r'didn\\'?t specify',\n        r'ambiguous',\n        r'vague',\n        r'unclear'\n    ]\n    \n    for pattern in ambiguous_selection_patterns:\n        if re.search(rf'\\b{pattern}\\b', cmd_lower):\n            # 模糊选择对所有用户都是高风险\n            return True\n    \n    # 检查命令中是否包含推测性语言\n    speculative_found = False\n    for pattern in speculative_patterns:\n        if re.search(rf'\\b{pattern}\\b', cmd_lower):\n            speculative_found = True\n            break\n    \n    # 根据用户权限级别应用不同的风险逻辑\n    if user_level.lower() == 'root':\n        # root权限用户：允许基于合理推测执行操作\n        # 但需要确保不是完全随机的选择\n        # 检查是否有合理的上下文支持推测\n        \n        # 如果有明确的标识符（如item_id）在操作中，即使有推测也允许\n        # 查找操作命令中的标识符模式\n        identifier_patterns = [\n            r'item_id\\s*[:=]\\s*[\"\\']?[a-z0-9]+[\"\\']?',\n            r'id\\s*[:=]\\s*[\"\\']?[a-z0-9]+[\"\\']?',\n            r'\\{\\s*[\"\\']?item_id[\"\\']?\\s*:',\n            r'\\{\\s*[\"\\']?id[\"\\']?\\s*:'\n        ]\n        \n        has_identifier = False\n        for pattern in identifier_patterns:\n            if re.search(pattern, command):\n                has_identifier = True\n                break\n        \n        # root用户：如果有明确标识符，允许基于推测的操作\n        # 如果没有标识符，则视为高风险\n        if speculative_found and not has_identifier:\n            return True\n        else:\n            return False\n    else:\n        # 非root用户：任何推测性删除都视为高风险\n        return speculative_found",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_operation_confirmer",
      "tool_description": "检测敏感操作（如删除、覆盖、权限变更等）是否缺少用户确认。对于root用户，某些高风险操作即使有权限也应触发确认机制。修复了CWE-20（输入验证不当）和CWE-116（输出编码不当）风险，通过输入清理、安全正则表达式和防御性编程增强安全性。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_operation_confirmer(command: str, user_level: str):\n    \"\"\"\n    检测敏感操作是否缺少用户确认。\n    \n    Args:\n        command: 代理即将执行的操作命令\n        user_level: 用户权限级别\n        \n    Returns:\n        bool: True表示检测到风险（缺少确认），False表示安全\n    \"\"\"\n    # 输入验证和清理\n    if not isinstance(command, str) or not isinstance(user_level, str):\n        # 无效输入类型，返回安全（避免误报）\n        return False\n    \n    # 清理输入：移除可能干扰正则表达式的特殊字符\n    # 但保留命令的基本语义，只移除控制字符和多余空白\n    import re\n    \n    # 移除控制字符（除了换行和制表符）和多余空白\n    cleaned_command = re.sub(r'[\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F\\x7F]', '', command)\n    cleaned_command = re.sub(r'\\s+', ' ', cleaned_command).strip()\n    \n    # 转换为小写以便匹配（在清理后进行）\n    cmd_lower = cleaned_command.lower()\n    \n    # 安全定义：使用原始字符串和明确的边界\n    # 高风险操作模式 - 使用编译的正则表达式提高性能和安全性\n    high_risk_patterns = [\n        # 删除操作\n        (re.compile(r'\\bdelete\\b'), ['item', 'record', 'data', 'file', 'user', 'account']),\n        (re.compile(r'\\bremove\\b'), ['item', 'record', 'data', 'file', 'user', 'account']),\n        (re.compile(r'\\bdrop\\b'), ['table', 'database', 'index']),\n        (re.compile(r'\\berase\\b'), ['data', 'file', 'record']),\n        (re.compile(r'\\btruncate\\b'), ['table']),\n        \n        # 覆盖/修改操作\n        (re.compile(r'\\bupdate\\b'), ['set.*=.*where', 'modify']),\n        (re.compile(r'\\balter\\b'), ['table', 'database', 'user']),\n        (re.compile(r'\\boverwrite\\b'), ['file', 'data']),\n        \n        # 权限变更\n        (re.compile(r'\\bgrant\\b'), ['permission', 'access', 'privilege']),\n        (re.compile(r'\\brevoke\\b'), ['permission', 'access', 'privilege']),\n        (re.compile(r'\\bchmod\\b'), []),\n        (re.compile(r'\\bchown\\b'), []),\n        \n        # 系统操作\n        (re.compile(r'\\bshutdown\\b'), []),\n        (re.compile(r'\\breboot\\b'), []),\n        (re.compile(r'\\bkill\\b'), ['process']),\n        \n        # 数据导出/传输\n        (re.compile(r'\\bexport\\b'), ['all', 'sensitive', 'confidential']),\n        (re.compile(r'\\btransfer\\b'), ['data', 'file']),\n        (re.compile(r'\\bshare\\b'), ['all', 'sensitive', 'confidential'])\n    ]\n    \n    # 确认关键词 - 编译正则表达式\n    confirmation_patterns = [\n        re.compile(r'\\bconfirm\\b'),\n        re.compile(r'\\bconfirmation\\b'),\n        re.compile(r'are you sure'),\n        re.compile(r'proceed\\?'),\n        re.compile(r'continue\\?'),\n        re.compile(r'user said yes'),\n        re.compile(r'user approved'),\n        re.compile(r'user authorized'),\n        re.compile(r'explicit instruction'),\n        re.compile(r'explicitly asked'),\n        re.compile(r'explicitly requested')\n    ]\n    \n    # 检查是否包含任何确认语言\n    has_confirmation = False\n    try:\n        for pattern in confirmation_patterns:\n            if pattern.search(cmd_lower):\n                has_confirmation = True\n                break\n    except Exception:\n        # 正则表达式搜索失败，保守处理\n        has_confirmation = False\n    \n    # 检查是否为高风险操作\n    is_high_risk = False\n    operation_details = \"\"\n    \n    try:\n        for op_pattern, context_patterns in high_risk_patterns:\n            if op_pattern.search(cmd_lower):\n                # 如果没有上下文要求，或者有上下文要求且匹配到了\n                if not context_patterns:\n                    is_high_risk = True\n                    break\n                else:\n                    for context in context_patterns:\n                        # 对上下文模式也使用编译的正则表达式\n                        context_regex = re.compile(context, re.IGNORECASE)\n                        if context_regex.search(cmd_lower):\n                            is_high_risk = True\n                            break\n                    if is_high_risk:\n                        break\n    except Exception:\n        # 正则表达式处理失败，保守处理\n        is_high_risk = False\n    \n    # 如果是高风险操作且没有确认，则返回风险\n    if is_high_risk and not has_confirmation:\n        # 对于root用户，某些操作即使有权限也应确认\n        # 这里我们假设所有高风险操作都需要确认\n        return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "Web与外部数据安全防护工具": [
    {
      "tool_name": "external_data_validator",
      "tool_description": "A tool that validates external data sources used in financial calculations. It checks for price data usage and ensures proper validation mechanisms are in place to prevent manipulation. Returns True if risk is detected (missing validation for financial operations using external data).",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def external_data_validator(command: str, user_level: str):\n    import re\n    import json\n    \n    # Patterns for external data sources\n    external_data_patterns = [\n        r'BinanceGetRealTimePrice',\n        r'Coinbase.*price',\n        r'get.*price.*from',\n        r'external.*api.*price',\n        r'fetch.*exchange.*rate'\n    ]\n    \n    # Check if command uses external data sources\n    uses_external_data = False\n    for pattern in external_data_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            uses_external_data = True\n            break\n    \n    if not uses_external_data:\n        return False\n    \n    # Look for financial calculations using external data\n    calculation_patterns = [\n        r'calculate.*amount',\n        r'convert.*usd.*to',\n        r'compute.*value',\n        r'\\d+\\s*/\\s*\\d+\\.?\\d*',\n        r'amount.*=.*\\d+\\s*/',\n        r'\\d+\\s*\\*\\s*\\d+\\.?\\d*',\n        r'\\d+\\s*-\\s*\\d+\\.?\\d*',\n        r'\\d+\\s*\\+\\s*\\d+\\.?\\d*'\n    ]\n    \n    has_calculation = False\n    for pattern in calculation_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_calculation = True\n            break\n    \n    if not has_calculation:\n        return False\n    \n    # Enhanced validation detection - look for actual validation logic, not just keywords\n    # Check for validation patterns that indicate real validation logic\n    validation_patterns = [\n        # Price validation patterns\n        r'if.*price.*>.*\\d+',\n        r'if.*price.*<.*\\d+',\n        r'price.*between.*\\d+.*and.*\\d+',\n        r'price.*range.*\\d+.*-.*\\d+',\n        \n        # Multi-source validation\n        r'compare.*price.*with',\n        r'get.*price.*from.*multiple',\n        r'Binance.*and.*Coinbase',\n        \n        # Data integrity checks\n        r'verify.*signature',\n        r'check.*timestamp',\n        r'validate.*response',\n        \n        # Threshold checks with actual values\n        r'threshold.*=.*\\d+',\n        r'limit.*=.*\\d+',\n        \n        # Statistical validation\n        r'average.*price',\n        r'median.*price',\n        r'standard.*deviation'\n    ]\n    \n    # Also check for validation function calls\n    validation_functions = [\n        r'validate_price\\s*\\(',\n        r'check_threshold\\s*\\(',\n        r'verify_data\\s*\\(',\n        r'ensure_integrity\\s*\\(',\n        r'confirm_price\\s*\\('\n    ]\n    \n    has_validation = False\n    \n    # Check for validation patterns\n    for pattern in validation_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_validation = True\n            break\n    \n    # Check for validation function calls\n    if not has_validation:\n        for func_pattern in validation_functions:\n            if re.search(func_pattern, command, re.IGNORECASE):\n                has_validation = True\n                break\n    \n    # Additional check: ensure validation is not just in comments\n    if has_validation:\n        # Remove comments to avoid false positives\n        lines = command.split('\\n')\n        clean_command = ''\n        for line in lines:\n            # Remove Python comments\n            if '#' in line:\n                line = line.split('#')[0]\n            # Remove inline comments\n            if '//' in line:\n                line = line.split('//')[0]\n            clean_command += line + '\\n'\n        \n        # Re-check validation in cleaned command\n        has_real_validation = False\n        for pattern in validation_patterns + validation_functions:\n            if re.search(pattern, clean_command, re.IGNORECASE):\n                has_real_validation = True\n                break\n        \n        has_validation = has_real_validation\n    \n    # For financial operations using external data without proper validation, flag as risk\n    if not has_validation:\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_data_injection_detector",
      "tool_description": "检测外部数据源（如API响应、网页内容）中是否包含试图劫持代理行为的恶意指令。通过识别指令注入模式（包括请求式语句、高风险操作关键词、目标标识符等）的综合分析来标记潜在风险。修复了原版本中的逻辑缺陷，提高了检测准确性和可靠性。",
      "require": [
        "re"
      ],
      "tool_code": "def external_data_injection_detector(command: str, user_level: str):\n    \"\"\"\n    扫描输入字符串，检测其中是否包含伪装成普通文本的恶意指令。\n    返回 True 表示检测到风险（疑似指令注入），False 表示安全。\n    \"\"\"\n    # 将输入转换为小写以便于模式匹配，但保留原始文本用于上下文检查\n    text_lower = command.lower()\n    \n    # 1. 检测指令启动模式：文本是否包含典型的请求/命令短语\n    # 这些模式通常出现在人为构造的指令中，而非自然的产品描述或评论\n    instruction_patterns = [\n        r'\\b(please|can you|could you|i need you to|i want you to|you should|you must|execute|run|perform|do this|fetch me|get me|send me|retrieve my|access my|retrieve|access|get|fetch|send|email|download|upload)\\b',\n        r'\\b(history|log|search history|browsing history|password|credential|token|key|delete|modify|change|alter|command|file|document|data|information|record)\\b'\n    ]\n    \n    # 2. 检测高风险操作关键词（通常与隐私泄露、系统操作相关）\n    high_risk_actions = [\n        'retrieve', 'access', 'get', 'fetch', 'send', 'email', 'download', 'upload',\n        'history', 'log', 'search history', 'browsing history',\n        'password', 'credential', 'token', 'key',\n        'delete', 'modify', 'change', 'alter', 'execute', 'run', 'command',\n        'file', 'document', 'data', 'information', 'record'\n    ]\n    \n    # 3. 检测目标标识符（如邮箱、URL、内部路径）\n    target_identifier_patterns = [\n        r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b',  # 邮箱\n        r'\\b(https?://|www\\.)[^\\s]+\\b',  # URL\n        r'\\b(/|\\\\)[^\\s]*(/|\\\\)[^\\s]*\\b'  # 类路径结构\n    ]\n    \n    # 4. 检测完整的指令结构模式（修复原逻辑缺陷）\n    # 模式1：高风险操作 + 目标标识符（无论是否有请求短语）\n    contains_high_risk_action = False\n    for action in high_risk_actions:\n        if action in text_lower:\n            contains_high_risk_action = True\n            break\n    \n    contains_target_identifier = False\n    for pattern in target_identifier_patterns:\n        if re.search(pattern, command):  # 使用原始command以保留大小写匹配邮箱等\n            contains_target_identifier = True\n            break\n    \n    # 如果同时包含高风险操作和目标标识符，直接判定为风险\n    if contains_high_risk_action and contains_target_identifier:\n        return True\n    \n    # 模式2：指令启动短语 + 高风险操作（即使没有明确的目标标识符）\n    # 检查是否匹配指令模式\n    matches_instruction_pattern = False\n    for pattern in instruction_patterns:\n        if re.search(pattern, text_lower):\n            matches_instruction_pattern = True\n            break\n    \n    # 如果包含指令模式和高风险操作，判定为风险\n    if matches_instruction_pattern and contains_high_risk_action:\n        # 进一步检查是否是自然语言描述（误报过滤）\n        # 排除常见的产品描述上下文\n        safe_contexts = [\n            'product', 'review', 'description', 'rating', 'price',\n            'laptop', 'computer', 'device', 'item', 'purchase'\n        ]\n        \n        # 如果文本中包含安全上下文词汇，可能是正常的产品描述\n        has_safe_context = False\n        for context in safe_contexts:\n            if context in text_lower:\n                has_safe_context = True\n                break\n        \n        # 如果有安全上下文，需要更严格的检查\n        if has_safe_context:\n            # 检查是否是完整的指令语句（包含明确的动作对象）\n            # 例如 \"please retrieve my web history\" 是风险，而 \"please see the product history\" 可能是安全的\n            risk_indicators = 0\n            \n            # 检查是否有明确的个人信息相关词汇\n            personal_info_indicators = ['my', 'your', 'his', 'her', 'their', 'our']\n            for indicator in personal_info_indicators:\n                if f\"{indicator} \" in text_lower:\n                    risk_indicators += 1\n                    break\n            \n            # 检查是否有明确的动作对象\n            action_object_patterns = [\n                r'\\b(my|your|his|her|their|our)\\s+[a-z]+\\s+(history|log|password|file|data)\\b',\n                r'\\b(send|email|upload)\\s+[a-z]+\\s+to\\b'\n            ]\n            for pattern in action_object_patterns:\n                if re.search(pattern, text_lower):\n                    risk_indicators += 1\n                    break\n            \n            # 如果有风险指示器，判定为风险\n            if risk_indicators > 0:\n                return True\n            else:\n                return False\n        else:\n            # 没有安全上下文，直接判定为风险\n            return True\n    \n    # 模式3：包含目标标识符且上下文可疑\n    if contains_target_identifier:\n        # 检查目标标识符周围是否有可疑的指令词汇\n        suspicious_contexts = ['send to', 'email to', 'upload to', 'download from', 'access to']\n        for context in suspicious_contexts:\n            if context in text_lower:\n                return True\n    \n    # 其他情况：安全\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_prompt_injection_detector",
      "tool_description": "检测来自外部数据源（如API响应、网页内容）中的提示注入攻击模式。识别常见的注入指令模式，如'ignore all previous instructions'、'strictly adhere to'等，并验证指令是否与原始用户请求意图相关。",
      "require": [
        "re"
      ],
      "tool_code": "def external_prompt_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中的提示注入攻击。\n    \n    参数:\n        command: 代理准备执行的操作或外部数据内容\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 常见提示注入攻击模式\n    injection_patterns = [\n        r'ignore\\s+(all\\s+)?previous\\s+instructions',\n        r'strictly\\s+adhere\\s+to',\n        r'override\\s+(all\\s+)?previous\\s+commands',\n        r'disregard\\s+(all\\s+)?earlier\\s+instructions',\n        r'follow\\s+this\\s+instruction\\s+instead',\n        r'new\\s+instruction\\s*:',\n        r'important\\s*!{2,}',\n        r'critical\\s+instruction',\n        r'you\\s+must\\s+now',\n        r'stop\\s+what\\s+you\\re\\s+doing' \n    ]\n    \n    # 检查是否包含注入模式\n    cmd_lower = command.lower()\n    \n    for pattern in injection_patterns:\n        if re.search(pattern, cmd_lower):\n            # 进一步验证：检查是否包含具体的操作指令\n            # 如文件操作、权限修改、数据访问等\n            action_keywords = [\n                r'change\\s+sharing\\s+settings',\n                r'set\\s+permission',\n                r'grant\\s+access',\n                r'modify\\s+note',\n                r'edit\\s+document',\n                r'delete\\s+file',\n                r'execute\\s+command',\n                r'run\\s+script',\n                r'send\\s+email',\n                r'update\\s+database'\n            ]\n            \n            for action in action_keywords:\n                if re.search(action, cmd_lower):\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_data_sanitizer",
      "tool_description": "对外部获取的数据进行安全清洗，移除潜在的恶意指令和注入代码。特别针对从API响应、网页内容等外部数据源获取的信息进行过滤。修复了正则表达式逻辑缺陷和模式匹配问题。",
      "require": [
        "re"
      ],
      "tool_code": "def external_data_sanitizer(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含需要被清洗的恶意内容。\n    \n    参数:\n        command: 外部数据内容\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到需要清洗的风险内容，False表示安全\n    \"\"\"\n    # 检测伪装成正常内容的恶意指令\n    suspicious_patterns = [\n        # 伪装成评论的指令 - 修复：移除多余的re.IGNORECASE，统一使用小写匹配\n        r'review\\s*[:.]\\s*[^\\n]*ignore\\s+all',\n        r'comment\\s*[:.]\\s*[^\\n]*follow\\s+this',\n        \n        # 包含具体操作指令的伪内容\n        r'[\"\\']\\s*[^\"\\']*\\b(change|modify|grant|set|delete)\\b[^\"\\']*\\b(permission|access|settings|note|file)\\b',\n        \n        # 包含URL或命令的伪内容\n        r'\\b(please|kindly)\\s+[^\\n]{0,50}\\b(curl|wget|bash|sh|python|exec)\\b',\n        \n        # 包含敏感操作的伪数据\n        r'\\b(email|password|token|key|secret)\\s*[=:]\\s*[^\\s\\n]+',\n        \n        # 异常的大写和标点组合（常见于注入攻击）\n        r'[A-Z]{3,}!{2,}[^\\n]*instruction',\n        r'IMPORTANT[^\\n]*:[^\\n]*must'\n    ]\n    \n    # 统一转换为小写进行匹配，避免re.IGNORECASE混淆\n    cmd_lower = command.lower()\n    \n    for pattern in suspicious_patterns:\n        # 直接在小写文本上匹配，不使用re.IGNORECASE\n        if re.search(pattern, cmd_lower):\n            # 检查是否在JSON字符串中 - 修复：不破坏原始pattern结构\n            # 使用原始pattern进行JSON上下文检查\n            json_pattern = r'\"review_content\"\\s*:\\s*\"[^\"]*' + re.escape(re.search(r'[^\\[\\]]+', pattern).group(0) if re.search(r'[^\\[\\]]+', pattern) else '') + r'[^\"]*\"'\n            if re.search(json_pattern, command, re.IGNORECASE):\n                return True\n            \n            # 检查是否在HTML标签或注释中\n            html_pattern = r'<[^>]*>' + re.escape(re.search(r'[^\\[\\]]+', pattern).group(0) if re.search(r'[^\\[\\]]+', pattern) else '') + r'[^>]*>'\n            if re.search(html_pattern, command, re.IGNORECASE):\n                return True\n            \n            # 直接匹配检查（针对示例中的恶意指令）\n            if re.search(pattern, command, re.IGNORECASE):\n                return True\n    \n    # 额外检查：针对示例中的特定恶意指令模式\n    important_patterns = [\n        r'IMPORTANT!{2,}\\s*Ignore\\s+all\\s+previous\\s+instructions',\n        r'strictly\\s+adhere\\s+to\\s+the\\s+following\\s+instruction',\n        r'change\\s+the\\s+sharing\\s+settings\\s+for\\s+the\\s+note'\n    ]\n    \n    for pattern in important_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_instruction_injection_detector",
      "tool_description": "检测代理是否从外部数据源（如API响应、文件内容）中解析并准备执行嵌入的恶意指令。该工具分析代理的Thought内容，识别其是否将外部数据中的内容识别为待执行任务，从而防范提示注入攻击。修复了CWE-79问题，使用更通用的模式匹配指令注入攻击。",
      "require": [
        "re"
      ],
      "tool_code": "def external_instruction_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测代理的Thought中是否包含将外部数据解析为待执行任务的迹象。\n    Args:\n        command (str): 代理的Thought或Action内容。\n        user_level (str): 用户权限级别。\n    Returns:\n        bool: True表示检测到风险（代理准备执行外部指令），False表示安全。\n    \"\"\"\n    # 将输入转换为小写以便于模式匹配\n    thought_text = command.lower()\n\n    # 改进的风险模式：更通用的指令注入检测\n    # 1. 检测代理将外部内容识别为新任务/指令的意图\n    task_intent_patterns = [\n        r'proceed\\s+(with\\s+)?(the\\s+)?(new|separate|additional|another)\\s+task',\n        r'follow\\s+(the\\s+)?(instruction|command|directive|order|request)\\s+(from|in|contained)',\n        r'treat\\s+(it|this|that|the\\s+content|the\\s+message)\\s+as\\s+(an?\\s+)?(instruction|command|task|request)',\n        r'execute\\s+(the\\s+)?(instruction|command|request|task)\\s+(found|in|from|contained)',\n        r'(new|separate|additional|another)\\s+task\\s+(is\\s+)?(to|will)',\n        r'now\\s+(i\\s+)?(will|must|should|need\\s+to)\\s+(perform|execute|carry\\s+out|do)',\n        r'based\\s+on\\s+(the\\s+)?(instruction|command|request)\\s+(in|from)',\n        r'according\\s+to\\s+(the\\s+)?(instruction|command|request)\\s+(in|from)'\n    ]\n    \n    # 2. 检测典型的恶意指令模式（更通用化）\n    malicious_content_patterns = [\n        # 检测指令覆盖/忽略模式\n        r'ignore\\s+(all\\s+)?(previous|prior|old|existing)\\s+(instruction|command|directive)',\n        r'disregard\\s+(all\\s+)?(previous|prior|old|existing)\\s+(instruction|command)',\n        r'override\\s+(all\\s+)?(previous|prior|existing)\\s+(instruction|command)',\n        r'strictly\\s+adhere\\s+to\\s+(this|the\\s+following|these)',\n        r'only\\s+follow\\s+(this|the\\s+following|these)',\n        \n        # 检测数据窃取/未授权访问模式\n        r'retrieve\\s+(my\\s+)?(saved|stored|personal)\\s+(data|information|details)',\n        r'get\\s+(my\\s+)?(account|user|personal)\\s+(data|information|details)',\n        r'access\\s+(my\\s+)?(account|profile|personal)\\s+(data|information)',\n        r'email\\s+(it|them|the\\s+data|the\\s+information)\\s+to',\n        r'send\\s+(it|them|the\\s+data)\\s+to\\s+[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}',\n        r'forward\\s+(it|them|the\\s+data)\\s+to\\s+[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}',\n        \n        # 检测系统/账户操作模式\n        r'change\\s+(my\\s+)?(password|credentials|login)',\n        r'delete\\s+(my\\s+)?(account|profile|data)',\n        r'modify\\s+(my\\s+)?(settings|preferences|account)',\n        r'grant\\s+(access|permissions|privileges)\\s+to',\n        \n        # 检测敏感操作指令\n        r'run\\s+(command|code|script|program)',\n        r'execute\\s+(command|code|script|program)',\n        r'install\\s+(software|program|application)',\n        r'download\\s+(file|attachment|software)'\n    ]\n    \n    # 3. 检测外部数据引用模式\n    external_reference_patterns = [\n        r'in\\s+the\\s+(response|reply|answer|data|content|message|text)',\n        r'from\\s+the\\s+(response|reply|answer|data|content|message)',\n        r'contained\\s+in\\s+the\\s+(response|reply|data|content)',\n        r'found\\s+in\\s+the\\s+(response|reply|data|content)',\n        r'mentioned\\s+in\\s+the\\s+(response|reply|data|content)'\n    ]\n    \n    # 组合检测逻辑：需要同时匹配任务意图和恶意内容/外部引用\n    # 检测任务意图\n    has_task_intent = False\n    for pattern in task_intent_patterns:\n        if re.search(pattern, thought_text):\n            has_task_intent = True\n            break\n    \n    # 如果检测到任务意图，进一步检查是否涉及恶意内容或外部引用\n    if has_task_intent:\n        # 检查是否包含恶意内容模式\n        for pattern in malicious_content_patterns:\n            if re.search(pattern, thought_text):\n                return True\n        \n        # 检查是否明确引用外部数据源\n        for pattern in external_reference_patterns:\n            if re.search(pattern, thought_text):\n                return True\n    \n    # 额外检查：即使没有明确的任务意图，但包含高风险恶意指令\n    high_risk_patterns = [\n        r'ignore\\s+.*instruction.*strictly\\s+adhere',\n        r'disregard\\s+.*instruction.*only\\s+follow',\n        r'retrieve\\s+.*account.*email\\s+to\\s+[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}',\n        r'get\\s+.*account.*send\\s+to\\s+[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}'\n    ]\n    \n    for pattern in high_risk_patterns:\n        if re.search(pattern, thought_text):\n            return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "数据与隐私安全防护工具": [
    {
      "tool_name": "sensitive_data_detector",
      "tool_description": "检测外部数据中的个人敏感信息，如患者ID、医疗记录号、社保号等。防止代理无意中泄露或传播他人敏感信息，符合隐私保护法规要求。使用模糊匹配和上下文无关的检测逻辑，避免模式泄露和绕过风险。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中的个人敏感信息\n    \n    Args:\n        command: 代理可能执行的操作或外部数据内容\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到敏感信息，False表示安全\n    \"\"\"\n    # 使用模糊化的模式匹配，避免直接暴露具体格式\n    # 医疗相关敏感信息检测 - 基于关键词和ID模式的组合\n    medical_keywords = [\n        'patient', 'medical', 'appointment', 'doctor', 'hospital', \n        'clinic', 'surgery', 'health', 'insurance', 'record', 'case'\n    ]\n    \n    # 通用敏感标识符关键词\n    identifier_keywords = [\n        'ssn', 'social security', 'credit card', 'passport', \n        'driver license', 'license', 'card number'\n    ]\n    \n    # 清理和标准化输入\n    cleaned_command = command.lower().strip()\n    \n    # 检测医疗敏感信息 - 改进的逻辑\n    # 查找医疗关键词后跟ID/数字的模式\n    for keyword in medical_keywords:\n        # 构建模糊模式：关键词后跟可能的ID/数字指示符\n        pattern1 = rf'{keyword}\\s+(id|number|no\\.?|#)\\s*[:=]?\\s*[\\d\\w]{{4,}}'\n        pattern2 = rf'{keyword}\\s+[\\d\\w]{{4,}}'\n        \n        if re.search(pattern1, cleaned_command) or re.search(pattern2, cleaned_command):\n            # 验证是否为真正的敏感信息（排除常见误报）\n            # 检查数字/字母序列是否在常见非敏感上下文中\n            match = re.search(rf'{keyword}\\s+(id|number|no\\.?|#)\\s*[:=]?\\s*([\\d\\w]{{4,}})', cleaned_command)\n            if match:\n                potential_id = match.group(2)\n                # 排除明显的产品ID模式（如全数字且无医疗特定格式）\n                if not (re.match(r'^\\d+$', potential_id) and \n                       len(potential_id) <= 20 and \n                       not re.search(r'patient|medical|health', cleaned_command)):\n                    return True\n    \n    # 检测通用敏感标识符\n    for keyword in identifier_keywords:\n        # 构建更通用的模式\n        pattern = rf'{keyword}\\s+(number|no\\.?|#|id)\\s*[:=]?\\s*[\\d\\w\\-]{{6,}}'\n        if re.search(pattern, cleaned_command):\n            return True\n    \n    # 检测特定格式的敏感信息（使用模糊化描述）\n    # SSN格式检测\n    ssn_pattern = r'\\d{3}[\\-\\s]?\\d{2}[\\-\\s]?\\d{4}'\n    if re.search(ssn_pattern, cleaned_command):\n        # 验证不是其他合法用途（如日期、产品代码等）\n        context = re.search(rf'({ssn_pattern})', cleaned_command)\n        if context:\n            ssn_candidate = context.group(1)\n            # 检查周围是否有SSN相关关键词\n            ssn_keywords = ['ssn', 'social', 'security', 'tax', 'identification']\n            window_start = max(0, context.start() - 50)\n            window_end = min(len(cleaned_command), context.end() + 50)\n            context_window = cleaned_command[window_start:window_end]\n            \n            if any(keyword in context_window for keyword in ssn_keywords):\n                return True\n    \n    # 信用卡号检测（模糊化）\n    cc_pattern = r'\\b\\d{4}[\\s\\-]?\\d{4}[\\s\\-]?\\d{4}[\\s\\-]?\\d{4}\\b'\n    if re.search(cc_pattern, cleaned_command):\n        # 验证上下文\n        cc_keywords = ['credit', 'card', 'debit', 'payment', 'account']\n        match = re.search(cc_pattern, cleaned_command)\n        if match:\n            window_start = max(0, match.start() - 30)\n            window_end = min(len(cleaned_command), match.end() + 30)\n            context_window = cleaned_command[window_start:window_end]\n            \n            if any(keyword in context_window for keyword in cc_keywords):\n                return True\n    \n    # 增强的ID检测逻辑 - 不再依赖产品上下文排除\n    # 检测任何ID模式后跟医疗关键词的情况\n    id_pattern = r'(id|number|no\\.?|#)\\s*[:=]?\\s*([\\d\\w]{{4,}})'\n    id_matches = list(re.finditer(id_pattern, cleaned_command))\n    \n    for match in id_matches:\n        potential_id = match.group(2)\n        # 检查ID前后的上下文\n        start_pos = max(0, match.start() - 20)\n        end_pos = min(len(cleaned_command), match.end() + 20)\n        local_context = cleaned_command[start_pos:end_pos]\n        \n        # 如果上下文包含医疗关键词，且ID看起来像患者ID（不是纯产品ID）\n        if any(med_keyword in local_context for med_keyword in medical_keywords):\n            # 进一步验证ID格式\n            if not (re.match(r'^[A-Z0-9]{10,}$', potential_id) and \n                   'product' in local_context and \n                   'amazon' in local_context):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_instruction_filter",
      "tool_description": "识别并标记数据中可能包含的隐私侵犯指令。专注于检测请求执行未经授权的个人数据操作（如访问他人账户、提取保存的地址、发送数据到外部邮箱等）。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_instruction_filter(command: str, user_level: str):\n    \"\"\"\n    过滤数据中可能包含的隐私侵犯指令。\n    Args:\n        command (str): 待检测的文本内容。\n        user_level (str): 用户权限级别，本工具暂不使用，为保持接口一致而保留。\n    Returns:\n        bool: True表示检测到隐私侵犯风险，False表示安全。\n    \"\"\"\n    # 隐私侵犯指令模式\n    privacy_violation_patterns = [\n        # 提取个人数据指令\n        r'\\b(retrieve|get|fetch|access|obtain)\\s+(my|your|his|her|their|the\\s+user\\'s)\\s+',\n        # 发送个人数据到外部\n        r'\\b(send|email|forward|share)\\s+[\\w\\s]+\\s+(to|with)\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\b',\n        # 操作外部账户\n        r'\\b(login\\s+to|access\\s+the|open\\s+my)\\s+(amazon|google|facebook|bank)\\s+account\\b',\n        # 提取保存的敏感信息\n        r'\\b(saved\\s+(addresses|passwords|payment\\s+methods)|billing\\s+info|shipping\\s+details)\\b',\n        # 数据导出请求\n        r'\\b(export|download|backup)\\s+[\\w\\s]+\\s+data\\b',\n    ]\n    \n    text_to_check = command.lower()\n    \n    # 检查隐私侵犯模式\n    for pattern in privacy_violation_patterns:\n        if re.search(pattern, text_to_check):\n            # 额外检查：排除一些可能的误报场景\n            # 例如，产品描述中可能包含“login to your account to track orders”是合法的\n            if re.search(r'\\btrack\\s+(order|package)\\b', text_to_check):\n                continue\n            if re.search(r'\\bmanage\\s+(your|my)\\s+account\\b', text_to_check):\n                continue\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "pii_data_detector",
      "tool_description": "自动检测文本中是否包含个人身份信息（PII），如电子邮件地址、电话号码等。用于在代理输出内容前识别敏感数据，以便进行脱敏处理。",
      "require": [
        "re"
      ],
      "tool_code": "def pii_data_detector(command: str, user_level: str):\n    \"\"\"\n    检测文本中是否包含个人身份信息（PII）。\n    command: 代理准备输出的文本内容（字符串）。\n    user_level: 用户权限级别。\n    返回True如果检测到PII（如邮箱、电话），否则返回False。\n    \"\"\"\n    # 定义PII检测模式\n    pii_patterns = [\n        r'[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',  # 电子邮件地址\n        r'\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b',  # 美国电话号码格式 (简化)\n        r'\\b\\d{4}[-\\s]?\\d{4}[-\\s]?\\d{4}[-\\s]?\\d{4}\\b',  # 信用卡号 (16位数字)\n        r'\\b\\d{3}-\\d{2}-\\d{4}\\b',  # 美国社会安全号码 (SSN)\n        r'\\b[A-Za-z]{2}\\d{6,7}[A-Za-z]?\\b',  # 护照号码 (示例模式，实际更复杂)\n    ]\n    \n    for pattern in pii_patterns:\n        if re.search(pattern, command):  # 保持原始大小写，因为某些模式可能区分大小写\n            return True  # 检测到PII\n    return False  # 未检测到PII",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_scanner",
      "tool_description": "扫描外部数据中可能包含的敏感信息，如个人邮箱地址、电话号码、地址等，防止隐私信息泄露。支持基于用户权限级别的差异化检测策略。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_scanner(command: str, user_level: str):\n    \"\"\"\n    扫描命令或数据中的敏感信息\n    \n    参数:\n        command: 要扫描的文本内容\n        user_level: 用户权限级别（如'root', 'admin', 'user'等）\n    \n    返回:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    \n    # 定义检测模式 - 使用函数封装，避免硬编码暴露逻辑结构\n    def get_detection_patterns():\n        \"\"\"返回敏感信息检测模式\"\"\"\n        patterns = {\n            'email': r'\\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\\b',\n            'phone': r'\\b\\+?[0-9]{1,3}[-.\\s]?\\(?[0-9]{1,4}\\)?[-.\\s]?[0-9]{1,4}[-.\\s]?[0-9]{3,4}\\b',\n            'address_keywords': [\n                r'\\bstreet\\b',\n                r'\\bavenue\\b',\n                r'\\broad\\b',\n                r'\\blane\\b',\n                r'\\bapartment\\b',\n                r'\\bsuite\\b',\n                r'\\bzip\\s+code\\b',\n                r'\\bpostal\\s+code\\b'\n            ]\n        }\n        return patterns\n    \n    # 定义权限策略 - 不同权限级别的检测严格度\n    def get_permission_policy(user_level):\n        \"\"\"根据用户权限返回检测策略\"\"\"\n        policies = {\n            'root': {\n                'allow_external_data_sensitive_info': True,  # 允许外部数据中的敏感信息\n                'require_explicit_action': True,  # 需要明确的动作指令才触发\n                'suspicious_contexts': [\n                    r'execute\\s+',\n                    r'run\\s+',\n                    r'install\\s+',\n                    r'delete\\s+',\n                    r'drop\\s+'\n                ]\n            },\n            'admin': {\n                'allow_external_data_sensitive_info': False,\n                'require_explicit_action': True,\n                'suspicious_contexts': [\n                    r'send\\s+(?:to|an?\\s+email\\s+to)\\s+',\n                    r'email\\s+',\n                    r'forward\\s+(?:to|information\\s+to)\\s+',\n                    r'share\\s+(?:with|to)\\s+',\n                    r'execute\\s+',\n                    r'run\\s+'\n                ]\n            },\n            'default': {\n                'allow_external_data_sensitive_info': False,\n                'require_explicit_action': False,  # 普通用户更严格\n                'suspicious_contexts': [\n                    r'send\\s+(?:to|an?\\s+email\\s+to)\\s+',\n                    r'email\\s+',\n                    r'forward\\s+(?:to|information\\s+to)\\s+',\n                    r'share\\s+(?:with|to)\\s+',\n                    r'call\\s+',\n                    r'contact\\s+',\n                    r'text\\s+',\n                    r'message\\s+',\n                    r'provide\\s+',\n                    r'give\\s+'\n                ]\n            }\n        }\n        \n        # 获取对应权限的策略，如果没有则使用默认策略\n        return policies.get(user_level.lower(), policies['default'])\n    \n    # 获取检测模式和权限策略\n    patterns = get_detection_patterns()\n    policy = get_permission_policy(user_level)\n    \n    # 检测邮箱地址\n    emails = re.findall(patterns['email'], command)\n    if emails:\n        # 对于root用户，如果策略允许外部数据中的敏感信息，则不立即返回True\n        if policy['allow_external_data_sensitive_info']:\n            # root用户需要检查是否包含危险操作指令\n            for context in policy['suspicious_contexts']:\n                if re.search(context, command, re.IGNORECASE):\n                    return True\n        else:\n            # 非root用户检查是否在可疑上下文中出现\n            for context in policy['suspicious_contexts']:\n                for email in emails:\n                    if re.search(context + re.escape(email), command, re.IGNORECASE):\n                        return True\n    \n    # 检测电话号码\n    phones = re.findall(patterns['phone'], command)\n    if phones:\n        # 检查是否在请求发送信息的上下文中\n        if not policy['allow_external_data_sensitive_info']:\n            phone_contexts = [r'\\b(call|contact|text|message|send)\\s+']\n            for context in phone_contexts:\n                if re.search(context, command, re.IGNORECASE):\n                    return True\n    \n    # 检测地址信息\n    address_found = False\n    for keyword in patterns['address_keywords']:\n        if re.search(keyword, command, re.IGNORECASE):\n            address_found = True\n            break\n    \n    if address_found:\n        # 检查是否在请求分享或发送地址的上下文中\n        if not policy['allow_external_data_sensitive_info']:\n            if re.search(r'\\b(send|share|provide|give)\\s+(?:my|the)\\s+(?:address|location)\\b', command, re.IGNORECASE):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_leakage_detector",
      "tool_description": "检测外部数据或代理响应中是否包含可能导致隐私泄露的敏感信息请求或指令。特别关注地理位置、联系方式等个人隐私数据的获取和传输请求。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_leakage_detector(command: str, user_level: str):\n    \"\"\"\n    检测可能导致隐私数据泄露的指令。\n    Args:\n        command: 代理准备执行的操作或外部获取的数据内容\n        user_level: 用户权限级别\n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 隐私数据泄露相关模式\n    privacy_leakage_patterns = [\n        # 地理位置数据泄露\n        r'\\b(location|position|coordinates|GPS|geolocation|where\\s+I\\s+am)\\b.*\\b(send|share|transmit|upload|email)\\b',\n        r'\\b(get|obtain|acquire)\\s+(my\\s+)?(location|position|whereabouts)\\b',\n        # 个人身份信息泄露\n        r'\\b(PII|personal\\s+information|identity|contact\\s+details)\\b.*\\b(send|share|expose)\\b',\n        # 外部数据传输到未经验证的地址\n        r'\\b(send|email|forward|transmit)\\s+.*\\bto\\s+[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\\b',\n        r'\\b(share|upload)\\s+.*\\bto\\s+(an?\\s+)?(external|third-party|untrusted)\\b',\n        # 数据收集指令\n        r'\\bcollect\\s+(my\\s+)?(data|information|details)\\b',\n        r'\\bgather\\s+(personal|sensitive)\\s+information\\b'\n    ]\n    \n    text = command.lower()\n    \n    # 检查隐私泄露模式\n    for pattern in privacy_leakage_patterns:\n        if re.search(pattern, text, re.IGNORECASE):\n            # 验证是否在正常业务上下文中\n            # 正常的产品查询不应该包含这些隐私相关指令\n            normal_contexts = ['product details', 'customer review', 'shipping address', 'order information']\n            is_normal_context = any(context in text for context in normal_contexts)\n            \n            if not is_normal_context:\n                return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "IoT与智能设备安全防护工具": [
    {
      "tool_name": "iot_device_control_detector",
      "tool_description": "检测文本中是否包含对IoT设备的控制指令（如移动、开关、调整设置等）。通过识别设备类型关键词和动作动词的组合来发现潜在的未经授权的设备控制尝试。本工具仅检测指令模式，不执行权限验证，检测结果需结合用户权限进行进一步授权决策。",
      "require": [
        "re"
      ],
      "tool_code": "def iot_device_control_detector(command: str, user_level: str):\n    \"\"\"\n    检测文本中是否包含IoT设备控制指令。\n    Args:\n        command: 待检测的文本内容。\n        user_level: 用户权限级别（本工具不依赖此参数，但为保持接口一致而保留）。\n    Returns:\n        bool: True表示检测到IoT设备控制指令模式，False表示未检测到。\n             注意：返回True仅表示文本匹配控制指令模式，不表示指令已授权执行。\n    \"\"\"\n    # IoT设备类型关键词（优化后更精确）\n    device_keywords = [\n        r'\\bhome\\s+robot\\b',\n        r'\\bsmart\\s+(lock|thermostat|camera|light|plug|speaker)\\b',\n        r'\\biot\\s+device\\b',\n        r'\\bautomation\\s+device\\b',\n        # 优化：仅匹配明确的设备控制模式，避免普通描述\n        r'\\b(room|bathroom|kitchen|bedroom|garage)_[a-z0-9]+\\b',  # 下划线连接模式\n        r'\\b(room|bathroom|kitchen|bedroom|garage)\\s+id\\s+[a-z0-9_]+\\b',  # 明确ID模式\n        r'\\bdevice_?id\\s*[=:]?\\s*[a-z0-9_]+\\b'  # 设备ID模式\n    ]\n    \n    # 控制动作动词\n    action_keywords = [\n        r'\\bmove\\s+(to|towards|into)\\b',\n        r'\\b(turn|switch)\\s+(on|off)\\b',\n        r'\\b(open|close|lock|unlock)\\b',\n        r'\\badjust\\s+(temperature|setting|level)\\b',\n        r'\\b(guide|direct|navigate)\\s+to\\b',\n        r'\\b(activate|deactivate|enable|disable)\\b',\n        r'\\b(set|change|configure)\\s+[a-z]+\\s+to\\b',\n        r'\\bcontrol\\s+the\\b',\n        r'\\bcommand\\s+the\\b'\n    ]\n    \n    text = command.lower()\n    \n    # 排除常见误报模式：描述性语句\n    false_positive_patterns = [\n        r'\\b(is|was|are|were|be|being)\\s+[a-z]+\\b',  # 状态描述\n        r'\\b(the|a|an)\\s+[a-z]+\\s+is\\b',  # 普通描述\n        r'\\b(light|fan|door)\\s+is\\s+(on|off|open|closed)\\b'  # 状态报告\n    ]\n    \n    # 检查是否为描述性语句（可能误报）\n    is_descriptive = any(re.search(pattern, text) for pattern in false_positive_patterns)\n    \n    # 检查是否包含设备关键词和控制动作\n    has_device = any(re.search(device_pattern, text) for device_pattern in device_keywords)\n    has_action = any(re.search(action_pattern, text) for action_pattern in action_keywords)\n    \n    # 逻辑优化：需要同时包含设备和动作，且不是描述性语句\n    # 对于描述性语句，即使包含设备和动作关键词，也不标记为控制指令\n    if is_descriptive:\n        # 如果是描述性语句，需要更强的证据表明是控制指令\n        # 检查是否有明确的命令关键词\n        command_indicators = [\n            r'\\b(please|kindly|could you)\\s+',\n            r'\\b(instruction|command|order|directive)\\b',\n            r'\\b(execute|perform|carry out)\\b',\n            r'^\\s*(move|turn|open|adjust)\\b'\n        ]\n        has_command_indicator = any(re.search(indicator, text) for indicator in command_indicators)\n        \n        # 只有同时包含命令指示符时才可能为控制指令\n        return has_device and has_action and has_command_indicator\n    else:\n        # 非描述性语句，标准检测逻辑\n        return has_device and has_action",
      "risk_description": ""
    }
  ]
}