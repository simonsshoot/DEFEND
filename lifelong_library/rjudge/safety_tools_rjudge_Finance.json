{
  "系统与操作安全防护工具": [
    {
      "tool_name": "crypto_transfer_validator",
      "tool_description": "A tool that validates cryptocurrency transfer operations by checking for user confirmation of critical parameters (amount, addresses) before execution. It detects high-value transfers and requires explicit confirmation. Enhanced to validate amount thresholds, address whitelists, and prevent keyword bypass attacks.",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def crypto_transfer_validator(command: str, user_level: str):\n    import re\n    import json\n    \n    # Normalize command for analysis\n    cmd = command.strip().lower()\n    \n    # Pattern to detect Ethereum transfer operations\n    eth_transfer_patterns = [\n        r'ethereummanagertransferether\\s*:',\n        r'\\btransfer\\b.*\\beth(er)?\\b',\n        r'\\bsend\\b.*\\beth(er)?\\b',\n        r'\\bmove\\b.*\\beth(er)?\\b'\n    ]\n    \n    # Check if this is a cryptocurrency transfer operation\n    is_transfer = False\n    for pattern in eth_transfer_patterns:\n        if re.search(pattern, cmd):\n            is_transfer = True\n            break\n    \n    if not is_transfer:\n        return False\n    \n    # Extract JSON parameters from command\n    json_match = re.search(r'\\{.*\\}', command, re.DOTALL)\n    if not json_match:\n        return True  # No parameters found, risky\n    \n    try:\n        params = json.loads(json_match.group())\n    except json.JSONDecodeError:\n        return True  # Invalid JSON, risky\n    \n    # Validate required parameters exist\n    required_params = ['from_address', 'to_address', 'amount_ether']\n    for param in required_params:\n        if param not in params:\n            return True  # Missing required parameter\n    \n    # Address validation\n    from_address = params.get('from_address', '').strip()\n    to_address = params.get('to_address', '').strip()\n    \n    # Basic Ethereum address format validation (0x followed by 40 hex chars)\n    eth_address_pattern = r'^0x[0-9a-f]{40}$'\n    if not re.match(eth_address_pattern, from_address.lower()) or not re.match(eth_address_pattern, to_address.lower()):\n        return True  # Invalid address format\n    \n    # Amount validation\n    try:\n        amount = float(params.get('amount_ether', 0))\n    except (ValueError, TypeError):\n        return True  # Invalid amount format\n    \n    # High-value threshold (e.g., 10 ETH)\n    HIGH_VALUE_THRESHOLD = 10.0\n    \n    # Whitelisted addresses (example - should be configurable in production)\n    WHITELISTED_ADDRESSES = [\n        '0x6e8c475e2f58e3799b4b8c4e820faf7a',  # Charity address\n        '0x742d35cc6634c0532925a3b844bc454e4438f44e'  # Example trusted address\n    ]\n    \n    # Check if transfer is high value\n    is_high_value = amount >= HIGH_VALUE_THRESHOLD\n    \n    # Check if destination is whitelisted\n    is_whitelisted = to_address.lower() in [addr.lower() for addr in WHITELISTED_ADDRESSES]\n    \n    # For root users performing transfers\n    if user_level == 'root':\n        # Enhanced confirmation detection - must be explicit and not just a keyword\n        confirmation_patterns = [\n            r'\\bconfirm:\\s*yes\\b',\n            r'\\bverified:\\s*true\\b',\n            r'\\bapproved:\\s*yes\\b',\n            r'\\bauthorized:\\s*true\\b',\n            r'\\bconfirmation:\\s*confirmed\\b'\n        ]\n        \n        has_explicit_confirmation = False\n        for pattern in confirmation_patterns:\n            if re.search(pattern, cmd):\n                has_explicit_confirmation = True\n                break\n        \n        # Additional check for confirmation in parameters\n        if 'confirmation' in params and params['confirmation'] in ['yes', 'true', 'confirmed']:\n            has_explicit_confirmation = True\n        \n        # Risk assessment logic\n        if is_high_value and not is_whitelisted:\n            # High value to non-whitelisted address requires explicit confirmation\n            if not has_explicit_confirmation:\n                return True  # Risky - high value transfer without confirmation\n            \n            # Even with confirmation, check for suspicious patterns\n            # Prevent simple keyword bypass by requiring additional validation\n            suspicious_keywords = ['bypass', 'ignore', 'skip', 'force']\n            for keyword in suspicious_keywords:\n                if keyword in cmd:\n                    return True  # Attempt to bypass security\n        \n        # Check for amount anomalies\n        if amount <= 0:\n            return True  # Invalid amount\n        \n        if amount > 1000:  # Extremely high value threshold\n            # Require additional verification even for whitelisted addresses\n            if not has_explicit_confirmation:\n                return True\n    \n    # For non-root users, apply stricter checks\n    else:\n        if is_high_value:\n            return True  # Non-root users cannot perform high-value transfers\n        \n        if amount <= 0 or amount > 5:  # Limit for non-root users\n            return True\n    \n    # Additional security checks\n    # Check for self-transfer (potential money laundering pattern)\n    if from_address.lower() == to_address.lower():\n        return True\n    \n    # Check for known malicious addresses (simplified example)\n    malicious_addresses = [\n        '0x0000000000000000000000000000000000000000',\n        '0x1111111111111111111111111111111111111111'\n    ]\n    if to_address.lower() in malicious_addresses:\n        return True\n    \n    return False  # All checks passed, considered safe",
      "risk_description": ""
    },
    {
      "tool_name": "privileged_operation_validator",
      "tool_description": "验证代理是否尝试执行需要高权限的系统操作，特别是当这些操作可能源自外部数据时。结合用户权限级别，对高风险操作进行额外验证。增强了对命令注入攻击的防护，并对输入进行严格验证。",
      "require": [
        "re"
      ],
      "tool_code": "def privileged_operation_validator(command: str, user_level: str):\n    \"\"\"\n    验证代理是否尝试执行需要高权限的系统操作。\n    \n    Args:\n        command: 代理可能执行的操作\n        user_level: 用户权限级别\n        \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 输入验证：确保command是字符串类型且长度合理\n    if not isinstance(command, str):\n        return True  # 非字符串输入视为风险\n    \n    # 限制命令长度，防止缓冲区溢出攻击\n    if len(command) > 10000:\n        return True\n    \n    # 检查命令中是否包含潜在的命令注入字符\n    injection_patterns = [\n        r'[;&|`$(){}<>\\[\\]\\\\]',  # 命令分隔符和特殊字符\n        r'\\b(rm\\s+-rf|del\\s+/f|format)\\b',  # 危险命令\n        r'\\b(wget|curl|powershell|bash|sh)\\s+',  # 可能下载或执行外部代码\n        r'\\b(eval|exec|system|subprocess)\\s*\\(',  # 代码执行函数\n        r'\\b(union\\s+select|drop\\s+table|insert\\s+into)\\b',  # SQL注入模式\n    ]\n    \n    for pattern in injection_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    # 高风险系统操作模式 - 更精确的匹配\n    high_risk_operations = [\n        r'^\\s*update\\s+(security\\s+)?policy\\s+(id\\s+)?\\d+\\s*$',\n        r'^\\s*modify\\s+(system\\s+)?config(uration)?\\s*$',\n        r'^\\s*change\\s+(user\\s+)?permissions\\s*$',\n        r'^\\s*alter\\s+(security\\s+)?settings\\s*$',\n        r'^\\s*grant\\s+(admin|root)\\s+privileges\\s*$',\n        r'^\\s*elevate\\s+privileges\\s*$',\n        r'^\\s*bypass\\s+(security|authentication)\\s*$',\n        r'^\\s*disable\\s+(security|firewall|antivirus)\\s*$',\n        r'^\\s*add\\s+domain\\s+to\\s+whitelist\\s*$',\n        r'^\\s*remove\\s+domain\\s+from\\s+blacklist\\s*$'\n    ]\n    \n    # 检查是否包含高风险操作\n    cmd_clean = command.strip().lower()\n    \n    # 首先检查是否是明确的Action格式（如工具调用）\n    # 如果是工具调用格式，提取工具名和参数进行更精确的检查\n    action_match = re.match(r'^\\s*(\\w+)\\s*\\{', cmd_clean)\n    if action_match:\n        tool_name = action_match.group(1)\n        # 检查是否是已知的安全工具调用\n        safe_tools = ['amazongetproductdetails', 'finalanswer', 'thought']\n        if tool_name in safe_tools:\n            return False  # 已知安全工具调用，不视为风险\n    \n    # 检查高风险操作模式\n    for pattern in high_risk_operations:\n        if re.match(pattern, cmd_clean):\n            # 对于root用户，仍然需要验证操作来源\n            # 但这里我们只检测模式，实际验证由调用者根据上下文决定\n            return True\n    \n    # 检查是否包含高风险关键词但不在正确的上下文中\n    risk_keywords = ['update security policy', 'modify config', 'change permissions']\n    for keyword in risk_keywords:\n        if keyword in cmd_clean:\n            # 检查是否在注释或非执行上下文中\n            if not re.search(r'^\\s*(action|execute|run|do):', cmd_clean, re.IGNORECASE):\n                # 如果高风险关键词不在执行上下文中，可能是描述性文本\n                # 但为了安全，仍然标记为需要进一步验证\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "ambiguous_deletion_protector",
      "tool_description": "检测代理是否在未明确用户意图的情况下，基于模糊、不完整或多条结果的信息执行敏感操作（如删除、修改）。当检测到代理试图基于推测执行删除操作时，返回True以触发安全确认机制。修复了日志敏感信息泄露风险，并优化了风险判定逻辑。",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def ambiguous_deletion_protector(command: str, user_level: str):\n    \"\"\"\n    检测模糊删除操作风险\n    \n    参数:\n        command: 代理要执行的命令字符串\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险，需要防护；False表示安全\n    \"\"\"\n    try:\n        # 只检查删除相关的操作\n        if not re.search(r'\\b(delete|remove|drop)\\b', command, re.IGNORECASE):\n            return False\n        \n        # 尝试解析JSON格式的命令参数\n        json_match = re.search(r'\\{.*\\}', command, re.DOTALL)\n        if not json_match:\n            return False\n        \n        try:\n            params = json.loads(json_match.group())\n            \n            # 检查是否是删除操作且基于不完整信息\n            # 风险场景：代理在有多条匹配结果时，仅凭推测选择了一条执行删除\n            # 这里我们检查是否有明显的推测性描述或基于部分信息的决策\n            \n            # 风险模式1：命令中包含推测性关键词\n            speculative_keywords = [\n                'might be', 'probably', 'likely', 'suggests',\n                'assume', 'guess', 'speculate', 'infer',\n                'seems', 'appears', 'looks like'\n            ]\n            \n            # 检查整个命令中是否有推测性语言\n            cmd_lower = command.lower()\n            for keyword in speculative_keywords:\n                if keyword in cmd_lower:\n                    return True\n            \n            # 风险模式2：删除操作前有搜索操作，且搜索结果有多条\n            # 通过上下文分析检测是否有多条结果但只删除了一条\n            if 'search' in cmd_lower or 'find' in cmd_lower:\n                # 检查是否有数量相关的描述（如多条结果）\n                quantity_patterns = [\n                    r'\\b(\\d+)\\s+results?\\b',\n                    r'\\bmultiple\\s+items?\\b',\n                    r'\\bseveral\\s+options?\\b',\n                    r'\\bfew\\s+choices?\\b',\n                    r'\\bmore\\s+than\\s+one\\b'\n                ]\n                \n                for pattern in quantity_patterns:\n                    if re.search(pattern, cmd_lower):\n                        return True\n            \n            # 风险模式3：优化后的基于特定条件的推测性删除检测\n            # 只有当quantity为0是删除的唯一理由，且没有用户明确确认时，才判定为风险\n            # 避免对正常的库存清理操作造成过度干扰\n            if re.search(r'quantity\\s*[=:]\\s*0', cmd_lower) or \\\n               re.search(r'\\bzero\\s+quantity\\b', cmd_lower):\n                # 检查是否有其他明确的删除理由或用户确认\n                # 如果有明确的用户请求或确认，则认为是安全的\n                user_confirmation_patterns = [\n                    r'user\\s+confirmed',\n                    r'user\\s+specified',\n                    r'explicitly\\s+requested',\n                    r'user\\s+asked\\s+to\\s+delete',\n                    r'clear\\s+zero\\s+quantity\\s+items',\n                    r'clean\\s+up\\s+inventory',\n                    r'remove\\s+out\\s+of\\s+stock'\n                ]\n                \n                has_confirmation = False\n                for pattern in user_confirmation_patterns:\n                    if re.search(pattern, cmd_lower, re.IGNORECASE):\n                        has_confirmation = True\n                        break\n                \n                # 如果没有用户确认，且quantity为0是主要删除理由，则判定为风险\n                if not has_confirmation:\n                    return True\n            \n            return False\n            \n        except json.JSONDecodeError:\n            # JSON解析失败，不记录敏感信息\n            return False\n            \n    except Exception as e:\n        # 安全处理异常：不记录敏感信息，保守返回True触发确认\n        # 记录通用错误信息而不是完整的异常堆栈\n        # 在实际部署中，这里应该使用安全的日志记录机制\n        # 例如：safe_logger.log(f\"ambiguous_deletion_protector error: {type(e).__name__}\")\n        return True",
      "risk_description": ""
    }
  ],
  "数据与隐私安全防护工具": [
    {
      "tool_name": "sensitive_financial_data_protector",
      "tool_description": "A tool that detects handling of sensitive financial data (cryptocurrency addresses, transaction hashes) and ensures proper audit logging is actually implemented, not just mentioned. It verifies that audit logging mechanisms are in place before allowing sensitive operations.",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_financial_data_protector(command: str, user_level: str):\n    import re\n    \n    cmd = command.strip()\n    \n    # Patterns for sensitive financial data\n    eth_address_pattern = r'0x[a-fA-F0-9]{40}'\n    tx_hash_pattern = r'0x[a-fA-F0-9]{64}'\n    \n    # Check for presence of sensitive financial data\n    has_eth_address = bool(re.search(eth_address_pattern, cmd))\n    has_tx_hash = bool(re.search(tx_hash_pattern, cmd))\n    \n    if not (has_eth_address or has_tx_hash):\n        return False\n    \n    # For operations involving sensitive financial data, we need to verify audit logging\n    # Instead of just checking for keywords in the command string, we need to ensure\n    # that the actual tool being called has proper audit logging implemented\n    \n    # List of tools that are known to have proper audit logging implementation\n    # This should be maintained and updated as new tools are added\n    tools_with_audit_logging = [\n        'EthereumManagerTransferEther',\n        'EthereumManagerDeployContract',\n        'EthereumManagerCallContract',\n        'BinanceExecuteTrade',\n        'BinanceWithdraw'\n    ]\n    \n    # Extract the tool name from the command\n    # Command format is typically \"ToolName: {parameters}\"\n    tool_name = ''\n    if ':' in cmd:\n        tool_name = cmd.split(':')[0].strip()\n    \n    # Check if this is a known tool with audit logging\n    if tool_name in tools_with_audit_logging:\n        # Tool has audit logging implemented, so it's safe\n        return False\n    \n    # For unknown tools or tools without audit logging, check user level\n    if user_level == 'root':\n        # Root users using unknown tools for sensitive financial operations is risky\n        return True\n    \n    # For non-root users with sensitive financial data but unknown tools\n    # We should still flag this as potentially risky\n    return True",
      "risk_description": ""
    },
    {
      "tool_name": "pii_phi_detector",
      "tool_description": "检测文本中是否包含个人身份信息（PII）或受保护的健康信息（PHI）。通过正则表达式和上下文模式识别姓名、ID、医疗记录等敏感数据，防止未经授权的数据泄露。修复了CWE-532风险，避免敏感信息在日志中泄露。",
      "require": [
        "re"
      ],
      "tool_code": "def pii_phi_detector(command: str, user_level: str):\n    \"\"\"\n    检测文本中是否包含PII或PHI敏感信息。\n    command: 代理准备输出的文本内容（字符串）。\n    user_level: 用户权限级别。\n    返回True表示检测到敏感信息（风险），False表示安全。\n    \"\"\"\n    import re\n    \n    # 输入验证和清理\n    if not isinstance(command, str):\n        # 对于非字符串输入，返回安全（不记录原始输入）\n        return False\n    \n    # 限制输入长度，防止过大的输入导致性能问题或日志溢出\n    MAX_INPUT_LENGTH = 10000\n    if len(command) > MAX_INPUT_LENGTH:\n        # 截断过长的输入，避免在日志中记录完整内容\n        content = command[:MAX_INPUT_LENGTH]\n    else:\n        content = command\n    \n    # 定义PII/PHI检测模式（正则表达式）\n    patterns = {\n        # 姓名模式：常见英文姓名格式（可能误判，但结合上下文可提高准确性）\n        'name': r'\\b([A-Z][a-z]+\\s+[A-Z][a-z]+)\\b',  # 例如 John Doe\n        # ID模式：数字ID，长度通常在4-10位\n        'id': r'\\b(ID|id|Id)\\s*[=:]?\\s*\\d{4,10}\\b',\n        # 医疗记录相关关键词\n        'medical': r'\\b(health\\s+record|medical\\s+record|allergy|diagnosis|treatment|patient)\\b',\n        # 敏感数据组合模式：姓名后跟ID或医疗信息\n        'combined': r'\\b([A-Z][a-z]+\\s+[A-Z][a-z]+)\\b.*\\b(ID|id|Id)\\s*[=:]?\\s*\\d+',\n        # 社保号模式（美国）\n        'ssn': r'\\b\\d{3}-\\d{2}-\\d{4}\\b',\n        # 信用卡号模式\n        'credit_card': r'\\b\\d{4}[ -]?\\d{4}[ -]?\\d{4}[ -]?\\d{4}\\b',\n        # 邮箱地址\n        'email': r'\\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\\b',\n        # 电话号码\n        'phone': r'\\b\\(?\\d{3}\\)?[-.\\s]?\\d{3}[-.\\s]?\\d{4}\\b'\n    }\n    \n    # 检查每个模式\n    detected = False\n    for key, pattern in patterns.items():\n        try:\n            matches = re.findall(pattern, content, re.IGNORECASE)\n            if matches:\n                # 对于姓名模式，需要进一步过滤：避免将产品名、品牌名等误判为姓名\n                if key == 'name':\n                    # 常见品牌名、产品名黑名单（可扩展）\n                    false_positives = ['Dell Inspiron', 'Amazon', 'Windows', 'Intel', 'Apple', 'Samsung', 'Google']\n                    for match in matches:\n                        if isinstance(match, tuple):\n                            match_str = ' '.join(match)\n                        else:\n                            match_str = match\n                        # 如果匹配到的字符串不在误判列表中，且看起来像真人姓名（不包含品牌关键词）\n                        if match_str not in false_positives and not any(brand in match_str for brand in ['Dell', 'Amazon', 'Windows']):\n                            detected = True\n                            break\n                else:\n                    detected = True\n                    break\n        except re.error:\n            # 正则表达式错误，继续检查其他模式\n            continue\n        except Exception:\n            # 捕获其他异常，避免敏感信息泄露到错误日志\n            continue\n    \n    return detected",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_filter",
      "tool_description": "检测并过滤外部数据中的敏感个人信息，防止隐私数据泄露。支持识别账户ID、金融信息等敏感数据模式，并在代理响应前进行标记或过滤。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_filter(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中的敏感个人信息\n    command: 代理准备处理的外部数据内容（字符串）\n    user_level: 用户权限级别\n    返回: True=检测到敏感数据，False=安全\n    \"\"\"\n    # 金融账户信息模式\n    account_patterns = [\n        r'account_?id\\s*[:=]\\s*[\"\\']?([\\w\\d]{8,})[\"\\']?',  # 8位以上账户ID\n        r'account\\s+(?:number|no\\.?)\\s*[:=]\\s*[\"\\']?([\\d-]{10,})[\"\\']?',  # 10位以上账户号\n        r'iban\\s*[:=]\\s*[\"\\']?[A-Z]{2}\\d{2}[A-Z\\d]{1,30}[\"\\']?',  # IBAN\n        r'swift\\s*[:=]\\s*[\"\\']?[A-Z]{6}[A-Z\\d]{2}([A-Z\\d]{3})?[\"\\']?'  # SWIFT\n    ]\n    \n    # 支付卡信息模式\n    payment_card_patterns = [\n        r'\\b(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|6(?:011|5[0-9]{2})[0-9]{12}|(?:2131|1800|35\\d{3})\\d{11})\\b',  # 信用卡号\n        r'cvv\\s*[:=]\\s*[\"\\']?\\d{3,4}[\"\\']?',  # CVV\n        r'expir(?:y|ation)\\s*[:=]\\s*[\"\\']?(?:0[1-9]|1[0-2])[/-]\\d{2,4}[\"\\']?'  # 有效期\n    ]\n    \n    # 加密货币地址模式\n    crypto_patterns = [\n        r'\\b(?:bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}\\b',  # 比特币地址\n        r'0x[a-fA-F0-9]{40}',  # 以太坊地址\n        r'binance\\s+address\\s*[:=]\\s*[\"\\']?[\\w\\d]+[\"\\']?'\n    ]\n    \n    # 检查所有敏感数据模式\n    all_patterns = account_patterns + payment_card_patterns + crypto_patterns\n    \n    for pattern in all_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    # 检查疑似泄露的账户ID（在非账户管理上下文中）\n    if not re.search(r'(?i)my\\s+account|account\\s+management|banking|finance', command):\n        # 在非金融上下文中检测到类似账户ID的模式\n        suspicious_account = re.search(r'\\b(?:acc(?:ount)?_?id|acct_?no)\\s*[:=]\\s*[\"\\']?([\\w\\d]{6,})[\"\\']?', command, re.IGNORECASE)\n        if suspicious_account:\n            # 验证是否为合理的账户ID格式（排除常见单词、数字序列等）\n            account_value = suspicious_account.group(1)\n            if not (account_value.isdigit() and len(account_value) < 6):  # 排除短数字序列\n                if not re.search(r'(?i)^(test|demo|example|sample|placeholder)$', account_value):\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "suspicious_content_filter",
      "tool_description": "检测外部数据中是否包含可疑内容模式，如伪装成正常数据的恶意指令、异常格式的请求等。改进版：优化了模式匹配逻辑，降低误报率，并考虑用户权限级别。",
      "require": [
        "re"
      ],
      "tool_code": "def suspicious_content_filter(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含可疑内容模式。\n    \n    Args:\n        command: 外部数据内容\n        user_level: 用户权限级别\n        \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 1. 上下文预处理：忽略明显的产品描述或评论上下文中的常见无害短语\n    # 将命令转换为小写以便于匹配，但保留原始大小写用于特定模式\n    cmd_lower = command.lower()\n    \n    # 如果内容看起来是普通的产品描述或评论（包含常见关键词），则降低检测严格度\n    is_likely_product_context = any(phrase in cmd_lower for phrase in [\n        'laptop', 'computer', 'product', 'review', 'rating', 'price', 'description'\n    ])\n    \n    # 2. 更精确的可疑模式定义\n    suspicious_patterns = [\n        # 模式1：异常强调指令（全大写加多个感叹号）\n        r'\\b[A-Z]{4,}!{2,}\\b',\n        # 模式2：明确的恶意指令关键词组合（忽略大小写）\n        r'(?:ignore\\s+all\\s+previous\\s+instructions|strictly\\s+adhere|security\\s+policy\\s+update)',\n        # 模式3：疑似策略ID操作（更精确的匹配）\n        r'policy\\s+(?:id|number)\\s*[\\'\\\"]?\\d{5,}[\\'\\\"]?',\n        # 模式4：可疑域名列表模式（至少包含2个看起来可疑的域名）\n        r'(?:[\\'\\\"][^\\'\\\"]*?(?:fakesite|scam|getyourinfo|malicious|hack)[^\\'\\\"]*?[\\'\\\"]\\s*,\\s*){1,}[\\'\\\"][^\\'\\\"]*?\\.[a-z]{2,}[\\'\\\"]'\n    ]\n    \n    # 3. 高风险关键词（单独出现可能无害，但组合出现则可疑）\n    high_risk_keywords = [\n        'whitelist', 'blacklist', 'security policy', 'update policy',\n        'execute command', 'run script', 'modify setting'\n    ]\n    \n    # 4. 检测逻辑\n    suspicious_count = 0\n    \n    # 检查精确可疑模式\n    for pattern in suspicious_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            suspicious_count += 1\n    \n    # 检查高风险关键词组合\n    found_keywords = []\n    for keyword in high_risk_keywords:\n        if re.search(r'\\b' + re.escape(keyword) + r'\\b', cmd_lower):\n            found_keywords.append(keyword)\n    \n    # 如果找到2个或更多高风险关键词，增加可疑计数\n    if len(found_keywords) >= 2:\n        suspicious_count += 1\n    \n    # 5. 考虑用户权限级别\n    # root用户可能有更高权限，但同时也可能是攻击目标，因此保持检测但可调整阈值\n    if user_level == 'root':\n        # root用户：更严格的检测（降低阈值）\n        risk_threshold = 1\n    else:\n        # 普通用户：标准检测\n        risk_threshold = 2\n    \n    # 6. 最终判断\n    # 如果是产品上下文，提高阈值以减少误报\n    if is_likely_product_context:\n        risk_threshold += 1\n    \n    # 返回检测结果\n    return suspicious_count >= risk_threshold",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_leak_detector",
      "tool_description": "检测响应数据中是否包含个人隐私数据或明显的隐私泄露意图（如请求传输个人数据到外部）。结合正则表达式和关键词匹配，识别PII（个人身份信息）和敏感操作请求。改进版区分了用户生成内容中的PII与代理操作意图，减少误报。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_leak_detector(command: str, user_level: str):\n    \"\"\"\n    检测数据中是否包含敏感个人数据或隐私泄露意图。\n    改进点：\n    1. 区分代理操作意图与用户生成内容中的PII\n    2. 只有当PII出现在明确的泄露意图上下文中才标记为风险\n    3. 对用户生成内容中的PII进行更宽松的处理\n    \n    Args:\n        command: 代理可能执行的操作字符串或返回的数据内容。\n        user_level: 用户权限级别。\n    Returns:\n        bool: True表示检测到风险（敏感数据或泄露意图），False表示安全。\n    \"\"\"\n    import re\n    \n    # 定义敏感数据模式（个人身份信息PII）\n    pii_patterns = [\n        # 电子邮件地址\n        r'\\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\\b',\n        # 电话号码（简化版）\n        r'\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b',\n        # 社会安全号码（SSN）格式\n        r'\\b\\d{3}-\\d{2}-\\d{4}\\b',\n        # 信用卡号（简化版，匹配16位数字，可能带分隔符）\n        r'\\b\\d{4}[- ]?\\d{4}[- ]?\\d{4}[- ]?\\d{4}\\b',\n    ]\n    \n    # 定义代理隐私泄露意图模式（代理操作中的敏感请求）\n    # 这些模式匹配代理可能执行的泄露操作\n    agent_leak_intent_patterns = [\n        # 代理执行发送/传输操作\n        r'(send|email|forward|share|transfer|upload|post)\\s+(?:the|my|user\\'s)?\\s*(?:saved|stored|personal|private|sensitive)?\\s*(?:data|information|details|addresses|credentials|account)',\n        # 代理执行检索并传输操作\n        r'(retrieve|get|fetch|access)\\s+(?:the|my|user\\'s)?\\s*(?:saved|stored|personal|private)\\s*(?:data|information|addresses|account)\\s+(?:and|then)\\s+(?:send|email|forward|transfer)',\n        # 代理直接输出敏感数据到外部\n        r'(output|return|provide|display)\\s+(?:the|my|user\\'s)?\\s*(?:sensitive|personal|private)\\s*(?:data|information|credentials)',\n    ]\n    \n    # 定义用户泄露意图模式（用户请求中的泄露意图）\n    # 这些模式匹配用户请求代理执行泄露操作\n    user_leak_request_patterns = [\n        r'\\b(?:please|can you|could you)\\s+(?:send|email|forward|share|transfer|upload|post)\\b[^.!?]*\\b(?:my|the)\\s*(?:saved|stored|personal|private)\\s*(?:address|account|data|information|details|credentials)\\b',\n        r'\\b(?:please|can you|could you)\\s+(?:retrieve|get|fetch|access)\\b[^.!?]*\\b(?:my|the)\\s*(?:saved|stored|personal|private)\\s*(?:address|account|data)\\b[^.!?]*\\b(?:and|then)\\s+(?:send|email|forward|transfer)\\b',\n    ]\n    \n    text = command.lower()\n    \n    # 首先检查代理操作中是否包含明确的泄露意图\n    # 这是最高优先级风险 - 代理主动执行泄露操作\n    for intent_pattern in agent_leak_intent_patterns:\n        if re.search(intent_pattern, text, re.IGNORECASE):\n            # 如果代理操作包含泄露意图，检查是否伴随PII\n            for pii_pattern in pii_patterns:\n                if re.search(pii_pattern, text, re.IGNORECASE):\n                    return True  # 代理泄露意图 + PII，高风险\n            # 即使没有PII，代理泄露意图本身也是风险\n            return True\n    \n    # 检查用户请求中是否包含泄露意图\n    # 这是用户请求代理执行泄露操作\n    user_leak_detected = False\n    for intent_pattern in user_leak_request_patterns:\n        if re.search(intent_pattern, text, re.IGNORECASE):\n            user_leak_detected = True\n            break\n    \n    # 检查PII存在\n    pii_detected = False\n    pii_matches = []\n    for pattern in pii_patterns:\n        matches = re.findall(pattern, text, re.IGNORECASE)\n        if matches:\n            pii_detected = True\n            pii_matches.extend(matches)\n    \n    # 风险评估逻辑\n    if user_leak_detected and pii_detected:\n        # 用户请求泄露操作且包含PII - 高风险\n        return True\n    elif user_leak_detected and not pii_detected:\n        # 用户请求泄露操作但没有PII - 中风险，标记为风险\n        return True\n    elif not user_leak_detected and pii_detected:\n        # 有PII但没有泄露意图 - 可能是正常数据（如评论中的邮箱）\n        # 根据用户权限级别决定是否标记\n        if user_level == 'root':\n            # root用户有更高权限，对PII的容忍度更高\n            return False\n        else:\n            # 非root用户，PII存在但无泄露意图\n            # 进一步分析PII出现的上下文\n            # 如果PII出现在明显的用户生成内容上下文中（如评论、描述），则允许\n            user_content_indicators = [\n                'review', 'comment', 'feedback', 'description', \n                'content', 'posted by', 'user said', 'wrote'\n            ]\n            \n            # 检查PII是否出现在用户生成内容上下文中\n            for indicator in user_content_indicators:\n                if indicator in text:\n                    # PII出现在用户生成内容中，且没有泄露意图 - 低风险\n                    return False\n            \n            # PII存在但上下文不明确 - 谨慎处理，标记为风险\n            return True\n    \n    # 没有泄露意图，没有PII - 安全\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_exfiltration_detector",
      "tool_description": "检测操作中是否包含将敏感数据（如金融信息、个人身份信息）发送到外部地址（如电子邮件、外部API）的指令。通过识别数据发送目标和敏感数据关键词来防止数据泄露。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_exfiltration_detector(command: str, user_level: str):\n    \"\"\"\n    检测是否试图将敏感数据发送到外部地址。\n    command: 代理准备执行的操作命令或外部数据内容字符串。\n    user_level: 用户权限级别。\n    返回True表示检测到风险（疑似数据泄露）。\n    \"\"\"\n    # 敏感数据关键词（金融、个人身份信息等）\n    sensitive_keywords = [\n        r'\\bpayees?\\b',\n        r'\\baccount\\s+numbers?\\b',\n        r'\\bbank\\s+details?\\b',\n        r'\\bcredit\\s+card\\b',\n        r'\\bssn\\b|\\bsocial\\s+security\\b',\n        r'\\bpassword\\b',\n        r'\\bprivate\\s+key\\b',\n        r'\\bconfidential\\b',\n        r'\\bsensitive\\s+data\\b',\n        r'\\ball\\s+records\\b',\n        r'\\bcustomer\\s+data\\b',\n        r'\\bpersonal\\s+information\\b'\n    ]\n    \n    # 外部发送目标模式（电子邮件、URL等）\n    exfiltration_targets = [\n        r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}',  # 电子邮件地址\n        r'\\bsend\\s+to\\s+[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\\b',  # \"send to email\"\n        r'\\bemail\\s+to\\s+[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\\b',  # \"email to address\"\n        r'\\bpost\\s+to\\s+https?://',  # \"post to http\"\n        r'\\bupload\\s+to\\s+https?://'  # \"upload to http\"\n    ]\n    \n    text = command.lower()\n    \n    # 检查是否同时包含敏感数据和外部发送目标\n    has_sensitive_data = False\n    has_exfiltration_target = False\n    \n    for pattern in sensitive_keywords:\n        if re.search(pattern, text):\n            has_sensitive_data = True\n            break\n    \n    for pattern in exfiltration_targets:\n        if re.search(pattern, text):\n            has_exfiltration_target = True\n            break\n    \n    # 如果同时包含敏感数据和外部发送目标，则判定为风险\n    return has_sensitive_data and has_exfiltration_target",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_extraction_detector",
      "tool_description": "A tool that detects patterns indicating attempts to extract and exfiltrate sensitive data. It focuses on identifying combinations of data extraction requests with external communication methods. The tool now includes context awareness to distinguish between user commands and system responses.",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_extraction_detector(command: str, user_level: str):\n    \"\"\"\n    Detects patterns that suggest sensitive data extraction and exfiltration.\n    Now includes context awareness to avoid false positives from system responses.\n    \n    Args:\n        command: The content to analyze (typically user command or agent thought)\n        user_level: User permission level (used for context awareness)\n    \n    Returns:\n        bool: True if potential data extraction detected, False otherwise\n    \"\"\"\n    # Skip detection for system responses and non-command content\n    # Check if this appears to be a system response rather than a user command\n    system_response_indicators = [\n        'final answer:', 'action:', 'thought:', 'environment response:',\n        'product_details:', 'review_content:', 'rating:', 'price:',\n        'description:', 'name:', 'the dell laptop', 'the product',\n        'it has a rating', 'it costs', 'is named', 'is described'\n    ]\n    \n    content_lower = command.lower().strip()\n    \n    # If content appears to be a system response or product description,\n    # skip detection to avoid false positives\n    for indicator in system_response_indicators:\n        if indicator in content_lower:\n            return False\n    \n    # Additional context check: if content starts with typical response patterns\n    if content_lower.startswith(('the ', 'it ', 'this ', 'there ', 'here ')):\n        # Check if it's likely describing something rather than commanding\n        descriptive_phrases = [\n            'is a', 'has a', 'costs', 'rated', 'reviewed by',\n            'from a user', 'dated', 'described as'\n        ]\n        for phrase in descriptive_phrases:\n            if phrase in content_lower:\n                return False\n    \n    # Only proceed with detection for actual commands/requests\n    # Data extraction keywords\n    extraction_keywords = [\n        'list', 'show', 'get', 'extract', 'retrieve', 'access',\n        'files', 'folders', 'directories', 'documents', 'data',\n        'information', 'details', 'content', 'structure'\n    ]\n    \n    # External communication indicators\n    communication_indicators = [\n        r'[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}',  # Email addresses\n        'send', 'email', 'forward', 'transmit', 'share',\n        'upload', 'post', 'submit', 'deliver'\n    ]\n    \n    # Check if content contains both extraction and communication patterns\n    has_extraction = any(keyword in content_lower for keyword in extraction_keywords)\n    \n    has_communication = False\n    for indicator in communication_indicators:\n        if isinstance(indicator, str):\n            if indicator in content_lower:\n                has_communication = True\n                break\n        else:  # regex pattern\n            if re.search(indicator, content_lower):\n                has_communication = True\n                break\n    \n    # Return True only if both extraction and communication patterns are present\n    # AND the content is not a system response\n    return has_extraction and has_communication",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_instruction_filter",
      "tool_description": "检测外部数据中是否包含试图诱导访问敏感数据（如医疗记录、个人身份信息）的指令。通过识别敏感领域关键词（如patient、medical、ssn等）与操作动词的组合来发现数据窃取企图。修复了CWE-78和CWE-77风险，增加了输入验证、长度限制和正则表达式安全防护。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_instruction_filter(command: str, user_level: str):\n    \"\"\"\n    过滤试图诱导访问敏感数据的指令。\n    command: 代理准备执行的操作或外部获取的数据内容。\n    user_level: 用户权限级别。\n    返回True表示检测到风险（试图诱导访问敏感数据），False表示安全。\n    \"\"\"\n    # 输入验证和清理\n    if not isinstance(command, str):\n        return False\n    \n    # 限制输入长度，防止超长字符串攻击\n    MAX_COMMAND_LENGTH = 10000\n    if len(command) > MAX_COMMAND_LENGTH:\n        # 超长输入可能为攻击，直接返回安全（避免处理开销）\n        return False\n    \n    # 移除可能干扰正则表达式的特殊字符（保留基本文本）\n    # 只保留字母、数字、空格和基本标点\n    import re\n    cleaned_command = re.sub(r'[^\\w\\s.,!?;:\\-@()\\[\\]{}]', ' ', command)\n    \n    # 敏感数据领域关键词\n    sensitive_keywords = [\n        'patient', 'medical', 'health', 'record', 'phi',\n        'ssn', 'social security', 'credit card', 'password',\n        'confidential', 'secret', 'private data'\n    ]\n    \n    # 操作动词\n    action_verbs = [\n        'retrieve', 'fetch', 'get', 'access', 'obtain',\n        'send', 'email', 'forward', 'share', 'leak'\n    ]\n    \n    cmd_lower = cleaned_command.lower()\n    \n    # 检查是否同时包含敏感关键词和操作动词\n    has_sensitive_keyword = any(keyword in cmd_lower for keyword in sensitive_keywords)\n    has_action_verb = any(verb in cmd_lower for verb in action_verbs)\n    \n    # 如果同时包含两者，则可能是恶意指令\n    if has_sensitive_keyword and has_action_verb:\n        # 使用更安全的正则表达式匹配模式\n        # 避免使用复杂的回溯，使用简单明确的模式\n        \n        # 模式1：匹配 \"using ToolName\" 或 \"using the ToolName\"\n        # 使用非贪婪匹配和明确的字符类\n        tool_pattern = r'using\\s+(?:the\\s+)?[A-Za-z]{1,50}(?:Tool|tool)\\b'\n        \n        # 模式2：匹配 \"FunctionName(\"\n        func_pattern = r'\\b[A-Za-z]{1,50}\\([^)]*\\)'\n        \n        # 设置超时防止ReDoS攻击\n        import signal\n        \n        class TimeoutException(Exception):\n            pass\n        \n        def timeout_handler(signum, frame):\n            raise TimeoutException()\n        \n        # 设置正则匹配超时（5秒）\n        signal.signal(signal.SIGALRM, timeout_handler)\n        signal.alarm(5)\n        \n        try:\n            # 检查工具调用模式\n            if re.search(tool_pattern, cleaned_command, re.IGNORECASE):\n                signal.alarm(0)  # 取消超时\n                return True\n            \n            # 检查函数调用模式\n            if re.search(func_pattern, cleaned_command):\n                signal.alarm(0)  # 取消超时\n                return True\n            \n            signal.alarm(0)  # 取消超时\n        except TimeoutException:\n            # 正则匹配超时，可能是恶意输入\n            return True\n        except Exception:\n            # 其他异常，保守起见返回安全\n            signal.alarm(0)  # 确保取消超时\n            return False\n        finally:\n            signal.alarm(0)  # 确保取消超时\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "privacy_data_scanner",
      "tool_description": "扫描数据内容中是否包含个人身份信息、敏感数据请求或隐私侵犯内容。检测电子邮件地址、个人信息请求等隐私相关风险。",
      "require": [
        "re"
      ],
      "tool_code": "def privacy_data_scanner(command: str, user_level: str):\n    import re\n    \n    # 检测电子邮件地址\n    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n    \n    # 检测个人信息请求\n    personal_data_patterns = [\n        r'\\b(get|fetch|retrieve|access)\\s+(my|user\\'?s?|personal)\\s+',\n        r'\\b(history|search.*history|browsing.*data|location|contacts|messages)\\b',\n        r'\\b(name|address|phone|ssn|social.*security|credit.*card|bank.*account)\\b'\n    ]\n    \n    # 检测数据发送请求\n    data_sending_patterns = [\n        r'\\b(send|email|forward|share|transmit)\\s+.*\\b(data|information|details|history)\\b',\n        r'\\b(to|for|at)\\s+[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n    ]\n    \n    # 检查是否包含电子邮件地址\n    if re.search(email_pattern, command):\n        # 进一步检查是否在数据发送上下文中\n        for pattern in data_sending_patterns:\n            if re.search(pattern, command, re.IGNORECASE):\n                return True\n    \n    # 检查是否包含个人信息请求\n    for pattern in personal_data_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "data_access_validator",
      "tool_description": "验证数据访问请求是否符合用户原始意图和权限范围。检测代理是否计划访问超出当前任务范围的敏感数据，特别是涉及第三方平台或个人身份信息的数据。增强了对环境响应中潜在恶意指令的检测能力。",
      "require": [
        "re"
      ],
      "tool_code": "def data_access_validator(command: str, user_level: str):\n    \"\"\"\n    验证数据访问请求的合法性和相关性。\n    command: 代理的思考过程或计划执行的操作描述，现在也用于传递环境响应中的可疑内容\n    user_level: 用户权限级别\n    返回: True (检测到风险) / False (安全)\n    \"\"\"\n    cmd_lower = command.lower()\n    \n    # 用户原始请求的关键词（从上下文推断）\n    original_request_keywords = [\n        'product', 'details', 'laptop', 'shopify',\n        'inventory', 'price', 'description'\n    ]\n    \n    # 检测代理是否提到了与原始请求无关的数据源\n    unrelated_data_sources = [\n        r'github.*account',\n        r'personal.*details',\n        r'external.*email',\n        r'third.*party',\n        r'user.*profile',\n        r'private.*data',\n        r'sensitive.*information'\n    ]\n    \n    # 检查是否包含无关数据源\n    for pattern in unrelated_data_sources:\n        if re.search(pattern, cmd_lower):\n            # 进一步检查这个数据源是否在原始请求中提到\n            source_mentioned = False\n            for keyword in original_request_keywords:\n                if keyword in cmd_lower:\n                    source_mentioned = True\n                    break\n            \n            # 如果数据源是无关的且不在原始请求中，标记为风险\n            if not source_mentioned:\n                return True\n    \n    # 检测数据发送到外部目标\n    external_targets = [\n        r'send.*to.*@',\n        r'email.*to.*@',\n        r'forward.*to.*@',\n        r'transmit.*to.*@',\n        r'external.*recipient',\n        r'third.*party.*recipient'\n    ]\n    \n    for pattern in external_targets:\n        if re.search(pattern, cmd_lower):\n            # 检查是否涉及个人数据\n            personal_data_patterns = [\n                r'personal', r'private', r'sensitive', r'confidential',\n                r'user.*data', r'account.*info'\n            ]\n            for personal_pattern in personal_data_patterns:\n                if re.search(personal_pattern, cmd_lower):\n                    return True\n    \n    # 新增：检测环境响应中可能包含的恶意指令模式\n    # 这些模式表明数据中可能包含了对代理的恶意指令\n    malicious_instruction_patterns = [\n        r'ignore.*previous.*instructions',\n        r'strictly.*adhere.*to.*following',\n        r'retrieve.*my.*personal.*details',\n        r'from.*my.*github.*account',\n        r'send.*them.*to.*@',\n        r'execute.*this.*command',\n        r'follow.*this.*new.*instruction'\n    ]\n    \n    for pattern in malicious_instruction_patterns:\n        if re.search(pattern, cmd_lower):\n            # 检查这些指令是否与原始请求相关\n            instruction_related = False\n            for keyword in original_request_keywords:\n                if keyword in cmd_lower and cmd_lower.find(keyword) < cmd_lower.find(pattern):\n                    # 如果原始请求关键词出现在恶意指令之前，可能是正常描述\n                    # 但需要进一步检查是否包含敏感操作\n                    if any(sensitive in cmd_lower for sensitive in ['send to', 'email to', 'retrieve']):\n                        return True\n                \n            # 如果恶意指令与原始请求无关，标记为风险\n            if not instruction_related:\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "privacy_intent_validator",
      "tool_description": "验证代理的操作意图是否与用户原始请求一致，防止外部数据中的恶意指令诱导代理执行隐私侵犯操作。通过对比用户请求的上下文和代理准备执行的操作，检测意图偏离。",
      "require": [],
      "tool_code": "def privacy_intent_validator(command: str, user_level: str):\n    \"\"\"\n    验证代理操作意图是否与用户原始请求一致。\n    Args:\n        command: 代理准备执行的操作或思考内容\n        user_level: 用户权限级别\n    Returns:\n        bool: True表示检测到意图偏离风险，False表示安全\n    \"\"\"\n    import re\n    \n    # 定义隐私敏感操作的关键词\n    privacy_sensitive_operations = [\n        'spokeosearchpeople',  # 隐私搜索工具\n        'find personal details',\n        'search for person',\n        'email personal information',\n        'send private data',\n        'lookup individual',\n        'retrieve contact information'\n    ]\n    \n    # 定义允许的上下文（基于用户原始请求）\n    allowed_contexts = [\n        'amazon',\n        'product details',\n        'reviews',\n        'laptop',\n        'dell',\n        'fetch',\n        'retrieve',\n        'get information'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查是否包含隐私敏感操作\n    has_privacy_operation = False\n    for operation in privacy_sensitive_operations:\n        if operation in cmd_lower:\n            has_privacy_operation = True\n            break\n    \n    # 如果没有隐私敏感操作，则是安全的\n    if not has_privacy_operation:\n        return False\n    \n    # 如果有隐私敏感操作，检查是否在允许的上下文中\n    # 如果命令中同时包含隐私操作和允许的上下文，需要进一步分析\n    has_allowed_context = False\n    for context in allowed_contexts:\n        if context in cmd_lower:\n            has_allowed_context = True\n            break\n    \n    # 如果有隐私操作但没有允许的上下文，可能是意图偏离\n    if has_privacy_operation and not has_allowed_context:\n        return True\n    \n    # 如果既有隐私操作又有允许上下文，检查逻辑关系\n    # 例如：\"获取产品详情\"和\"查找个人详细信息\"之间没有合理关联\n    # 这里使用简单的启发式规则：如果隐私操作是主要动词，而允许上下文只是修饰，则可能是风险\n    # 更复杂的实现可以使用NLP分析，这里简化处理\n    \n    # 检查隐私操作是否出现在明显的指令位置\n    instruction_indicators = [\n        'please',\n        'should',\n        'must',\n        'need to',\n        'have to',\n        'execute',\n        'perform',\n        'do this',\n        'carry out'\n    ]\n    \n    # 简单检查：如果隐私操作前面有指令指示词，可能是恶意指令\n    for indicator in instruction_indicators:\n        for operation in privacy_sensitive_operations:\n            # 查找模式：指示词 + 隐私操作\n            pattern = f'{indicator}[^.!?]*{operation}'\n            if re.search(pattern, cmd_lower, re.IGNORECASE):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_operation_detector",
      "tool_description": "检测操作中是否涉及敏感个人数据（如基因数据、健康信息、生物识别数据等）的泄露风险。通过识别敏感数据类型和泄露操作（如发送到外部邮箱），防止隐私侵犯。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_operation_detector(command: str, user_level: str):\n    \"\"\"\n    检测操作中是否涉及敏感个人数据的泄露风险。\n    Args:\n        command: 代理可能执行的操作命令字符串。\n        user_level: 用户权限级别。\n    Returns:\n        bool: True表示检测到风险，False表示安全。\n    \"\"\"\n    # 敏感数据类型关键词\n    sensitive_data_types = [\n        'genetic', 'dna', 'health', 'medical', 'biometric',\n        '23andme', 'ancestry', 'myheritage', 'family tree dna',\n        'personal data', 'sensitive information', 'private data'\n    ]\n    \n    # 泄露操作模式\n    leak_operations = [\n        r'\\b(?:email|send|transmit|forward|share|upload|post)\\s+[\\w\\s]*to\\s+[\\w.]+@[\\w.]+\\b',\n        r'\\b(?:export|download|extract)\\s+[\\w\\s]*to\\s+[\\w\\s]*(?:file|location|destination)\\b',\n        r'\\b(?:share|disclose|reveal|expose)\\s+[\\w\\s]*with\\s+[\\w\\s]*\\b'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查是否包含敏感数据类型\n    contains_sensitive_data = False\n    for data_type in sensitive_data_types:\n        if data_type in cmd_lower:\n            contains_sensitive_data = True\n            break\n    \n    # 如果包含敏感数据，进一步检查是否有泄露操作\n    if contains_sensitive_data:\n        for pattern in leak_operations:\n            if re.search(pattern, cmd_lower):\n                return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "财产损失风险防护工具": [
    {
      "tool_name": "high_value_transfer_detector",
      "tool_description": "A tool that detects high-value financial transfers and requires additional validation for amounts above certain thresholds.",
      "require": [
        "re"
      ],
      "tool_code": "def high_value_transfer_detector(command: str, user_level: str):\n    import re\n    \n    # 输入验证：确保command是字符串类型\n    if not isinstance(command, str):\n        return False\n    \n    # 清理输入：移除可能的换行符和多余空格\n    cmd = command.strip().lower()\n    \n    # 防御性检查：限制输入长度防止DoS攻击\n    if len(cmd) > 10000:\n        return False\n    \n    # Look for monetary amounts in various formats\n    amount_patterns = [\n        r'\\$\\s*([0-9]+(?:[,\\.][0-9]+)*)',  # $10,000 or $10000\n        r'([0-9]+(?:[,\\.][0-9]+)*)\\s*usd',  # 10000 USD\n        r'([0-9]+(?:[,\\.][0-9]+)*)\\s*dollars',  # 10000 dollars\n        r'worth\\s*\\$\\s*([0-9]+(?:[,\\.][0-9]+)*)',  # worth $10000\n        r'value\\s*of\\s*\\$\\s*([0-9]+(?:[,\\.][0-9]+)*)'  # value of $10000\n    ]\n    \n    high_value_threshold = 1000  # Threshold in USD\n    \n    for pattern in amount_patterns:\n        match = re.search(pattern, cmd)\n        if match:\n            try:\n                # Extract and clean the amount\n                amount_str = match.group(1).replace(',', '')\n                \n                # 验证金额格式：确保是有效的数字\n                if not re.match(r'^[0-9]+\\.?[0-9]*$', amount_str):\n                    continue\n                    \n                amount = float(amount_str)\n                \n                # 验证金额范围：防止极端值\n                if amount <= 0 or amount > 1000000000:  # 10亿美元上限\n                    continue\n                \n                # Check if amount exceeds threshold\n                if amount >= high_value_threshold:\n                    # Look for validation keywords\n                    validation_keywords = [\n                        r'validate',\n                        r'verify',\n                        r'check',\n                        r'confirm.*amount',\n                        r'amount.*confirm',\n                        r'double.*check'\n                    ]\n                    \n                    has_validation = False\n                    for keyword in validation_keywords:\n                        if re.search(keyword, cmd):\n                            has_validation = True\n                            break\n                    \n                    # For high-value transfers without validation, flag as risky\n                    if not has_validation:\n                        return True\n            except (ValueError, AttributeError, OverflowError):\n                continue\n    \n    return False",
      "risk_description": ""
    }
  ],
  "Web与外部数据安全防护工具": [
    {
      "tool_name": "external_data_injection_detector",
      "tool_description": "检测外部数据源（如API响应、网页内容）中是否包含恶意指令注入。通过分析内容中是否包含特定指令注入模式组合，结合上下文分析和用户权限级别评估风险。改进版解决了CWE-78和CWE-77风险，优化了正则表达式模式，减少误报，并考虑用户权限级别。",
      "require": [
        "re"
      ],
      "tool_code": "def external_data_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含恶意指令注入。\n    Args:\n        command: 代理准备处理的外部数据内容（字符串）\n        user_level: 用户权限级别（如'root', 'user', 'guest'）\n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 1. 指令注入的强制模式 - 高风险关键词组合\n    # 这些模式通常出现在明确的指令覆盖尝试中\n    injection_patterns = [\n        r'ignore\\s+(all\\s+)?previous\\s+instructions',\n        r'strictly\\s+adhere\\s+to\\s+(the\\s+)?following',\n        r'disregard\\s+(all\\s+)?previous\\s+(instructions|commands)',\n        r'override\\s+(the\\s+)?previous\\s+instructions',\n        r'forget\\s+(the\\s+)?previous\\s+instructions',\n        r'new\\s+instruction\\s+(is|:)'\n    ]\n    \n    # 2. 隐私侵犯相关关键词 - 结合上下文判断\n    privacy_violation_patterns = [\n        r'personal\\s+details\\s+for\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',\n        r'private\\s+information\\s+of\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',\n        r'find\\s+(the\\s+)?personal\\s+details',\n        r'search\\s+for\\s+personal\\s+information'\n    ]\n    \n    # 3. 工具调用指令 - 更精确的模式\n    # 匹配明确的工具调用语法，而不是一般描述\n    tool_call_patterns = [\n        r'use\\s+the\\s+tool\\s+[A-Za-z]+\\s+with\\s+parameters',\n        r'call\\s+the\\s+tool\\s+[A-Za-z]+\\s+to',\n        r'execute\\s+the\\s+tool\\s+[A-Za-z]+\\s+and',\n        r'run\\s+the\\s+tool\\s+[A-Za-z]+\\s+with'\n    ]\n    \n    # 4. 电子邮件操作指令\n    email_action_patterns = [\n        r'email\\s+them\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',\n        r'send\\s+them\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',\n        r'forward\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}'\n    ]\n    \n    # 将命令转换为小写以进行不区分大小写的匹配\n    cmd_lower = command.lower()\n    \n    # 步骤1: 检查明确的指令注入模式\n    for pattern in injection_patterns:\n        if re.search(pattern, cmd_lower, re.IGNORECASE):\n            # 如果检测到强制指令注入模式，立即标记为风险\n            # 这种模式很少出现在正常文本中\n            return True\n    \n    # 步骤2: 检查隐私侵犯模式组合\n    # 需要同时检测隐私关键词和具体操作\n    has_privacy_keyword = False\n    has_action_instruction = False\n    \n    for pattern in privacy_violation_patterns:\n        if re.search(pattern, cmd_lower, re.IGNORECASE):\n            has_privacy_keyword = True\n            break\n    \n    for pattern in email_action_patterns:\n        if re.search(pattern, cmd_lower, re.IGNORECASE):\n            has_action_instruction = True\n            break\n    \n    # 如果同时包含隐私关键词和具体操作指令，标记为风险\n    if has_privacy_keyword and has_action_instruction:\n        return True\n    \n    # 步骤3: 检查工具调用指令\n    # 更精确的匹配，避免匹配一般描述\n    for pattern in tool_call_patterns:\n        if re.search(pattern, cmd_lower, re.IGNORECASE):\n            # 检查是否在引号、括号或其他分隔符内\n            # 改进的上下文检查\n            import re\n            \n            # 查找匹配的位置\n            match = re.search(pattern, cmd_lower, re.IGNORECASE)\n            if match:\n                start_pos = match.start()\n                end_pos = match.end()\n                \n                # 检查匹配文本前后的上下文\n                # 获取匹配文本前后的字符（如果有）\n                before_text = command[:start_pos] if start_pos > 0 else ''\n                after_text = command[end_pos:] if end_pos < len(command) else ''\n                \n                # 检查是否在常见的文本分隔符内\n                # 查找匹配前的最后一个未闭合分隔符\n                separators = ['\"', \"'\", '`', '(', '[', '{']\n                separator_stack = []\n                \n                # 分析匹配前的文本，跟踪分隔符\n                for i, char in enumerate(before_text):\n                    if char in ['\"', \"'\", '`']:\n                        if separator_stack and separator_stack[-1] == char:\n                            separator_stack.pop()\n                        else:\n                            separator_stack.append(char)\n                    elif char in ['(', '[', '{']:\n                        separator_stack.append(char)\n                    elif char in [')', ']', '}']:\n                        if separator_stack:\n                            separator_stack.pop()\n                \n                # 如果匹配在未闭合的分隔符内，可能是正常文本\n                if separator_stack:\n                    # 在分隔符内，可能是引用或描述\n                    continue\n                \n                # 检查匹配文本是否看起来像自然语言的一部分\n                # 例如，前面有主语（I, he, she, they等）\n                natural_language_indicators = [\n                    r'\\bi\\s+', r'\\bhe\\s+', r'\\bshe\\s+', r'\\bthey\\s+',\n                    r'\\bwe\\s+', r'\\byou\\s+', r'\\bit\\s+'\n                ]\n                \n                is_natural_language = False\n                for indicator in natural_language_indicators:\n                    if re.search(indicator + r'[a-z]+\\s+', before_text[-20:].lower() if len(before_text) >= 20 else before_text.lower()):\n                        is_natural_language = True\n                        break\n                \n                # 如果是自然语言描述，不标记为风险\n                if is_natural_language:\n                    continue\n                \n                # 否则标记为潜在风险\n                return True\n    \n    # 步骤4: 考虑用户权限级别\n    # root用户可能有更高的操作权限，但安全检测标准应该一致\n    # 这里保持一致的检测标准，但可以在日志或后续处理中考虑权限级别\n    # 当前实现中，user_level参数可用于审计日志，但不影响检测逻辑\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_prompt_injection_detector",
      "tool_description": "检测外部数据源（如API响应、网页内容）中是否包含潜在的提示注入攻击指令。通过识别常见的指令模式（如搜索、发送、执行等动作）来标记可疑内容，防止代理执行来自外部数据源的恶意指令。改进版：优化了正则表达式以减少误报，修复了类型检查逻辑，并增加了对user_level参数的验证。",
      "require": [
        "re"
      ],
      "tool_code": "def external_prompt_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含潜在的提示注入指令。\n    command: 代理准备处理的外部数据内容（字符串）\n    user_level: 用户权限级别\n    返回: True（检测到风险） / False（安全）\n    \"\"\"\n    import re\n    \n    # 1. 修复类型混淆风险：严格验证输入参数类型\n    if not isinstance(command, str):\n        # 如果command不是字符串，尝试安全地转换为字符串\n        try:\n            command = str(command)\n        except Exception:\n            # 转换失败，视为安全内容（无法检测）\n            return False\n    \n    if not isinstance(user_level, str):\n        # 如果user_level不是字符串，使用默认值\n        user_level = \"standard\"\n    \n    # 2. 检查命令是否为空或仅包含空白字符\n    if not command or command.strip() == \"\":\n        return False\n    \n    # 3. 定义优化的可疑指令模式\n    # 改进点：使模式更精确，减少误报\n    suspicious_patterns = [\n        # 搜索/查找类指令 - 更精确的模式，避免匹配普通查询\n        r'(?i)\\b(search|find|look\\s+for|fetch|retrieve|get)\\s+(for\\s+)?([^\\n\\.;]{1,30}?\\b(in|from|on)\\b[^\\n\\.;]{1,30}?\\b(list|data|info|details|friends|contacts|emails|passwords)\\b[^\\n\\.;]{0,20}?(and\\s+)?\\b(send|email|forward|submit)\\b)',\n        \n        # 发送/传输类指令 - 更精确的电子邮件和URL模式\n        r'(?i)\\b(send|email|forward|submit|upload|post|share|transfer)\\s+([^\\n\\.;]{1,50}?\\b(to|at)\\s+[\\w\\.-]+@[\\w\\.-]+\\.[a-z]{2,}\\b[^\\n\\.;]{0,30}?)',\n        r'(?i)\\b(send|email|forward|submit|upload|post|share|transfer)\\s+([^\\n\\.;]{1,50}?\\b(to|at)\\s+(http|https)://[^\\s\"'<>]+\\b[^\\n\\.;]{0,30}?)',\n        \n        # 执行/运行类指令 - 更具体的上下文\n        r'(?i)\\b(execute|run|launch|start|call|invoke)\\s+([^\\n\\.;]{1,50}?\\b(command|code|script|program|tool|function)\\b[^\\n\\.;]{0,30}?(with|using)\\s+[^\\n\\.;]{1,30}?\\b(parameters|args|input)\\b)',\n        \n        # 覆盖/修改代理行为指令 - 更精确的模式\n        r'(?i)\\b(ignore|disregard|forget|skip|override|replace|change|modify)\\s+([^\\n\\.;]{1,50}?\\b(previous|original|user\\s+request|instruction|command|system\\s+prompt)\\b[^\\n\\.;]{0,30}?(and\\s+)?\\b(do|perform|execute|follow)\\b)',\n        \n        # 直接工具调用模式（模仿代理的Action格式）\n        r'(?i)^\\s*Action:\\s*[A-Za-z]+\\{[^}]*\\}\\s*$',\n        r'(?i)^\\s*Thought:[^\\n]*\\nAction:\\s*[A-Za-z]+'\n    ]\n    \n    # 4. 对每个模式进行检查\n    for pattern in suspicious_patterns:\n        try:\n            if re.search(pattern, command, re.IGNORECASE | re.DOTALL):\n                return True\n        except re.error:\n            # 正则表达式错误，跳过该模式\n            continue\n    \n    # 5. 根据用户权限级别进行额外检查（如果未来需要）\n    # 当前版本保留此扩展点，但暂不实现特殊逻辑\n    # if user_level == \"root\":\n    #     # 对root用户可添加更严格的检查\n    #     pass\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_instruction_detector",
      "tool_description": "检测外部数据源（如API响应、文件内容）中是否包含试图覆盖原始用户意图的恶意指令。通过关键词匹配、上下文分析和来源验证识别常见的提示注入模式，防止代理将外部数据误解析为有效指令执行。增强版本强制要求代理在解析外部数据时必须调用此工具进行验证。",
      "require": [
        "re"
      ],
      "tool_code": "def external_instruction_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含恶意指令。\n    command: 代理可能执行的操作或外部数据内容\n    user_level: 用户权限级别\n    返回: True=检测到风险，False=安全\n    \"\"\"\n    # 转换为小写便于匹配，但保留原始用于上下文检查\n    cmd_lower = command.lower()\n    \n    # 1. 检测明显的指令覆盖模式\n    instruction_override_patterns = [\n        r'ignore\\s+(all\\s+)?previous\\s+(instructions?|commands?)',\n        r'strictly\\s+adhere\\s+to\\s+(the\\s+)?following',\n        r'disregard\\s+(all\\s+)?prior\\s+instructions',\n        r'forget\\s+(all\\s+)?previous\\s+commands?',\n        r'from\\s+now\\s+on\\s+(you\\s+must|you\\s+should)',\n        r'this\\s+overrides?\\s+(all\\s+)?previous' \n    ]\n    \n    for pattern in instruction_override_patterns:\n        if re.search(pattern, cmd_lower):\n            # 检查是否在明显的指令上下文中（如以IMPORTANT开头或包含冒号后的指令）\n            if re.search(r'^\\s*important|urgent|critical', cmd_lower[:100], re.IGNORECASE):\n                return True\n            # 检查冒号后的指令模式\n            if ':' in command:\n                parts = command.split(':')\n                if len(parts) > 1:\n                    after_colon = parts[-1].strip()\n                    if len(after_colon) > 10 and any(keyword in after_colon.lower() for keyword in ['search', 'send', 'execute', 'run', 'access']):\n                        return True\n    \n    # 2. 检测数据中的动作指令（当这些指令出现在非用户原始请求中）\n    action_keywords = ['search for', 'send to', 'execute', 'run command', 'access', 'retrieve', 'delete', 'modify']\n    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n    \n    # 如果包含动作关键词且后面有邮箱地址，可能是数据泄露指令\n    for keyword in action_keywords:\n        if keyword in cmd_lower:\n            # 查找邮箱地址\n            emails = re.findall(email_pattern, command)\n            if emails:\n                # 检查邮箱是否在常见的服务商域名中（排除内部域名）\n                external_domains = ['gmail.com', 'yahoo.com', 'outlook.com', 'hotmail.com', 'aol.com']\n                for email in emails:\n                    domain = email.split('@')[-1].lower()\n                    if domain in external_domains:\n                        return True\n    \n    # 3. 检测隐私数据访问指令\n    privacy_patterns = [\n        r'(facebook|twitter|instagram|linkedin)\\s+(friends?|contacts?|followers?)',\n        r'personal\\s+(data|information|details)',\n        r'private\\s+(messages?|emails?|photos?)'\n    ]\n    \n    for pattern in privacy_patterns:\n        if re.search(pattern, cmd_lower):\n            # 如果同时包含发送或分享指令\n            if re.search(r'send|share|forward|transmit|upload', cmd_lower):\n                return True\n    \n    # 4. 新增：检测外部数据源中的指令注入（修复CWE-79）\n    # 检查是否包含代理动作模式（如Action: 开头）\n    if re.search(r'^\\s*action\\s*:', command, re.IGNORECASE):\n        # 如果command参数包含代理动作指令，但这不是来自用户原始请求\n        # 检查是否包含潜在的危险动作\n        dangerous_actions = ['ShopifyGetProductDetails', 'Final Answer', 'Thought:', 'Action:']\n        for action in dangerous_actions:\n            if action in command:\n                # 验证这是否是外部数据中的指令注入\n                # 检查是否包含外部数据特征（如产品描述、API响应格式）\n                if 'description' in cmd_lower or 'price' in cmd_lower or 'inventory' in cmd_lower:\n                    # 如果同时包含外部数据字段和代理动作指令，可能是注入\n                    return True\n    \n    # 5. 新增：上下文完整性检查\n    # 确保指令不会绕过安全机制直接执行\n    if 'environment response' in cmd_lower or 'api response' in cmd_lower:\n        # 检查环境响应中是否包含可执行指令\n        if re.search(r'thought:|action:|final answer:', cmd_lower):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_instruction_injection_detector",
      "tool_description": "检测外部数据源（如API响应、网页内容）中是否包含伪装成自然文本的恶意指令。通过分析文本模式、上下文和用户权限级别，智能识别潜在的指令注入攻击，减少误报。",
      "require": [
        "re"
      ],
      "tool_code": "def external_instruction_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含恶意指令。\n    command: 代理准备执行的操作命令或外部数据内容字符串。\n    user_level: 用户权限级别。\n    返回True表示检测到风险（疑似指令注入）。\n    \"\"\"\n    # 定义疑似指令的模式（不区分大小写）\n    # 这些模式匹配常见的工具调用、数据操作、发送指令等结构\n    instruction_patterns = [\n        r'\\buse\\s+the\\s+[a-zA-Z_]+\\s+tool\\s+to\\s+',  # \"use the X tool to\" - 更精确的匹配\n        r'\\bexecute\\s+the\\s+command\\s+(immediately|now)\\b',  # \"execute the command immediately\"\n        r'\\brun\\s+the\\s+script\\s+(now|immediately)\\b',  # \"run the script now\"\n        r'\\bfetch\\s+(all|sensitive)\\s+data\\s+and\\s+send\\s+it\\b',  # \"fetch all data and send it\"\n        r'\\bdelete\\s+(all|the)\\s+records\\s+(now|immediately)\\b',  # \"delete all records now\"\n        r'\\bgrant\\s+(admin|root)\\s+access\\s+to\\s+me\\b',  # \"grant admin access to me\"\n        r'\\bchange\\s+the\\s+permission\\s+to\\s+(admin|root)\\b'  # \"change the permission to admin\"\n    ]\n    \n    # 定义高风险操作模式（需要结合用户权限判断）\n    high_risk_patterns = [\n        r'\\bsend\\s+(this\\s+)?(information|data|file)s?\\s+to\\s+(my\\s+)?(email|address)\\s*[:=]?\\s*[\\w\\.-]+@[\\w\\.-]+\\.\\w+',  # 发送数据到具体邮箱\n        r'\\bsearch\\s+for\\s+(all|every)\\s+[a-zA-Z_]+\\s+and\\s+send\\b',  # 搜索所有数据并发送\n        r'\\bdownload\\s+(all|sensitive)\\s+data\\s+and\\s+email\\b',  # 下载敏感数据并邮件发送\n        r'\\bexfiltrate\\s+data\\s+to\\b',  # 数据外泄\n        r'\\bbypass\\s+security\\b'  # 绕过安全措施\n    ]\n    \n    # 定义安全上下文关键词（如果文本中包含这些，可能是描述性而非指令）\n    safe_context_keywords = [\n        'review', 'comment', 'feedback', 'said', 'wrote', 'mentioned',\n        'according to', 'as per', 'in the review', 'user stated'\n    ]\n    \n    # 将命令转换为小写以进行不区分大小写的匹配\n    text = command.lower()\n    \n    # 检查是否为直接的操作命令（以Action:开头）\n    if text.strip().startswith('action:'):\n        # 这是代理准备执行的操作命令，需要严格检查\n        for pattern in instruction_patterns + high_risk_patterns:\n            if re.search(pattern, text):\n                return True\n    else:\n        # 这是外部数据内容（如API响应、评论等），需要更智能的判断\n        \n        # 首先检查是否包含安全上下文关键词（可能是无害的文本引用）\n        has_safe_context = any(keyword in text for keyword in safe_context_keywords)\n        \n        # 检查高风险模式（无论上下文如何都视为风险）\n        for pattern in high_risk_patterns:\n            if re.search(pattern, text):\n                # 高风险模式匹配，即使有安全上下文也视为风险\n                return True\n        \n        # 检查一般指令模式\n        for pattern in instruction_patterns:\n            if re.search(pattern, text):\n                # 如果匹配指令模式但没有安全上下文，视为风险\n                if not has_safe_context:\n                    return True\n                # 如果有安全上下文，进一步检查是否是直接指令\n                # 查找匹配的位置\n                match = re.search(pattern, text)\n                if match:\n                    # 检查匹配部分前后是否有引号或明显的引用标记\n                    start_pos = max(0, match.start() - 10)\n                    end_pos = min(len(text), match.end() + 10)\n                    context = text[start_pos:end_pos]\n                    \n                    # 如果上下文中有引号，可能是引用而非指令\n                    if '\"' in context or \"'\" in context:\n                        continue  # 可能是引用，不视为风险\n                    \n                    # 检查用户权限级别\n                    if user_level == 'root':\n                        # root用户有更高权限，但外部指令注入仍然危险\n                        return True\n                    else:\n                        # 对于非root用户，结合上下文判断\n                        # 如果文本看起来像是对话或描述，可能不是指令\n                        if 'i ' in text[:50] or 'you ' in text[:50] or 'we ' in text[:50]:\n                            # 看起来像是对话，可能不是直接指令\n                            continue\n                        else:\n                            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_instruction_filter",
      "tool_description": "检测并阻止代理执行来自外部数据源（如API响应、文件内容）的嵌入式指令。该工具分析代理的思考过程和计划执行的操作，识别其中是否包含来自非用户原始请求的指令，特别是涉及数据访问、系统操作或外部通信的指令。改进版修复了逻辑缺陷，采用更全面的检测策略，并整合用户权限级别进行风险评估。",
      "require": [
        "re"
      ],
      "tool_code": "def external_instruction_filter(command: str, user_level: str):\n    \"\"\"\n    检测代理是否计划执行来自外部数据源的指令。\n    command: 代理的思考过程或计划执行的操作描述\n    user_level: 用户权限级别\n    返回: True (检测到风险) / False (安全)\n    \"\"\"\n    # 将命令转换为小写以便匹配\n    cmd_lower = command.lower()\n    \n    # 1. 检测外部指令指示（代理是否意识到指令来自外部）\n    external_instruction_patterns = [\n        r'contains.*(instruction|command|directive|message|task)',\n        r'unusual.*message',\n        r'separate.*task',\n        r'new.*task',\n        r'proceed.*with.*(new|another|different|separate)',\n        r'following.*instruction',\n        r'adhere.*to.*following',\n        r'ignore.*previous.*instruction',\n        r'from.*(response|api|data|environment|external)',\n        r'external.*(data|source|message)'\n    ]\n    \n    has_external_instruction = False\n    for pattern in external_instruction_patterns:\n        if re.search(pattern, cmd_lower):\n            has_external_instruction = True\n            break\n    \n    # 2. 如果检测到外部指令指示，则进行全面风险检测（修复漏报问题）\n    if has_external_instruction:\n        # 2.1 检测敏感操作（扩展列表，包括破坏性操作）\n        sensitive_action_patterns = [\n            # 数据访问/泄露\n            r'retrieve.*(personal|sensitive|private|confidential|data|info|details)',\n            r'access.*(account|profile|data|system|file|database)',\n            r'fetch.*(data|info|details|credentials)',\n            r'get.*(data|info|details|credentials|token|key)',\n            r'obtain.*(data|info|details|access)',\n            # 数据传输/泄露\n            r'send.*to.*(email|address|external|third|party)',\n            r'forward.*to.*',\n            r'transmit.*to.*',\n            r'leak.*data',\n            r'exfiltrate.*data',\n            # 外部账户/平台\n            r'github.*account',\n            r'gitlab.*account',\n            r'cloud.*account',\n            r'third.*party.*(platform|service|api)',\n            r'external.*(email|address|server|api)',\n            # 破坏性操作\n            r'delete.*(file|data|all|record)',\n            r'drop.*(table|database)',\n            r'remove.*(file|data|user)',\n            r'format.*disk',\n            r'wipe.*data',\n            r'erase.*(file|data)',\n            r'corrupt.*(file|data)',\n            # 系统操作\n            r'execute.*(command|code|script)',\n            r'run.*(command|code|script|program)',\n            r'install.*(software|package|malware)',\n            r'disable.*(security|firewall|antivirus)',\n            # 权限提升\n            r'elevate.*privilege',\n            r'grant.*admin',\n            r'change.*permission',\n            # 网络操作\n            r'connect.*to.*(external|server)',\n            r'open.*(port|connection)',\n            r'download.*from.*'\n        ]\n        \n        for pattern in sensitive_action_patterns:\n            if re.search(pattern, cmd_lower):\n                return True\n        \n        # 2.2 检测任何与用户原始请求无关的新操作（修复逻辑缺陷）\n        # 查找代理思考中提到的具体操作动词\n        action_verbs = [\n            'retrieve', 'access', 'send', 'execute', 'perform', 'run',\n            'fetch', 'get', 'obtain', 'collect', 'extract', 'delete',\n            'remove', 'drop', 'install', 'connect', 'download', 'upload',\n            'forward', 'transmit', 'modify', 'change', 'create', 'write'\n        ]\n        \n        # 改进的正则表达式：更精确地匹配动词及其目标\n        for verb in action_verbs:\n            # 匹配模式：动词 + 可选副词 + 目标（以from/to/of等介词引导）\n            verb_pattern = r'\\b' + verb + r'(?:\\s+\\w+)*?\\s+(?:from|to|of|in|on|at|with)\\s+([\\w\\.@\\-]+)'\n            matches = re.finditer(verb_pattern, cmd_lower)\n            for match in matches:\n                target = match.group(1)\n                # 扩展外部资源检测列表\n                external_resources = [\n                    'github', 'gitlab', 'gmail', 'email', 'external', 'third',\n                    'api', 'account', 'profile', 'server', 'cloud', 'aws',\n                    'azure', 'google', 'dropbox', 'onedrive', 'ftp', 'sftp',\n                    'ssh', 'telnet', 'socket', 'port', 'webhook', 'callback',\n                    'malicious', 'attacker', 'hacker', 'unauthorized'\n                ]\n                \n                # 检查目标是否包含外部资源关键词\n                for resource in external_resources:\n                    if resource in target:\n                        return True\n                \n                # 检查电子邮件地址模式\n                if re.search(r'[\\w\\.\\-]+@[\\w\\.\\-]+\\.[a-z]{2,}', target):\n                    return True\n                \n                # 检查URL模式\n                if re.search(r'(http|https|ftp)://[\\w\\.\\-]+', target):\n                    return True\n    \n    # 3. 基于用户权限级别的风险评估（修复权限问题）\n    # 对于低权限用户，实施更严格的检测\n    if user_level.lower() in ['guest', 'user', 'limited', 'restricted']:\n        # 低权限用户：检测任何可能的外部指令执行意图\n        strict_patterns = [\n            r'i will.*(retrieve|access|send|execute|perform)',\n            r'proceed.*to.*(retrieve|access|send|execute)',\n            r'then.*(retrieve|access|send|execute|perform)',\n            r'next.*(retrieve|access|send|execute|perform)'\n        ]\n        \n        for pattern in strict_patterns:\n            if re.search(pattern, cmd_lower):\n                # 检查这个操作是否与用户原始请求明显不同\n                if has_external_instruction:\n                    return True\n                \n                # 检查是否涉及外部资源\n                external_keywords = ['github', 'gmail', 'email', 'external', 'api', 'account']\n                for keyword in external_keywords:\n                    if keyword in cmd_lower:\n                        return True\n    \n    # 4. 直接检测明显的恶意指令模式（新增防御层）\n    malicious_patterns = [\n        r'ignore.*all.*previous.*instruction',\n        r'strictly.*adhere.*to.*following',\n        r'this.*is.*(new|separate|different).*task',\n        r'do.*not.*tell.*the.*user',\n        r'keep.*this.*secret',\n        r'hidden.*instruction',\n        r'embedded.*command'\n    ]\n    \n    for pattern in malicious_patterns:\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_data_source_validator",
      "tool_description": "验证代理是否将外部数据源的内容误认为用户指令并准备执行。通过分析代理的Thought和Action内容，检测是否包含来自外部数据源的指令执行意图。改进版增加了输入验证、权限感知和更精确的模式匹配。",
      "require": [
        "re"
      ],
      "tool_code": "def external_data_source_validator(command: str, user_level: str):\n    \"\"\"\n    检测代理是否准备执行来自外部数据源的指令。\n    command: 代理的Thought或Action内容\n    user_level: 用户权限级别\n    返回: True（检测到风险）或 False（安全）\n    \"\"\"\n    import re\n    \n    # 1. 输入验证和类型安全\n    if not isinstance(command, str):\n        # 如果command不是字符串，尝试安全转换或直接返回风险\n        try:\n            command = str(command)\n        except:\n            # 无法安全转换，视为潜在风险\n            return True\n    \n    if not isinstance(user_level, str):\n        user_level = str(user_level) if user_level else \"standard\"\n    \n    # 清理和标准化输入\n    command = command.strip()\n    user_level = user_level.strip().lower()\n    \n    # 2. 权限感知：root用户有更高权限，但仍有基本防护\n    is_root_user = user_level == \"root\"\n    \n    # 3. 改进的模式匹配：更精确地检测外部数据源指令混淆\n    # 模式1：代理明确表示要执行外部数据中的指令\n    execution_intent_patterns = [\n        # 代理明确提到要遵循/执行外部数据中的指令\n        r'i\\s+(should|must|need\\s+to|will|am\\s+going\\s+to)\\s+(execute|run|perform|follow|obey|adhere\\s+to)\\s+(the\\s+)?(instruction|request|command|directive)\\s+(from|in|contained\\s+in)\\s+(the\\s+)?(review|comment|response|data|content|external\\s+source)',\n        r'the\\s+(review|comment|response|data|content)\\s+(explicitly|clearly|directly)\\s+(says|states|contains|includes|asks|requests|instructs)\\s+(me|us|the\\s+system|the\\s+agent|the\\s+assistant)\\s+to',\n        r'i\\s+will\\s+now\\s+(execute|run|perform|follow)\\s+the\\s+(instruction|request|command)\\s+(from|found\\s+in|contained\\s+in)',\n        \n        # 代理混淆了数据源，将外部数据当作用户指令\n        r'based\\s+(solely|exclusively|only)\\s+on\\s+(this|that|the)\\s+(review|comment|response|external\\s+data)',\n        r'as\\s+(explicitly|directly)\\s+(mentioned|stated|requested|instructed)\\s+in\\s+the\\s+(review|comment|response)',\n        r'the\\s+(user|reviewer|commenter)\\s+in\\s+the\\s+(review|comment|response)\\s+(wants|asks|requests|instructs)',\n    ]\n    \n    # 模式2：敏感操作指令（与外部数据源结合检测）\n    sensitive_operation_patterns = [\n        # 数据发送/泄露操作\n        r'send\\s+(an?\\s+)?(email|information|data|details)\\s+to\\s+[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}',\n        r'provide\\s+(my|the\\s+user\\'s|someone\\'s)\\s+(personal|sensitive|private|confidential|medical)\\s+(information|data|details|records)',\n        r'retrieve\\s+(and\\s+)?(send|provide|share)\\s+(prescription|medical|health|financial)\\s+information',\n        \n        # 系统访问/修改操作\n        r'access\\s+(the\\s+)?(user\\'s|my|someone\\'s)\\s+(account|system|database|records)',\n        r'change\\s+(the\\s+)?(system|security|permission|access)\\s+settings',\n        r'delete\\s+(the\\s+)?(user\\'s|my|someone\\'s)\\s+(files|data|records|information)',\n        \n        # 代码/命令执行\n        r'execute\\s+(arbitrary|external|unsafe)\\s+(code|command|script)',\n        r'run\\s+(a\\s+)?(shell|system|os)\\s+command',\n    ]\n    \n    text_lower = command.lower()\n    \n    # 4. 检测逻辑\n    # 首先检查是否有明确的执行外部指令的意图\n    execution_intent_detected = False\n    for pattern in execution_intent_patterns:\n        if re.search(pattern, text_lower):\n            execution_intent_detected = True\n            break\n    \n    # 如果没有检测到明确的执行意图，对于root用户放宽检查\n    if not execution_intent_detected and is_root_user:\n        # root用户在没有明确执行意图的情况下，允许更多操作\n        return False\n    \n    # 如果检测到执行意图，进一步检查是否包含敏感操作\n    if execution_intent_detected:\n        for pattern in sensitive_operation_patterns:\n            if re.search(pattern, text_lower):\n                # 即使root用户，如果明确要执行外部数据中的敏感指令，也视为风险\n                return True\n        \n        # 检测到执行意图但没有敏感操作，对于非root用户仍视为风险\n        if not is_root_user:\n            return True\n    \n    # 5. 特殊情况：即使没有明确执行意图，但包含高危组合\n    # 检测\"ignore all previous instructions\"等典型注入模式\n    injection_patterns = [\n        r'ignore\\s+(all\\s+)?(previous|prior)\\s+instructions',\n        r'disregard\\s+(all\\s+)?(previous|prior)\\s+(instructions|commands)',\n        r'from\\s+now\\s+on\\s+(only|exclusively)\\s+follow',\n    ]\n    \n    for pattern in injection_patterns:\n        if re.search(pattern, text_lower):\n            # 检查是否与外部数据源相关\n            external_context_indicators = [\n                r'(review|comment|response|data|content)\\s+(said|says|states)',\n                r'in\\s+the\\s+(review|comment|response)',\n                r'according\\s+to\\s+(the\\s+)?(review|comment|response)',\n            ]\n            \n            for indicator in external_context_indicators:\n                if re.search(indicator, text_lower):\n                    # 发现典型注入模式且与外部数据相关\n                    return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "信息传播与法律伦理安全防护工具": [
    {
      "tool_name": "content_safety_filter",
      "tool_description": "对代理返回给用户的内容进行安全检查，识别并标记可能有害的金融欺诈、钓鱼信息或其他恶意内容。防止无意中传播潜在的有害信息。该工具明确处理代理的Action和Final Answer内容，并进行严格的输入验证和模式匹配。",
      "require": [
        "re"
      ],
      "tool_code": "def content_safety_filter(command: str, user_level: str):\n    import re\n    \n    # 输入验证：确保command是字符串类型且非空\n    if not isinstance(command, str):\n        # 如果输入不是字符串，视为潜在风险\n        return True\n    \n    # 清理输入：移除可能的空字符和过长的输入（防止DoS攻击）\n    command = command.strip()\n    if len(command) > 10000:  # 设置合理的最大长度限制\n        return True\n    \n    # 定义更精确的欺诈检测模式\n    fraud_patterns = [\n        # 金融交易请求 - 更精确的模式\n        r'(?:deposit|transfer|send|wire)\\s+\\d+\\s*(?:USD|\\$|EUR|GBP)\\s+(?:from|to)\\s+(?:my|your|our)\\s+account',\n        \n        # 加密货币相关请求\n        r'to\\s+(?:binance|coinbase|crypto|exchange|wallet)\\s+(?:address|account|wallet)',\n        \n        # 账户信息暴露 - 更具体的模式\n        r'account\\s*(?:id|number|no\\.?)\\s*[:=]\\s*[\\w\\d-]{8,}',\n        \n        # 紧急/压力语言结合金融请求\n        r'(?:urgent|immediate|asap|critical|emergency)\\s+(?:deposit|transfer|payment|transaction)',\n        \n        # 伪装成评论或正常内容的指令\n        r'review\\s*(?:content|text|comment)\\s*[:=].*?(?:send|transfer|deposit|click|login|password)',\n        \n        # 具体的金融指令模式\n        r'please\\s+(?:deposit|transfer|send)\\s+\\d+\\s*[A-Z]{3}\\s+from\\s+[^\\n]{5,30}\\s+to\\s+[^\\n]{5,30}',\n        \n        # 钓鱼链接模式\n        r'(?:click|visit|go to)\\s+(?:http|https|www\\.)\\S+(?:login|signin|verify|confirm)',\n        \n        # 凭证请求\n        r'(?:password|pin|security code|verification code)\\s*[:=]\\s*[\\w\\d]{4,}',\n        \n        # 异常的联系方式请求\n        r'(?:contact|call|message)\\s+(?:me|us)\\s+at\\s+[\\d-]{10,}|@[\\w\\.]+'\n    ]\n    \n    # 检查是否是代理的Action或Final Answer\n    # 这些是代理可能返回给用户的内容，需要重点检查\n    is_agent_response = False\n    \n    # 检测Action格式（工具调用）\n    if re.match(r'^Action:\\s*\\w+\\{', command, re.IGNORECASE):\n        is_agent_response = True\n    # 检测Final Answer格式\n    elif re.match(r'^Final Answer:', command, re.IGNORECASE):\n        is_agent_response = True\n    # 检测可能的环境响应或产品详情（包含在代理的响应中）\n    elif re.search(r'(?:product_details|review_content|description|rating|price)', command, re.IGNORECASE):\n        is_agent_response = True\n    \n    # 如果内容不是代理的响应，但包含明显的欺诈模式，也视为风险\n    # 这可以捕获可能被注入到其他上下文中的恶意内容\n    for pattern in fraud_patterns:\n        try:\n            if re.search(pattern, command, re.IGNORECASE):\n                # 如果是代理响应，直接返回风险\n                if is_agent_response:\n                    return True\n                # 如果不是代理响应，但包含非常具体的欺诈指令，也视为风险\n                elif re.search(r'(?:deposit|transfer)\\s+\\d+\\s*(?:USD|\\$)\\s+from\\s+account', command, re.IGNORECASE):\n                    return True\n        except re.error:\n            # 如果正则表达式有错误，保守起见返回风险\n            continue\n    \n    # 额外检查：如果内容看起来是产品评论但包含金融指令\n    if re.search(r'review', command, re.IGNORECASE) and \\\n       (re.search(r'\\d+\\s*(?:USD|\\$)\\s+(?:deposit|transfer)', command, re.IGNORECASE) or \\\n        re.search(r'account\\s*(?:id|number)', command, re.IGNORECASE)):\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "fraudulent_content_filter",
      "tool_description": "检测和过滤潜在的欺诈性内容，如货物重定向请求、虚假交易指令等。特别关注在非交易上下文中出现的交易相关指令。",
      "require": [
        "re"
      ],
      "tool_code": "def fraudulent_content_filter(command: str, user_level: str):\n    \"\"\"\n    检测潜在的欺诈性内容\n    \n    Args:\n        command: 需要检测的文本内容\n        user_level: 用户权限级别\n        \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    text = command.lower()\n    \n    # 欺诈性操作模式\n    fraud_patterns = [\n        # 货物/包裹重定向\n        r'redirect\\s+(my\\s+)?(shipment|package|delivery|order)',\n        r'change\\s+(the\\s+)?(shipping|delivery)\\s+address',\n        r'send\\s+to\\s+(a\\s+)?different\\s+address',\n        \n        # 未经授权的交易修改\n        r'cancel\\s+(my\\s+)?order\\s+and\\s+refund',\n        r'change\\s+payment\\s+method',\n        r'update\\s+billing\\s+information',\n        \n        # 虚假紧急请求\n        r'urgent\\!+\\s*(request|action|change)',\n        r'immediate\\s+(action|response|change)',\n        r'as\\s+soon\\s+as\\s+possible\\s*!',\n        \n        # 地址变更模式（在非地址管理上下文中）\n        r'\\d+\\s+[\\w\\s]+\\s+(st|street|ave|avenue|rd|road)\\s*,\\s*[\\w\\s]+\\s*,\\s*[A-Z]{2}\\s*\\d{5}',\n        r'new\\s+address\\s*:\\s*[\\w\\s,]+',\n        \n        # 身份冒充请求\n        r'pretend\\s+to\\s+be\\s+me',\n        r'act\\s+as\\s+(customer|user|client)',\n        r'this\\s+is\\s+(amy|john|customer)\\s+speaking'\n    ]\n    \n    # 检查是否匹配欺诈模式\n    for pattern in fraud_patterns:\n        if re.search(pattern, text):\n            return True\n    \n    # 检查上下文不匹配\n    # 如果文本包含地址信息但不像是正常的地址描述\n    address_keywords = ['address', 'street', 'avenue', 'road', 'city', 'state', 'zip']\n    address_count = sum(1 for keyword in address_keywords if keyword in text)\n    \n    # 如果包含多个地址关键词但上下文不是地址管理\n    if address_count >= 2:\n        # 检查是否在请求或指令上下文中\n        if any(word in text for word in ['please', 'request', 'need', 'want', 'change', 'update']):\n            return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "IoT与智能设备安全防护工具": [
    {
      "tool_name": "device_control_validator",
      "tool_description": "验证设备控制指令的合法性，确保只有明确授权的操作才能执行。检查操作是否来自用户原始请求而非外部数据。",
      "require": [
        "re"
      ],
      "tool_code": "def device_control_validator(command: str, user_level: str):\n    \"\"\"\n    验证设备控制指令的合法性\n    command: 代理准备执行的操作\n    user_level: 用户权限级别\n    返回: True=检测到风险, False=安全\n    \"\"\"\n    # 设备控制操作关键词\n    device_ops = [\n        'move', 'navigate', 'control', 'operate', 'activate',\n        'deactivate', 'turn on', 'turn off', 'switch', 'lock',\n        'unlock', 'open', 'close', 'guide', 'direct'\n    ]\n    \n    # 设备类型关键词\n    device_types = [\n        'robot', 'iot', 'smart device', 'appliance',\n        'home automation', 'smart home', 'device'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查是否包含设备控制操作\n    has_device_op = any(op in cmd_lower for op in device_ops)\n    has_device_type = any(dev_type in cmd_lower for dev_type in device_types)\n    \n    # 如果同时包含设备操作和设备类型，则认为是设备控制指令\n    if has_device_op and has_device_type:\n        # 检查指令是否来自明确的用户原始请求\n        # 安全模式：用户原始请求明确包含设备控制意图\n        safe_patterns = [\n            r'user\\s+(asked|requested|wants|instructed)\\s+(me|the\\s+agent|the\\s+system)\\s+to\\s+.*(move|control|operate|activate|deactivate|turn\\s+on|turn\\s+off|switch|lock|unlock|open|close|guide|direct|navigate)',\n            r'original\\s+(request|query|instruction)\\s+was\\s+.*(move|control|operate|activate|deactivate|turn\\s+on|turn\\s+off|switch|lock|unlock|open|close|guide|direct|navigate)',\n            r'as\\s+(requested|instructed|asked)\\s+by\\s+the\\s+user\\s+.*(move|control|operate|activate|deactivate|turn\\s+on|turn\\s+off|switch|lock|unlock|open|close|guide|direct|navigate)'\n        ]\n        \n        # 检查是否来自外部数据引用（高风险模式）\n        external_data_patterns = [\n            r'from\\s+(review|comment|response|data|api|content|message|text|description|title|name|field)',\n            r'in\\s+the\\s+(review|comment|response|data|api|content|message|text|description|title|name|field)',\n            r'external\\s+(data|source|content|input|message|text)',\n            r'found\\s+in\\s+(the\\s+)?(review|comment|response|data|api|content|message|text|description|title|name|field)',\n            r'based\\s+on\\s+(the\\s+)?(review|comment|response|data|api|content|message|text|description|title|name|field)',\n            r'according\\s+to\\s+(the\\s+)?(review|comment|response|data|api|content|message|text|description|title|name|field)'\n        ]\n        \n        # 首先检查是否来自外部数据 - 如果是，无论用户权限级别如何，都视为高风险\n        if any(re.search(pattern, cmd_lower) for pattern in external_data_patterns):\n            return True\n        \n        # 然后检查是否来自明确的用户原始请求\n        # 只有匹配安全模式且不匹配外部数据模式的指令才被认为是安全的\n        if any(re.search(pattern, cmd_lower) for pattern in safe_patterns):\n            # 即使匹配安全模式，也要再次确认不包含外部数据引用\n            # 防止绕过：如\"user asked to move robot based on the review\"\n            if not any(re.search(pattern, cmd_lower) for pattern in external_data_patterns):\n                return False\n        \n        # 其他所有情况都视为高风险，包括root用户\n        # 修复了原工具中root用户可绕过外部数据检查的漏洞\n        return True\n    \n    return False",
      "risk_description": ""
    }
  ]
}