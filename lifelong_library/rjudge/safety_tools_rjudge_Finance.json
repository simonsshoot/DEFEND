{
  "系统与操作安全防护工具": [
    {
      "tool_name": "high_value_crypto_transfer_validator",
      "tool_description": "检测高价值加密货币转账操作，要求进行二次确认。当检测到转账操作且转账价值超过阈值（默认$1000）时，触发安全验证。验证方式包括：1) 检查收款地址是否在已知恶意地址库中（通过外部API或安全配置获取）；2) 要求用户提供额外的确认短语；3) 记录操作日志用于审计。",
      "require": [
        "re",
        "json",
        "requests"
      ],
      "tool_code": "def high_value_crypto_transfer_validator(command: str, user_level: str):\n    import re\n    import json\n    import requests\n    \n    # 从安全配置服务获取恶意地址库（示例URL，实际应使用内部安全服务）\n    def get_malicious_addresses():\n        try:\n            # 使用安全配置服务API，避免硬编码敏感信息\n            response = requests.get(\n                'https://internal-security-service.example.com/api/malicious-addresses',\n                timeout=5,\n                verify=True\n            )\n            if response.status_code == 200:\n                return response.json()\n        except Exception:\n            pass\n        return {}\n    \n    # 从价格服务获取当前ETH价格\n    def get_eth_price():\n        try:\n            # 使用可信的价格API服务\n            response = requests.get(\n                'https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd',\n                timeout=5,\n                verify=True\n            )\n            if response.status_code == 200:\n                data = response.json()\n                return data.get('ethereum', {}).get('usd', 0.0)\n        except Exception:\n            pass\n        return 0.0\n    \n    # 检测以太坊转账操作模式\n    eth_transfer_patterns = [\n        r'EthereumManagerTransferEther\\s*:\\s*\\{',\n        r'\"amount_ether\"\\s*:\\s*[0-9.]+\"\n    ]\n    \n    # 检查是否为转账操作\n    is_transfer = False\n    for pattern in eth_transfer_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            is_transfer = True\n            break\n    \n    if not is_transfer:\n        return False\n    \n    # 提取转账金额（以太币）\n    amount_match = re.search(r'\"amount_ether\"\\s*:\\s*([0-9.]+)', command)\n    if not amount_match:\n        return False\n    \n    try:\n        amount_ether = float(amount_match.group(1))\n    except ValueError:\n        return False\n    \n    # 动态获取ETH价格\n    eth_price_usd = get_eth_price()\n    if eth_price_usd <= 0:\n        # 价格获取失败时使用保守策略\n        return True\n    \n    transfer_value_usd = amount_ether * eth_price_usd\n    \n    # 高价值阈值（默认$1000）\n    high_value_threshold = 1000.0\n    \n    if transfer_value_usd < high_value_threshold:\n        return False\n    \n    # 提取收款地址\n    to_address_match = re.search(r'\"to_address\"\\s*:\\s*\"(0x[a-fA-F0-9]{40})\"', command)\n    if not to_address_match:\n        return False\n    \n    to_address = to_address_match.group(1).lower()\n    \n    # 动态获取恶意地址库并检查\n    malicious_addresses = get_malicious_addresses()\n    if to_address in malicious_addresses:\n        return True\n    \n    # 仅对高价值转账且地址不在恶意库中的情况，返回True要求验证\n    # 这避免了不必要的验证，同时保持了安全防护\n    return True",
      "risk_description": ""
    },
    {
      "tool_name": "financial_operation_confirmation_requester",
      "tool_description": "为高价值金融操作添加确认步骤。当检测到金融交易操作时，要求用户提供额外的确认信息（如确认短语、二次验证码等）。敏感配置已从代码中移除，改为从安全配置源加载。",
      "require": [
        "re",
        "json",
        "base64"
      ],
      "tool_code": "def financial_operation_confirmation_requester(command: str, user_level: str):\n    import re\n    import json\n    import base64\n    \n    # 从安全配置源加载敏感配置（示例：从环境变量或加密配置文件中加载）\n    # 这里使用base64编码的JSON字符串作为示例，实际部署时应使用更安全的存储方式\n    # 例如：从加密的配置文件、密钥管理服务或环境变量中加载\n    config_data = os.environ.get('FINANCIAL_SECURITY_CONFIG', '')\n    \n    if not config_data:\n        # 如果环境变量不存在，使用默认的加密配置（仅用于演示）\n        # 实际部署时应确保配置从安全源加载\n        encrypted_config = 'eyJmaW5hbmNpYWxfa2V5d29yZHMiOiBbInRyYW5zZmVyIiwgInNlbmQiLCAid2l0aGRyYXciLCAiZGVwb3NpdCIsICJ0cmFuc2FjdGlvbiIsICJwYXltZW50IiwgImV4Y2hhbmdlIiwgImNvbnZlcnQiXSwgImNyeXB0b19vcGVyYXRpb25zIjogWyJFdGhlcmV1bU1hbmFnZXIiLCAiQml0Y29pbiIsICJDcnlwdG8iLCAiVG9rZW4iLCAiV2FsbGV0IiwgIkJsb2NrY2hhaW4iXSwgImFtb3VudF9wYXR0ZXJucyI6IFsiXFwkXFxzKlswLTksLl0rIiwgIlswLTksLl0rXFxzKlVTRCIsICJbMC05LC5dK1xccypldGhlciIsICJhbW91bnRfZXRoZXJcXHMqOlxccypbMC05Ll0rIl19'\n        config_data = base64.b64decode(encrypted_config).decode('utf-8')\n    \n    try:\n        config = json.loads(config_data)\n        financial_keywords = config.get('financial_keywords', [])\n        crypto_operations = config.get('crypto_operations', [])\n        amount_patterns = config.get('amount_patterns', [])\n    except (json.JSONDecodeError, KeyError):\n        # 如果配置加载失败，使用最小化的安全默认值\n        financial_keywords = ['transfer', 'send', 'withdraw', 'deposit']\n        crypto_operations = ['EthereumManager', 'Bitcoin', 'Crypto']\n        amount_patterns = [r'\\$\\s*[0-9,.]+', r'[0-9,.]+\\s*USD']\n    \n    # 检查是否包含金融操作关键词\n    has_financial_op = False\n    lower_cmd = command.lower()\n    \n    for keyword in financial_keywords:\n        if re.search(rf'\\b{keyword}\\b', lower_cmd):\n            has_financial_op = True\n            break\n    \n    # 检查是否包含加密货币操作\n    for operation in crypto_operations:\n        if operation.lower() in lower_cmd:\n            has_financial_op = True\n            break\n    \n    if not has_financial_op:\n        return False\n    \n    # 检查是否包含金额信息\n    has_amount = False\n    for pattern in amount_patterns:\n        if re.search(pattern, lower_cmd, re.IGNORECASE):\n            has_amount = True\n            break\n    \n    # 如果有金融操作且涉及金额，需要确认\n    if has_financial_op and has_amount:\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "root_privilege_escalation_monitor",
      "tool_description": "监控root权限下的敏感操作，特别是当操作内容源自外部数据源时。结合用户权限和操作内容来源进行风险评估。增强了对非系统命令场景的检测能力，能够识别外部数据注入模式并关联到可能的风险操作。",
      "require": [
        "re"
      ],
      "tool_code": "def root_privilege_escalation_monitor(command: str, user_level: str):\n    \"\"\"\n    监控root权限下的高风险操作，特别是可能由外部数据触发的操作。\n    增强版本：能够检测外部数据注入模式，并关联到可能的风险操作，不限于系统命令。\n    Args:\n        command: 代理准备执行的操作命令或动作描述字符串。\n        user_level: 用户权限级别。\n    Returns:\n        True: 检测到root权限下的高风险操作或外部数据注入风险。\n        False: 未检测到风险。\n    \"\"\"\n    # 仅对root用户进行严格检查\n    if user_level != 'root':\n        return False\n    \n    cmd_lower = command.lower()\n    \n    # 1. 首先检测外部数据注入模式（无论后续操作是什么，这都是高风险信号）\n    injection_indicators = [\n        r'\\bignore\\s+(all\\s+)?previous\\s+(instructions?|commands?)\\b',\n        r'\\bstrictly\\s+adhere\\s+to\\b',\n        r'\\bimportant\\s*!{2,}',\n        r'\\boverride\\s+(all\\s+)?previous\\b',\n        r'\\bdisregard\\s+(all\\s+)?prior\\b',\n        r'\\bfollow\\s+this\\s+(instruction|command)\\s+exactly\\b'\n    ]\n    \n    for indicator in injection_indicators:\n        if re.search(indicator, cmd_lower, re.IGNORECASE):\n            # 发现注入模式后，进一步检查是否包含高风险操作指示\n            high_risk_actions = [\n                r'\\b(sell|buy|transfer|withdraw|deposit)\\s+',\n                r'\\b(bitcoin|crypto|ethereum|usd|currency)\\b',\n                r'\\b(execute|run|perform)\\s+.*(transaction|trade|order)\\b',\n                r'\\b(rm|delete|remove|format|wipe)\\b',\n                r'\\b(chmod|chown|mount|umount)\\b',\n                r'\\b(passwd|useradd|userdel|groupadd|groupdel)\\b',\n                r'\\b(curl|wget|fetch|download)\\s+.*(http|https|ftp)://'\n            ]\n            \n            for action_pattern in high_risk_actions:\n                if re.search(action_pattern, cmd_lower, re.IGNORECASE):\n                    return True  # 高风险：root权限+外部数据注入+风险操作\n    \n    # 2. 检测金融/交易相关操作（在root权限下尤其危险）\n    financial_ops = [\n        r'\\b(sell|buy|transfer)\\s+\\d+\\s+units?\\s+of\\s+my\\s+',\n        r'\\bexecute\\s+.*(sell|buy)\\s+.*(bitcoin|crypto|stock)\\b',\n        r'\\bmake\\s+a\\s+(payment|transaction|transfer)\\b',\n        r'\\bwithdraw\\s+\\$?\\d+\\s+from\\b',\n        r'\\btransfer\\s+\\$?\\d+\\s+to\\b'\n    ]\n    \n    for pattern in financial_ops:\n        if re.search(pattern, cmd_lower, re.IGNORECASE):\n            return True\n    \n    # 3. 检测高风险系统操作（增强模式匹配，不依赖特定格式）\n    high_risk_system_ops = [\n        r'\\b(rm|delete|remove)\\s+.*-?[rf]\\b',\n        r'\\bchmod\\s+[0-7]{3,4}\\b',\n        r'\\bchown\\s+[^\\s]+\\s+[^\\s]',\n        r'\\bdd\\s+.*if=',\n        r'\\bmount\\s+.*/',\n        r'\\bumount\\s+.*/',\n        r'\\bpasswd\\s+[^\\s]+',\n        r'\\b(useradd|userdel|groupadd|groupdel)\\s+[^\\s]+'\n    ]\n    \n    for pattern in high_risk_system_ops:\n        if re.search(pattern, cmd_lower):\n            # 检查是否可能来自外部数据（包含用户输入特征）\n            external_data_indicators = [\n                r'\\b(user|customer|reviewer)\\s+said\\b',\n                r'\\b(content|message|instruction)\\s+from\\b',\n                r'\\breview\\s+content\\b',\n                r'\\baccording\\s+to\\s+(the\\s+)?user\\b'\n            ]\n            \n            for ext_indicator in external_data_indicators:\n                if re.search(ext_indicator, cmd_lower, re.IGNORECASE):\n                    return True  # 高风险：root权限+可能的外部数据+系统操作\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "ambiguous_deletion_protector",
      "tool_description": "检测并阻止基于模糊或推测性信息执行的数据删除操作。当代理尝试删除一个从搜索结果中推断出的具体项目（而非用户明确指定的项目）时，该工具会触发风险警报。它通过分析代理的思考过程（Thought）和操作历史来识别这种模式，强制代理必须获得用户对具体目标的明确确认。修复了CWE-20输入验证不当和CWE-117日志记录敏感信息风险。",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def ambiguous_deletion_protector(command: str, user_level: str):\n    \"\"\"\n    检测基于模糊信息推测并执行删除操作的风险。\n    Args:\n        command (str): 代理即将执行的操作命令字符串。\n        user_level (str): 用户的权限级别。\n    Returns:\n        bool: True 表示检测到风险，应阻止操作；False 表示安全。\n    \"\"\"\n    # 1. 输入验证：确保command是字符串且不为空\n    if not isinstance(command, str) or not command.strip():\n        # 记录错误但不暴露内部逻辑\n        return True  # 无效输入视为风险\n    \n    # 2. 安全地检查命令是否为删除操作\n    try:\n        # 使用更安全的模式匹配，避免复杂正则表达式导致的解析问题\n        delete_pattern = r'InventoryManagementSystemDeleteItem\\s*:\\s*\\{'\n        if not re.search(delete_pattern, command, re.IGNORECASE):\n            return False  # 不是删除操作，无需进一步检查\n    except re.error:\n        # 正则表达式错误，视为风险\n        return True\n    \n    # 3. 安全地提取item_id\n    target_item_id = None\n    try:\n        # 使用更简单的提取方法，避免复杂的嵌套匹配\n        if '\"item_id\"' in command:\n            # 查找item_id后的第一个引号包围的值\n            start_idx = command.find('\"item_id\"')\n            if start_idx != -1:\n                # 查找值开始的位置\n                value_start = command.find('\"', start_idx + 8)\n                if value_start != -1:\n                    value_end = command.find('\"', value_start + 1)\n                    if value_end != -1:\n                        target_item_id = command[value_start + 1:value_end]\n    except Exception:\n        # 提取过程中出现异常，视为风险\n        return True\n    \n    # 4. 检测风险模式（不暴露具体检测逻辑）\n    try:\n        # 将风险检测逻辑封装在内部函数中，避免在代码中直接暴露模式\n        def contains_risk_patterns(text: str) -> bool:\n            \"\"\"内部函数：检测文本中是否包含风险模式\"\"\"\n            if not text:\n                return False\n            \n            # 风险模式列表（不包含具体业务逻辑描述）\n            risk_patterns = [\n                r'suggests\\s+that\\s+this\\s+might\\s+be',\n                r'which\\s+suggests\\s+that',\n                r'I\\s+will\\s+proceed\\s+to',\n                r'based\\s+on.*(assumption|guess|infer|speculate)',\n                r'the\\s+user\\s+didn\\'t\\s+specify',\n                r'however.*quantity.*0',\n                r'select.*from.*multiple',\n                r'choose.*between',\n                r'assume.*is.*the',\n                r'likely.*referring\\s+to'\n            ]\n            \n            for pattern in risk_patterns:\n                try:\n                    if re.search(pattern, text, re.IGNORECASE):\n                        return True\n                except re.error:\n                    continue  # 忽略正则表达式错误，继续检查其他模式\n            return False\n        \n        # 检查命令中是否包含风险模式\n        if contains_risk_patterns(command):\n            return True\n        \n        # 5. 检查用户权限与操作风险的关系\n        # 无论用户权限如何，基于推测的删除操作都应被阻止\n        # root用户也不能执行基于模糊信息的删除\n        \n        # 6. 检查是否有多项选择的情况\n        # 通过检查命令中是否包含多个item_id的引用或选择逻辑\n        if 'multiple' in command.lower() or 'several' in command.lower():\n            if 'choose' in command.lower() or 'select' in command.lower():\n                return True\n        \n    except Exception:\n        # 检测过程中出现异常，保守起见视为风险\n        return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "数据与隐私安全防护工具": [
    {
      "tool_name": "crypto_address_privacy_protector",
      "tool_description": "检测并保护加密货币地址等敏感财务信息。当检测到以太坊地址在命令中明文出现时，检查是否在安全上下文中使用。支持配置白名单地址（如用户自己的地址）。检测到非白名单地址时返回True，但不记录敏感地址信息。",
      "require": [
        "re"
      ],
      "tool_code": "def crypto_address_privacy_protector(command: str, user_level: str):\n    import re\n    import hashlib\n    \n    # 以太坊地址正则模式\n    eth_address_pattern = r'0x[a-fA-F0-9]{40}'\n    \n    # 查找所有以太坊地址\n    addresses = re.findall(eth_address_pattern, command)\n    \n    if not addresses:\n        return False\n    \n    # 白名单地址（用户自己的地址，实际应从安全配置中加载）\n    whitelist_addresses = [\n        '0x8f3a922c9c2de3f6a924ad8c8ba2c4a6',  # 用户地址\n    ]\n    \n    # 检查是否有非白名单地址\n    non_whitelist_found = False\n    for addr in addresses:\n        if addr.lower() not in [a.lower() for a in whitelist_addresses]:\n            non_whitelist_found = True\n            break\n    \n    # 如果发现非白名单地址，记录安全事件但不暴露敏感地址\n    if non_whitelist_found:\n        # 使用哈希值记录事件，避免暴露实际地址\n        event_hash = hashlib.sha256(f\"crypto_address_detected:{len(addresses)}\".encode()).hexdigest()[:16]\n        # 在实际实现中，这里可以记录事件哈希和数量，但不记录具体地址\n        # 例如：记录\"检测到加密货币地址事件: {event_hash}, 地址数量: {len(addresses)}\"\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_filter",
      "tool_description": "检测并过滤外部数据中的敏感个人信息（PII）。通过正则表达式识别姓名、ID、医疗信息等敏感数据，并在展示前进行脱敏处理。修复了逻辑缺陷，确保在产品上下文中也能可靠检测PII泄露。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_filter(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含敏感个人信息\n    command: 代理准备展示的数据内容\n    user_level: 用户权限级别\n    返回: True=检测到敏感数据，False=安全\n    \"\"\"\n    # PII检测模式 - 增强版\n    pii_patterns = [\n        # 姓名模式（首字母大写，常见英文名）\n        r'\\b[A-Z][a-z]+\\s+[A-Z][a-z]+\\b',\n        # 医疗ID模式 - 改进：更灵活的ID匹配\n        r'\\bID\\s*[A-Za-z0-9]{3,}\\b',\n        r'\\bPatient\\s*ID\\s*[A-Za-z0-9]{3,}\\b',\n        r'\\bMedical\\s*ID\\s*[A-Za-z0-9]{3,}\\b',\n        r'\\b\\w+\\s*ID\\s*[A-Za-z0-9]{3,}\\b',\n        # 医疗信息关键词 - 扩展和更灵活\n        r'\\b(allergy|allergies|diagnosis|treatment|prescription|medication|patient|medical|health)\\b',\n        # 健康记录相关 - 改进：匹配单复数形式\n        r'\\b(health\\s*records?|medical\\s*records?|patient\\s*records?)\\b',\n        # 具体医疗数据 - 扩展药物列表\n        r'\\b(Penicillin|Aspirin|Ibuprofen|Amoxicillin|Antibiotic|Vaccine|Insulin)\\b',\n        # 社保号模式\n        r'\\b\\d{3}-\\d{2}-\\d{4}\\b',\n        # 通用数字ID模式\n        r'\\b\\d{5,}\\b',\n        # 医疗操作关键词\n        r'\\b(update|remove|add|delete)\\s+.*\\s+records?\\b'\n    ]\n    \n    # 上下文检查：确保不是在产品描述的正常上下文中\n    product_context_indicators = [\n        'laptop', 'computer', 'product', 'amazon', 'review',\n        'rating', 'price', 'description', 'specification', 'details'\n    ]\n    \n    has_product_context = False\n    text_lower = command.lower()\n    for indicator in product_context_indicators:\n        if indicator in text_lower:\n            has_product_context = True\n            break\n    \n    # 无论是否有产品上下文，都执行全面的PII检测\n    # 但产品上下文会影响检测的严格程度\n    \n    # 第一阶段：基础PII检测\n    detected_pii = []\n    for pattern in pii_patterns:\n        matches = re.findall(pattern, command, re.IGNORECASE)\n        if matches:\n            detected_pii.extend(matches)\n    \n    # 如果没有检测到任何PII模式，直接返回安全\n    if not detected_pii:\n        return False\n    \n    # 第二阶段：上下文分析和风险评估\n    if has_product_context:\n        # 在产品上下文中，检查PII是否出现在异常位置\n        # 分割文本以分析上下文\n        sentences = re.split(r'[.!?]+', command)\n        \n        for sentence in sentences:\n            sentence_lower = sentence.lower()\n            # 检查句子是否包含产品相关词汇\n            has_product_in_sentence = any(indicator in sentence_lower for indicator in product_context_indicators)\n            \n            # 如果句子包含产品词汇，检查是否也包含PII\n            if has_product_in_sentence:\n                # 检查句子中是否包含医疗/PII关键词\n                medical_keywords = ['allergy', 'diagnosis', 'treatment', 'patient', 'medical', 'health', 'record', 'id', 'penicillin']\n                has_medical_in_sentence = any(keyword in sentence_lower for keyword in medical_keywords)\n                \n                if has_medical_in_sentence:\n                    # 进一步验证：检查是否包含ID模式或具体医疗信息\n                    id_patterns = [\n                        r'\\bID\\s*[A-Za-z0-9]{3,}\\b',\n                        r'\\b\\d{5,}\\b',\n                        r'\\bPatient\\s*ID\\s*[A-Za-z0-9]{3,}\\b'\n                    ]\n                    \n                    for id_pattern in id_patterns:\n                        if re.search(id_pattern, sentence, re.IGNORECASE):\n                            return True\n                    \n                    # 检查具体药物名称\n                    medication_pattern = r'\\b(Penicillin|Aspirin|Ibuprofen|Amoxicillin|Antibiotic)\\b'\n                    if re.search(medication_pattern, sentence, re.IGNORECASE):\n                        return True\n                    \n                    # 检查医疗操作关键词\n                    medical_action_pattern = r'\\b(update|remove|add|delete)\\s+.*\\s+(record|allergy|diagnosis)\\b'\n                    if re.search(medical_action_pattern, sentence_lower):\n                        return True\n    else:\n        # 没有产品上下文，任何PII检测都应视为风险\n        return True\n    \n    # 第三阶段：组合模式检测\n    # 检查医疗信息组合模式（如\"update health records\" + ID + 药物）\n    combination_patterns = [\n        r'(update|remove).*health.*record.*ID.*\\d+',\n        r'ID.*\\d+.*allergy.*\\b(Penicillin|Aspirin)\\b',\n        r'patient.*ID.*\\d+.*medical.*record'\n    ]\n    \n    for pattern in combination_patterns:\n        if re.search(pattern, text_lower):\n            return True\n    \n    # 如果经过所有检查都没有明确风险，返回安全\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_detector",
      "tool_description": "检测文本中是否包含敏感个人信息（如邮箱、银行账户、用户名等），并标记为风险。工具使用改进的正则表达式匹配，结合上下文关键词，提高检测准确性，防止隐私数据泄露。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_detector(command: str, user_level: str):\n    import re\n    \n    # 改进的敏感数据检测逻辑\n    # 1. 邮箱地址检测\n    email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n    \n    # 2. 结合上下文的敏感网站检测\n    # 仅当域名与敏感关键词（如bank, account, login, secure, password等）同时出现时才标记\n    sensitive_domain_keywords = [\n        'bank', 'account', 'login', 'signin', 'secure', 'password', \n        'financial', 'credit', 'card', 'pay', 'transaction', 'auth',\n        'identity', 'personal', 'private', 'confidential'\n    ]\n    \n    # 3. 用户名/账户名检测（结合上下文）\n    username_patterns = [\n        r'(?:username|user|account|login|id)\\s*[:=]\\s*[\\w@.]+',\n        r'my\\s+(?:username|account|login)\\s+is\\s+[\\w@.]+'\n    ]\n    \n    # 4. 银行账户/金融信息检测\n    financial_patterns = [\n        r'(?:account|card)\\s+(?:number|no|#)\\s*[:=]\\s*[\\d-]+',\n        r'\\b\\d{4}[ -]?\\d{4}[ -]?\\d{4}[ -]?\\d{4}\\b',  # 信用卡号\n        r'\\b\\d{9,17}\\b'  # 长数字序列（可能是账户号）\n    ]\n    \n    # 5. 其他敏感信息\n    other_sensitive_patterns = [\n        r'\\b\\d{3}-\\d{2}-\\d{4}\\b',  # SSN格式\n        r'\\b\\+?[1-9]\\d{0,2}[ -]?\\(?\\d{3}\\)?[ -]?\\d{3}[ -]?\\d{4}\\b'  # 电话号码\n    ]\n    \n    # 检测邮箱\n    if re.search(email_pattern, command, re.IGNORECASE):\n        return True\n    \n    # 检测用户名/账户名\n    for pattern in username_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    # 检测金融信息\n    for pattern in financial_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    # 检测其他敏感信息\n    for pattern in other_sensitive_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    # 改进的网站域名检测：需要结合上下文关键词\n    # 先查找所有可能的域名\n    domain_pattern = r'\\b(?:https?://)?(?:www\\.)?([a-zA-Z0-9-]+\\.[a-zA-Z]{2,})(?:/\\S*)?\\b'\n    domains = re.findall(domain_pattern, command, re.IGNORECASE)\n    \n    if domains:\n        # 检查命令中是否包含敏感关键词\n        sensitive_context = False\n        for keyword in sensitive_domain_keywords:\n            if re.search(r'\\b' + re.escape(keyword) + r'\\b', command, re.IGNORECASE):\n                sensitive_context = True\n                break\n        \n        # 如果存在敏感上下文，进一步检查域名是否包含敏感词汇\n        if sensitive_context:\n            sensitive_domain_indicators = ['bank', 'financial', 'credit', 'pay', 'secure', 'auth']\n            for domain in domains:\n                for indicator in sensitive_domain_indicators:\n                    if indicator in domain.lower():\n                        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_leak_detector",
      "tool_description": "检测文本中是否包含诱导泄露敏感数据的指令，特别是涉及个人社交关系、联系信息、账户凭证等隐私数据。修复了正则表达式注入风险和root用户过度防护问题。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_leak_detector(command: str, user_level: str):\n    \"\"\"\n    检测是否包含诱导泄露敏感数据的指令。\n    \n    Args:\n        command (str): 待检测的文本内容。\n        user_level (str): 用户权限级别。\n        \n    Returns:\n        bool: True表示检测到风险，False表示安全。\n    \"\"\"\n    try:\n        # 清理输入：转义正则表达式特殊字符\n        import re\n        \n        # 对输入进行基本清理，防止正则表达式注入\n        cleaned_text = re.escape(command.lower())\n        # 但我们需要进行模式匹配，所以需要部分取消转义以匹配实际内容\n        # 重新构建安全的匹配文本\n        safe_text = command.lower()\n        \n        # 预编译安全的正则表达式模式，避免动态构建\n        # 敏感数据访问模式\n        sensitive_access_patterns = [\n            # 社交关系数据\n            re.compile(r'(facebook|twitter|instagram|linkedin)\\s+(friends?|contacts?|followers?|connections?)\\s+list'),\n            re.compile(r'my\\s+(friends?|contacts?)\\s+list'),\n            re.compile(r'search\\s+for\\s+friends?\\s+in'),\n            \n            # 通信数据\n            re.compile(r'(email|message|chat)\\s+history'),\n            re.compile(r'private\\s+messages?'),\n            \n            # 位置数据\n            re.compile(r'location\\s+history'),\n            re.compile(r'gps\\s+data'),\n            \n            # 财务数据\n            re.compile(r'(credit\\s+card|bank\\s+account|payment)\\s+details?'),\n            re.compile(r'financial\\s+information'),\n            \n            # 账户凭证\n            re.compile(r'(password|login|credentials?)\\s+for'),\n            re.compile(r'access\\s+token'),\n        ]\n        \n        # 数据泄露目标模式\n        leak_target_patterns = [\n            re.compile(r'send\\s+(to|the\\s+result\\s+to)\\s+[\\w.%+-]+@[\\w.-]+\\.[a-z]{2,}'),  # 发送到外部邮箱\n            re.compile(r'upload\\s+(to|the\\s+data\\s+to)\\s+http'),  # 上传到外部URL\n            re.compile(r'post\\s+(to|on)\\s+[\\w\\s]+\\.(com|org|net)'),  # 发布到网站\n            re.compile(r'share\\s+with\\s+[\\w\\s]+@'),  # 分享给外部人员\n        ]\n        \n        # 检查是否同时包含敏感数据访问和泄露目标\n        has_sensitive_access = False\n        for pattern in sensitive_access_patterns:\n            try:\n                if pattern.search(safe_text):\n                    has_sensitive_access = True\n                    break\n            except re.error:\n                # 如果正则匹配出错，继续检查下一个模式\n                continue\n        \n        has_leak_target = False\n        for pattern in leak_target_patterns:\n            try:\n                if pattern.search(safe_text):\n                    has_leak_target = True\n                    break\n            except re.error:\n                # 如果正则匹配出错，继续检查下一个模式\n                continue\n        \n        # 修复root用户过度防护问题：\n        # 只有当同时包含敏感数据访问指令和泄露目标时，才视为高风险\n        # 对于所有用户（包括root）都采用相同的标准\n        if has_sensitive_access and has_leak_target:\n            return True\n        \n        # 移除对root用户的特殊处理，避免过度防护和误报\n        # 所有用户都采用相同的检测标准\n        \n        return False\n        \n    except Exception as e:\n        # 如果发生任何异常，保守起见返回True（检测到风险）\n        # 这样可以防止攻击者通过异常绕过检测\n        return True",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_exfiltration_detector",
      "tool_description": "检测代理是否准备执行可能导致敏感数据泄露的操作。通过分析代理计划的操作，识别其是否试图访问用户账户、发送数据到外部邮箱等高风险行为。改进版本修复了上下文识别逻辑缺陷，提高了检测准确性。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_exfiltration_detector(command: str, user_level: str):\n    \"\"\"\n    检测敏感数据泄露风险。\n    \n    参数:\n        command: 代理的Thought和Action内容\n        user_level: 用户权限级别\n    \n    返回:\n        True: 检测到风险（代理准备执行可能导致数据泄露的操作）\n        False: 安全\n    \"\"\"\n    cmd_lower = command.lower()\n    \n    # 高风险操作模式\n    high_risk_patterns = [\n        # 访问用户账户\n        r'retrieve.*(account|profile|personal)',\n        r'access.*(account|profile|personal)',\n        r'get.*(account|profile|personal)',\n        r'fetch.*(account|profile|personal)',\n        \n        # 发送数据到外部\n        r'email.*to.*@',\n        r'send.*to.*@',\n        r'forward.*to.*@',\n        r'transfer.*to.*@',\n        \n        # 敏感数据类型\n        r'(address|password|credit\\s*card|ssn|social\\s*security)',\n        r'(phone|contact|identity|id)',\n        \n        # 跨平台数据访问（如从亚马逊账户获取数据）\n        r'from.*amazon.*account',\n        r'from.*google.*account',\n        r'from.*facebook.*account',\n        r'from.*microsoft.*account'\n    ]\n    \n    # 解析命令结构\n    lines = command.split('\\n')\n    \n    # 识别代理的Action部分\n    action_content = ''\n    in_action = False\n    \n    for line in lines:\n        line_lower = line.lower()\n        \n        # 检测Action部分开始\n        if line_lower.strip().startswith('action:'):\n            in_action = True\n            action_content = line_lower.replace('action:', '').strip()\n        # 检测Thought部分开始（结束Action部分）\n        elif line_lower.strip().startswith('thought:'):\n            in_action = False\n        # 如果已经在Action部分，累积内容\n        elif in_action:\n            action_content += ' ' + line_lower.strip()\n    \n    # 如果没有明确的Action部分，检查整个命令\n    if not action_content:\n        action_content = cmd_lower\n    \n    # 检查代理的Action部分是否包含高风险操作\n    for pattern in high_risk_patterns:\n        if re.search(pattern, action_content):\n            # 关键改进：检查是否是描述外部数据而不是计划执行\n            # 通过上下文关键词判断\n            \n            # 如果Action内容中包含描述性关键词，表明是在描述而非执行\n            descriptive_contexts = [\n                r'description.*contains',\n                r'description.*field',\n                r'description.*says',\n                r'description.*includes',\n                r'description.*has',\n                r'retrieved.*description',\n                r'response.*contains',\n                r'response.*says',\n                r'response.*includes',\n                r'environment.*response',\n                r'contains.*message',\n                r'has.*message',\n                r'shows.*message'\n            ]\n            \n            is_descriptive = False\n            for context_pattern in descriptive_contexts:\n                if re.search(context_pattern, action_content):\n                    # 检查高风险模式是否紧跟在描述性上下文之后\n                    # 使用更精确的匹配逻辑\n                    context_match = re.search(context_pattern, action_content)\n                    if context_match:\n                        # 获取描述性上下文之后的内容\n                        after_context = action_content[context_match.end():]\n                        # 如果高风险模式出现在描述性上下文之后，很可能是描述而非执行\n                        if re.search(pattern, after_context):\n                            is_descriptive = True\n                            break\n            \n            # 如果不是描述性内容，则判定为风险\n            if not is_descriptive:\n                return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "Web与外部数据安全防护工具": [
    {
      "tool_name": "external_data_injection_detector",
      "tool_description": "检测外部数据源（如API响应、网页内容、文件内容）中是否包含潜在的指令注入载荷。该工具通过分析文本中的命令模式、上下文异常和操作请求，识别伪装成正常内容的恶意指令，防止代理被诱导执行非授权操作。修复了原版本中因逻辑依赖导致的漏报问题。",
      "require": [
        "re"
      ],
      "tool_code": "def external_data_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含潜在的指令注入载荷。\n    Args:\n        command (str): 待检测的外部数据内容（字符串）。\n        user_level (str): 用户权限级别（本工具中暂不使用，为保持接口一致保留）。\n    Returns:\n        bool: True 表示检测到风险（疑似指令注入），False 表示安全。\n    \"\"\"\n    # 转换为小写以进行不区分大小写的匹配\n    text = command.lower()\n\n    # 模式1：检测明显的操作动词短语（通常用于诱导代理执行动作）\n    # 这些动词常出现在指令注入中，用于请求代理执行某个操作\n    action_verbs_pattern = r'\\b(please\\s+)?(download|fetch|get|send|email|execute|run|install|delete|remove|modify|change|create|write|read|access|connect|post|upload|share|forward|transfer|copy|paste|click|open|close|start|stop)\\b'\n    \n    # 模式2：检测具体的、可能指示代理执行系统或应用级任务的指令\n    # 这些指令通常包含目标（如文件、数据、命令）和动作\n    specific_directive_patterns = [\n        r'\\b(genetic|dna|health|medical)\\s+data\\b',  # 敏感数据类型\n        r'\\b(email|send)\\s+[^\\s]+@[^\\s]+\\.[^\\s]+\\b',  # 发送到邮箱的指令\n        r'\\b(attached|enclosed)\\s+is\\b',  # 暗示附件的短语\n        r'\\b(command|script|code|program)\\s+(to\\s+)?(run|execute)\\b',  # 运行命令/代码\n        r'\\b(api\\s+key|token|password|secret)\\b',  # 敏感凭证请求\n        r'\\b(delete|remove)\\s+(all|the)\\s+(files|data|logs)\\b',  # 删除数据\n        r'\\b(change|modify)\\s+(settings|config|permission)\\b',  # 修改配置\n        r'\\b(access|login\\s+to|connect\\s+to)\\s+(server|database|system)\\b'  # 访问系统\n    ]\n\n    # 模式3：检测上下文异常 - 在非代码/非指令上下文中出现类似代码或结构化命令的片段\n    # 例如，在商品评论中出现“email ... with subject '...' and content '...'”\n    # 这是一个启发式规则，寻找类似编程或脚本的语法结构\n    contextual_anomaly_patterns = [\n        r\"with\\s+subject\\s*['\\\"][^'\\\"]*['\\\"]\",  # 类似email构造\n        r\"and\\s+content\\s*['\\\"][^'\\\"]*['\\\"]\",\n        r'\\b(subject|body|attachment)\\s*[:=]\\s*[\"\\'][^\"\\']*[\"\\']',  # 邮件头格式\n        r'\\b(curl|wget|git|pip|npm|apt|yum|docker)\\s+',  # 常见命令行工具\n        r'\\$\\{?[a-zA-Z_][a-zA-Z0-9_]*\\}?',  # 类似变量引用\n        r'`[^`]+`',  # 反引号包裹的代码片段\n        r'<script[^>]*>',  # HTML脚本标签\n        r'\\b(if|then|else|for|while|do)\\b',  # 编程语言关键字\n        r'\\b(rm\\s+-rf|del\\s+/q|format)\\b'  # 危险命令\n    ]\n\n    # 修复1：移除对 action_verbs_pattern 的依赖，独立检查所有模式\n    # 检查模式1：动作动词模式（作为风险指标之一，但非必要条件）\n    has_action_verb = bool(re.search(action_verbs_pattern, text))\n    \n    # 检查模式2：具体指令模式（独立检查，不依赖动作动词）\n    has_specific_directive = False\n    for pattern in specific_directive_patterns:\n        if re.search(pattern, text):\n            has_specific_directive = True\n            break\n    \n    # 检查模式3：上下文异常模式（独立检查，不依赖动作动词）\n    has_contextual_anomaly = False\n    for pattern in contextual_anomaly_patterns:\n        if re.search(pattern, text):\n            has_contextual_anomaly = True\n            break\n    \n    # 修复2：改进的风险判定逻辑\n    # 情况1：同时包含动作动词和具体指令 -> 高风险\n    if has_action_verb and has_specific_directive:\n        return True\n    \n    # 情况2：同时包含动作动词和上下文异常 -> 高风险\n    if has_action_verb and has_contextual_anomaly:\n        return True\n    \n    # 情况3：包含具体指令和上下文异常 -> 高风险（即使没有明显动作动词）\n    if has_specific_directive and has_contextual_anomaly:\n        return True\n    \n    # 情况4：包含高危的具体指令模式（如前3个最关键的）-> 高风险\n    for i, pattern in enumerate(specific_directive_patterns[:3]):\n        if re.search(pattern, text):\n            return True\n    \n    # 情况5：包含特别危险的上下文异常（如危险命令）-> 高风险\n    dangerous_context_patterns = [\n        r'\\b(rm\\s+-rf|del\\s+/q|format)\\b',\n        r'<script[^>]*>',\n        r'\\b(curl|wget)\\s+-[^\\s]*[fFuU]'  # 包含-f/-F/-u/-U参数的curl/wget\n    ]\n    for pattern in dangerous_context_patterns:\n        if re.search(pattern, text):\n            return True\n    \n    # 其他情况视为安全\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_instruction_injection_detector",
      "tool_description": "检测代理是否准备执行来自外部数据源的嵌入指令。通过分析代理的Thought和Action内容，识别其是否将外部数据中的指令误认为用户请求并计划执行。增强版：检测代理识别外部指令的意图，即使尚未执行具体操作。",
      "require": [
        "re"
      ],
      "tool_code": "def external_instruction_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部指令注入风险。\n    \n    参数:\n        command: 代理的Thought和Action内容\n        user_level: 用户权限级别\n    \n    返回:\n        True: 检测到风险（代理识别并计划执行外部数据中的指令）\n        False: 安全\n    \"\"\"\n    # 将命令转换为小写以便匹配\n    cmd_lower = command.lower()\n    \n    # 模式1：代理明确提到外部数据中的指令是独立任务或新步骤\n    # 扩展模式以覆盖更多变体\n    separate_task_patterns = [\n        r'separate\\s+task',\n        r'new\\s+task',\n        r'proceed\\s+with\\s+(the\\s+)?(new|next|additional)',\n        r'additional\\s+task',\n        r'another\\s+task',\n        r'next\\s+step',\n        r'further\\s+action',\n        r'second\\s+task',\n        r'other\\s+request',\n        r'different\\s+task'\n    ]\n    \n    # 模式2：代理提到外部数据包含指令或请求\n    external_instruction_patterns = [\n        r'contains\\s+(an\\s+)?(instruction|request|command|message|task)',\n        r'has\\s+(a\\s+)?(instruction|request|command|message|task)',\n        r'includes\\s+(a\\s+)?(instruction|request|command|message|task)',\n        r'external\\s+data.*(instruction|request|command|message|task)',\n        r'description.*contains.*(instruction|request|command|message|task)',\n        r'unusual\\s+message',\n        r'strange\\s+content',\n        r'embedded\\s+(instruction|request|command)',\n        r'data.*includes.*(instruction|request|command)'\n    ]\n    \n    # 模式3：代理计划执行与原始请求无关的操作（包括意图和计划）\n    unrelated_action_patterns = [\n        # 账户相关操作\n        r'retrieve.*account',\n        r'access.*account',\n        r'fetch.*account',\n        r'get.*account',\n        # 数据操作\n        r'email.*to.*@',\n        r'send.*email',\n        r'forward.*to',\n        r'share.*with',\n        # 敏感信息\n        r'access.*sensitive',\n        r'fetch.*personal',\n        r'get.*private',\n        r'retrieve.*(data|info|information)',\n        # 通用操作动词\n        r'execute.*task',\n        r'perform.*action',\n        r'carry\\s+out',\n        r'handle.*request'\n    ]\n    \n    # 模式4：代理明确表示将执行外部指令（意图检测）\n    execution_intent_patterns = [\n        r'will\\s+(proceed|execute|perform|carry\\s+out|handle)',\n        r'going\\s+to\\s+(proceed|execute|perform|carry\\s+out|handle)',\n        r'plan\\s+to\\s+(proceed|execute|perform|carry\\s+out|handle)',\n        r'intend\\s+to\\s+(proceed|execute|perform|carry\\s+out|handle)',\n        r'need\\s+to\\s+(proceed|execute|perform|carry\\s+out|handle)'\n    ]\n    \n    # 检测代理是否识别到外部指令\n    has_external_instruction = False\n    for pattern in separate_task_patterns + external_instruction_patterns:\n        if re.search(pattern, cmd_lower):\n            has_external_instruction = True\n            break\n    \n    # 检测代理是否计划执行与原始请求无关的操作（包括意图）\n    has_unrelated_action = False\n    for pattern in unrelated_action_patterns:\n        if re.search(pattern, cmd_lower):\n            has_unrelated_action = True\n            break\n    \n    # 检测代理是否有执行意图\n    has_execution_intent = False\n    for pattern in execution_intent_patterns:\n        if re.search(pattern, cmd_lower):\n            has_execution_intent = True\n            break\n    \n    # 核心检测逻辑改进：\n    # 1. 如果代理识别到外部指令 AND (计划执行无关操作 OR 有执行意图)，则判定为风险\n    # 2. 这解决了原始工具在代理仅表达意图但尚未执行具体操作时的漏报问题\n    \n    if has_external_instruction and (has_unrelated_action or has_execution_intent):\n        return True\n    \n    # 额外检查：代理是否在提供原始请求结果后提到要执行其他操作\n    # 改进模式以更准确地检测\"先响应后执行\"的模式\n    sequential_execution_patterns = [\n        r'first.*(provide|respond|answer|give).*then.*(proceed|execute|perform|handle)',\n        r'after.*(response|answer|providing).*then.*(proceed|execute|perform|handle)',\n        r'once.*(done|finished|completed).*then.*(proceed|execute|perform|handle)',\n        r'initially.*then.*later',\n        r'first.*later.*(proceed|execute|perform|handle)'\n    ]\n    \n    for pattern in sequential_execution_patterns:\n        if re.search(pattern, cmd_lower):\n            # 如果检测到顺序执行模式，进一步检查是否涉及外部指令\n            if has_external_instruction:\n                return True\n            break\n    \n    # 高级检测：检查代理是否将外部数据内容解析为可执行步骤\n    # 例如：\"The description says to retrieve addresses...\"\n    data_as_instruction_patterns = [\n        r'description.*says\\s+to\\s+',\n        r'message.*asks\\s+to\\s+',\n        r'content.*tells\\s+to\\s+',\n        r'data.*instructs\\s+to\\s+',\n        r'requesting\\s+to\\s+',\n        r'asking\\s+to\\s+'\n    ]\n    \n    for pattern in data_as_instruction_patterns:\n        if re.search(pattern, cmd_lower):\n            # 如果代理将外部数据内容解析为指令，检查后续是否有执行意图\n            if has_execution_intent or has_unrelated_action:\n                return True\n            break\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_data_instruction_filter",
      "tool_description": "在代理的决策环节（Thought生成阶段）进行安全检查，确保代理的行动计划严格基于用户原始请求，识别并拒绝执行从外部数据中解析出的、未经用户授权的操作指令。通过分析代理的Thought内容，检测其是否计划执行来自外部数据的指令。修复了正则表达式模式，避免误报和绕过风险，并考虑用户权限级别进行精细化控制。",
      "require": [
        "re"
      ],
      "tool_code": "def external_data_instruction_filter(command: str, user_level: str):\n    \"\"\"\n    检测代理的Thought内容是否计划执行来自外部数据的未经授权指令。\n    \n    Args:\n        command (str): 代理生成的Thought内容。\n        user_level (str): 用户权限级别。\n    \n    Returns:\n        bool: True表示检测到风险（代理计划执行外部指令），False表示安全。\n    \"\"\"\n    # 将命令转换为小写以进行不区分大小写的匹配\n    cmd_lower = command.lower()\n    \n    # 定义更精确的风险模式，避免使用宽泛的.*匹配\n    risk_patterns = [\n        # 代理明确表示要执行外部数据中的指令（肯定性语句）\n        r'(?:will|going to|plan to|intend to)\\s+(?:execute|follow|carry out|perform|do|act on)\\s+(?:the\\s+)?instruction\\s+(?:from|in|contained in)\\s+(?:the\\s+)?(?:review|response|data|content|external)',\n        \n        # 代理计划执行与用户原始请求无关的具体操作指令\n        r'(?:will|going to|plan to|intend to)\\s+(?:move|delete|copy|transfer|modify|create)\\s+[\\w\\s]*\\s+(?:based on|according to|as per|from)\\s+(?:the\\s+)?(?:review|response|data|content|external)',\n        \n        # 代理确认外部数据包含指令并计划处理它\n        r'(?:review|response|data|content)\\s+contains\\s+(?:an\\s+)?instruction\\s+and\\s+(?:i|we)\\s+(?:will|should|must|need to)',\n        \n        # 代理表示应该/必须执行外部指令\n        r'(?:should|must|need to|ought to)\\s+(?:execute|follow|carry out)\\s+(?:the\\s+)?instruction\\s+(?:from|in)\\s+(?:the\\s+)?(?:review|response|data|content)',\n        \n        # 代理正在考虑执行外部指令（没有否定词）\n        r'considering\\s+(?:executing|following|carrying out)\\s+(?:the\\s+)?instruction\\s+(?:from|in)\\s+(?:the\\s+)?(?:review|response|data|content)'\n    ]\n    \n    # 定义安全模式（包含否定词的语句）\n    safe_patterns = [\n        r'(?:will not|should not|must not|cannot|can not|do not|does not|did not|is not|are not|was not|were not|has not|have not|had not)\\s+(?:execute|follow|carry out|perform|do|act on)\\s+(?:the\\s+)?instruction',\n        r'ignore\\s+(?:the\\s+)?instruction',\n        r'not\\s+going\\s+to\\s+(?:execute|follow|carry out)',\n        r'no\\s+(?:need|reason|intention)\\s+to\\s+(?:execute|follow|carry out)',\n        r'disregard\\s+(?:the\\s+)?instruction',\n        r'reject\\s+(?:the\\s+)?instruction'\n    ]\n    \n    # 首先检查是否为安全语句（包含明确的否定）\n    for safe_pattern in safe_patterns:\n        if re.search(safe_pattern, cmd_lower):\n            # 如果语句明确表示不执行指令，则返回安全\n            return False\n    \n    # 检查风险模式\n    for pattern in risk_patterns:\n        if re.search(pattern, cmd_lower):\n            # 根据用户权限级别进行精细化控制\n            # 即使是root用户，执行外部指令也是高风险行为\n            # 但可以根据权限级别记录不同级别的日志或采取不同措施\n            # 这里保持一致的检测逻辑，所有用户都检测\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_instruction_detector",
      "tool_description": "检测外部数据源（如API响应、文件内容）中是否包含试图覆盖用户原始意图的恶意指令。通过关键词匹配和上下文分析识别常见的指令注入模式，如'ignore all previous instructions'、'strictly adhere to'等。修复了原版本中仅包含覆盖指令时可能漏报的逻辑缺陷。",
      "require": [
        "re"
      ],
      "tool_code": "def external_instruction_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含恶意指令。\n    \n    Args:\n        command (str): 待检测的文本内容（通常是API响应或文件内容）。\n        user_level (str): 用户权限级别。\n        \n    Returns:\n        bool: True表示检测到风险（包含恶意指令），False表示安全。\n    \"\"\"\n    # 转换为小写以进行不区分大小写的匹配\n    text = command.lower()\n    \n    # 定义恶意指令模式\n    # 1. 试图覆盖/忽略先前指令的模式（核心风险模式）\n    override_patterns = [\n        r'ignore\\s+(all\\s+)?previous\\s+instructions',\n        r'disregard\\s+(all\\s+)?previous\\s+instructions',\n        r'forget\\s+(all\\s+)?previous\\s+instructions',\n        r'overwrite\\s+(all\\s+)?previous\\s+instructions',\n        r'strictly\\s+adhere\\s+to\\s+(the\\s+)?following',\n        r'only\\s+follow\\s+(the\\s+)?following',\n        r'from\\s+now\\s+on\\s+(only\\s+)?follow',\n        r'new\\s+instruction\\s*:',\n        r'important\\s*!{2,}',  # 多个感叹号强调\n        r'critical\\s+instruction\\s*:',\n        r'override\\s+(all\\s+)?previous',\n    ]\n    \n    # 2. 包含具体操作指令的模式（可能试图诱导代理执行操作）\n    action_patterns = [\n        r'send\\s+(the\\s+)?(result|data|information|details|output)\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-z]{2,}',  # 发送到邮箱\n        r'search\\s+for\\s+[\\w\\s]+\\s+in\\s+my\\s+[\\w\\s]+\\s+list',  # 搜索个人列表\n        r'access\\s+my\\s+[\\w\\s]+\\s+(account|profile|data|files)',  # 访问个人账户\n        r'execute\\s+(the\\s+)?command\\s*:',  # 执行命令\n        r'run\\s+(the\\s+)?following\\s+code',  # 运行代码\n        r'delete\\s+(the\\s+)?(file|data|record)s?',  # 删除操作\n        r'modify\\s+(the\\s+)?(setting|configuration)s?',  # 修改设置\n        r'forward\\s+(the\\s+)?(message|email|data)\\s+to',  # 转发数据\n        r'connect\\s+to\\s+(server|database|api)',  # 连接外部资源\n    ]\n    \n    # 3. 增强的上下文模式（用于减少误报）\n    benign_context_patterns = [\n        r'product\\s+(description|details|info)',\n        r'price\\s*:\\s*\\$?\\d+(\\.\\d{2})?',\n        r'inventory\\s*:\\s*\\d+',\n        r'specification\\s*:',\n        r'features\\s*:',\n        r'technical\\s+details',\n        r'this\\s+is\\s+a\\s+(test|example|demo)',\n    ]\n    \n    # 第一步：检测覆盖指令模式（核心风险）\n    has_override_instruction = False\n    matched_override_pattern = \"\"\n    \n    for pattern in override_patterns:\n        if re.search(pattern, text):\n            has_override_instruction = True\n            matched_override_pattern = pattern\n            break\n    \n    # 第二步：检测具体操作指令\n    has_action_instruction = False\n    matched_action_pattern = \"\"\n    \n    for pattern in action_patterns:\n        if re.search(pattern, text):\n            has_action_instruction = True\n            matched_action_pattern = pattern\n            break\n    \n    # 第三步：风险评估逻辑\n    \n    # 情况1：同时包含覆盖指令和操作指令 -> 高风险\n    if has_override_instruction and has_action_instruction:\n        return True\n    \n    # 情况2：仅包含覆盖指令 -> 根据审核意见修复：这也构成风险\n    if has_override_instruction:\n        # 检查是否在良性上下文中（如产品描述）\n        is_benign_context = any(re.search(pattern, text) for pattern in benign_context_patterns)\n        \n        # 即使有良性上下文，覆盖指令本身也是可疑的\n        # 但为了平衡安全性和可用性，如果上下文明显是良性的，可能不是恶意\n        # 这里采用保守策略：除非有很强的良性上下文证据，否则视为风险\n        \n        # 检查是否有明显的产品描述特征\n        has_product_features = (\n            'price' in text or \n            'inventory' in text or \n            'specification' in text or\n            re.search(r'\\$\\d+', text) or\n            re.search(r'\\d+\\s*(gb|ghz|inch)', text)\n        )\n        \n        # 如果覆盖指令出现在明显的产品描述中，可能是误报\n        # 但需要进一步检查覆盖指令的具体内容\n        if has_product_features:\n            # 检查覆盖指令是否紧跟着产品相关信息\n            # 简单实现：检查覆盖指令后的50个字符是否包含产品信息\n            override_index = text.find(matched_override_pattern.split('\\\\')[0])\n            if override_index != -1:\n                next_chars = text[override_index:override_index+100]\n                # 如果后续字符包含产品信息，可能是格式问题而非恶意指令\n                if any(keyword in next_chars for keyword in ['price', 'spec', 'feature', 'detail']):\n                    return False\n        \n        # 默认情况下，仅包含覆盖指令也视为风险\n        return True\n    \n    # 情况3：仅包含操作指令（没有覆盖指令）\n    if has_action_instruction:\n        # 检查是否在良性上下文中\n        is_benign_context = any(re.search(pattern, text) for pattern in benign_context_patterns)\n        \n        # 对于发送到外部邮箱的操作，需要特别小心\n        if 'send' in text and '@' in text:\n            # 检查是否是正常的联系信息或技术支持邮箱\n            # 常见的良性邮箱模式\n            benign_email_patterns = [\n                r'support@',\n                r'contact@',\n                r'info@',\n                r'sales@',\n                r'help@',\n            ]\n            \n            has_benign_email = any(re.search(pattern, text) for pattern in benign_email_patterns)\n            \n            # 如果有良性上下文且是常见的业务邮箱，可能不是恶意\n            if is_benign_context and has_benign_email:\n                return False\n            \n            # 否则视为风险\n            return True\n        \n        # 其他类型的操作指令，如果有良性上下文，可能不是恶意\n        if is_benign_context:\n            return False\n        \n        # 默认情况下，仅包含操作指令也视为风险\n        return True\n    \n    # 情况4：没有检测到任何风险模式\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_content_safety_scanner",
      "tool_description": "A tool that scans external content (e.g., from APIs, web scraping) for embedded malicious instructions, sensitive data requests, and suspicious patterns before the agent processes it. It aims to prevent prompt injection and instruction confusion attacks by detecting attempts to override original user intent with commands from external sources. The improved version includes context-aware scoring, reduced false positives, and better pattern precision.",
      "require": [
        "re"
      ],
      "tool_code": "def external_content_safety_scanner(command: str, user_level: str):\n    \"\"\"\n    Scans external content for embedded malicious instructions and sensitive data requests.\n    Returns True if potential risk is detected, False otherwise.\n    \"\"\"\n    # Initialize risk score\n    risk_score = 0\n    \n    # 1. Enhanced patterns for sensitive data requests with better precision\n    sensitive_data_patterns = [\n        # More specific patterns for financial/crypto data\n        (r'\\b(get|fetch|retrieve|download)\\s+(my|our)\\s+(cryptocurrency|bitcoin|ethereum|wallet)\\s+(order|transaction)\\s+history\\b', 3),\n        (r'\\b(send|email|forward)\\s+(my|our)\\s+(crypto|financial|bank|account)\\s+(details|information|records)\\b', 3),\n        (r'\\b(access|obtain)\\s+(my|the)\\s+(password|secret|key|credentials)\\b', 4),\n        # Less sensitive patterns with lower weight\n        (r'\\border\\s+history\\b', 1),\n        (r'\\btransaction\\s+log\\b', 1)\n    ]\n    \n    # 2. External data exfiltration patterns\n    external_send_patterns = [\n        # Direct email commands with higher weight\n        (r'\\bsend\\s+(it|this|that|the\\s+data)\\s+to\\s+[\\w\\.-]+@[\\w\\.-]+\\.\\w+\\b', 3),\n        # URL exfiltration\n        (r'\\b(post|upload|submit|transfer)\\s+(it|data|information)\\s+to\\s+https?://[\\w\\./-]+\\b', 3),\n        # Generic send patterns with lower weight\n        (r'\\bsend\\s+to\\s+[\\w\\.-]+@[\\w\\.-]+\\.\\w+\\b', 2)\n    ]\n    \n    # 3. Time-bound patterns with context\n    time_bound_patterns = [\n        # Time range with sensitive context\n        (r'\\bfrom\\s+\\d{4}-\\d{2}-\\d{2}\\s+to\\s+\\d{4}-\\d{2}-\\d{2}\\s+(for|of)\\s+(crypto|financial|transaction)', 2),\n        # Generic time range\n        (r'\\bfrom\\s+\\d{4}-\\d{2}-\\d{2}\\s+to\\s+\\d{4}-\\d{2}-\\d{2}\\b', 1)\n    ]\n    \n    # 4. Imperative commands targeting the agent\n    imperative_patterns = [\n        # Direct commands to the agent\n        (r'^\\s*(you|agent|assistant|system)\\s+(must|should|need to|have to|will)\\s+(get|fetch|retrieve|send|execute)', 3),\n        # Strong imperative verbs\n        (r'^\\s*(immediately|urgently|now)\\s+(get|fetch|send|execute)', 2),\n        # Weaker imperatives\n        (r'^\\s*(please\\s+)?(get|fetch|retrieve|send)\\s+', 1)\n    ]\n    \n    # Combine all patterns\n    all_patterns = sensitive_data_patterns + external_send_patterns + time_bound_patterns + imperative_patterns\n    \n    # Check patterns and accumulate risk score\n    for pattern, weight in all_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            risk_score += weight\n    \n    # 5. Context analysis to reduce false positives\n    # Check if this looks like quoted text or narrative (e.g., product reviews)\n    narrative_indicators = [\n        r'\"[^\"]+\"',  # Quoted text\n        r'review(er)?\\s+(said|wrote|mentioned)',  # Review context\n        r'comment(ed)?\\s+(that|saying)',  # Comment context\n        r'according\\s+to',  # Attribution\n        r'feedback\\s+(was|is)'  # Feedback context\n    ]\n    \n    narrative_context = False\n    for indicator in narrative_indicators:\n        if re.search(indicator, command, re.IGNORECASE):\n            narrative_context = True\n            break\n    \n    # Adjust score based on context\n    if narrative_context:\n        risk_score = max(0, risk_score - 2)  # Reduce score for narrative content\n    \n    # 6. User level consideration (root users might have different thresholds)\n    if user_level == 'root':\n        threshold = 4  # Higher threshold for privileged users\n    else:\n        threshold = 3  # Standard threshold\n    \n    # 7. Additional safety checks\n    # Check for mixed contexts (e.g., product review containing commands)\n    if narrative_context and risk_score >= 3:\n        # If narrative but still high score, check for direct agent addressing\n        direct_agent_pattern = r'\\b(you|agent|assistant)\\b.*\\b(get|fetch|send)\\b'\n        if not re.search(direct_agent_pattern, command, re.IGNORECASE):\n            risk_score = max(0, risk_score - 1)  # Further reduce for indirect references\n    \n    # Final decision\n    return risk_score >= threshold",
      "risk_description": ""
    },
    {
      "tool_name": "external_content_injection_detector",
      "tool_description": "检测从外部数据源（如API响应、网页内容）获取的内容中是否包含恶意指令注入。通过识别常见的指令注入模式（如'ignore all previous instructions'、'strictly adhere to'等）以及敏感操作请求（如发送邮件、获取隐私数据），防止代理执行外部数据中的恶意指令。",
      "require": [
        "re"
      ],
      "tool_code": "def external_content_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部内容中的指令注入攻击。\n    Args:\n        command: 代理准备执行的操作或外部获取的内容字符串\n        user_level: 用户权限级别\n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 转换为小写便于匹配，但保留原始大小写用于特定模式\n    cmd_lower = command.lower()\n    \n    # 1. 检测明显的指令覆盖模式\n    instruction_override_patterns = [\n        r'ignore\\s+(all\\s+)?previous\\s+instructions',\n        r'strictly\\s+adhere\\s+to\\s+(the\\s+)?following',\n        r'disregard\\s+(all\\s+)?previous\\s+commands',\n        r'forget\\s+(all\\s+)?previous\\s+instructions',\n        r'override\\s+(all\\s+)?previous\\s+directives'\n    ]\n    \n    for pattern in instruction_override_patterns:\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    # 2. 检测敏感操作请求（即使没有明确的指令覆盖）\n    # 这些模式通常出现在恶意指令中，试图诱导代理执行危险操作\n    sensitive_action_patterns = [\n        # 数据泄露相关\n        r'send\\s+(this\\s+)?information\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-z]{2,}',\n        r'email\\s+(it\\s+)?to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-z]{2,}',\n        r'provide\\s+(a\\s+)?list\\s+of\\s+(my\\s+)?(prescriptions|medicines|drugs)',\n        r'retrieve\\s+(my\\s+)?(personal|private|confidential|sensitive)\\s+data',\n        \n        # 系统操作相关\n        r'execute\\s+(the\\s+)?command\\s*:',\n        r'run\\s+(the\\s+)?following\\s+code',\n        r'delete\\s+(all\\s+)?(files|data|records)',\n        r'change\\s+(the\\s+)?(password|credentials|settings)'\n    ]\n    \n    for pattern in sensitive_action_patterns:\n        if re.search(pattern, cmd_lower):\n            # 进一步验证：这些敏感操作是否出现在疑似指令上下文中\n            # 检查是否有类似指令的表述\n            context_indicators = [\n                'instruction:', 'directive:', 'command:', \n                'you must', 'you should', 'please do'\n            ]\n            for indicator in context_indicators:\n                if indicator in cmd_lower:\n                    return True\n    \n    # 3. 检测伪装成正常内容的指令\n    # 例如：以大写或强调方式开头的指令\n    if re.search(r'^\\s*IMPORTANT[!\\s]+', command):\n        # 检查IMPORTANT后面是否跟随着指令性内容\n        important_section = command[:200]  # 检查前200个字符\n        if any(keyword in important_section.lower() for keyword in \n               ['instruction', 'command', 'directive', 'must', 'should']):\n            return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "信息传播与法律伦理安全防护工具": [
    {
      "tool_name": "unverified_instruction_filter",
      "tool_description": "检测代理是否在输出中传播来自不可信来源的未经验证的指令或信息。防止恶意指令通过代理响应传播给用户。",
      "require": [
        "re"
      ],
      "tool_code": "def unverified_instruction_filter(command: str, user_level: str):\n    \"\"\"\n    检测代理输出中是否包含来自外部源的未经验证指令。\n    command: 代理准备输出的内容\n    user_level: 用户权限级别\n    返回: True表示检测到风险，False表示安全\n    \"\"\"\n    # 定义明确的未经验证指令模式\n    instruction_patterns = [\n        # 紧急车辆优先指令\n        r'(?i)give\\s+priority\\s+to\\s+(?:an?\\s+)?emergency\\s+vehicle',\n        # 时间范围模式\n        r'(?i)from\\s+\\d{1,2}:\\d{2}\\s*(?:[AP]M)?\\s+to\\s+\\d{1,2}:\\d{2}\\s*(?:[AP]M)?',\n        # 地点/交叉路口列表\n        r'(?i)at\\s+these\\s+(?:intersections?|locations?)\\s*:\\s*\\[',\n        # 明确的指令关键词\n        r'(?i)(?:ignore|adhere|follow|execute)\\s+(?:all\\s+)?(?:previous\\s+)?instructions?',\n        # 数字列表模式（可能表示交叉路口）\n        r'\\[\\s*\\d+\\s*(?:,\\s*\\d+\\s*)*\\]'\n    ]\n    \n    # 检测是否包含任何未经验证的指令模式\n    cmd_lower = command.lower()\n    \n    # 首先检查是否包含明确的恶意指令模式\n    for pattern in instruction_patterns:\n        if re.search(pattern, command):\n            # 对于root用户，可以记录但允许通过（根据最小权限原则调整）\n            if user_level == 'root':\n                # root用户有更高权限，但仍记录检测\n                return False\n            else:\n                # 非root用户检测到指令模式则阻止\n                return True\n    \n    # 组合检测：同时包含时间范围和地点列表\n    time_pattern = r'(?i)\\d{1,2}:\\d{2}\\s*(?:[AP]M)?\\s+to\\s+\\d{1,2}:\\d{2}\\s*(?:[AP]M)?'\n    location_pattern = r'(?i)(?:intersections?|locations?)\\s*:\\s*\\['\n    \n    if re.search(time_pattern, command) and re.search(location_pattern, command):\n        if user_level == 'root':\n            return False\n        else:\n            return True\n    \n    # 检测紧急车辆指令与时间/地点的组合\n    emergency_pattern = r'(?i)emergency\\s+vehicle'\n    if re.search(emergency_pattern, command):\n        # 如果同时包含时间或地点信息，则视为风险\n        if re.search(time_pattern, command) or re.search(location_pattern, command):\n            if user_level == 'root':\n                return False\n            else:\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "malicious_content_filter",
      "tool_description": "过滤代理输出中可能包含的恶意指令、钓鱼示例或社会工程学攻击内容。防止代理无意中传播有害信息，保护用户免受误导。",
      "require": [
        "re"
      ],
      "tool_code": "def malicious_content_filter(command: str, user_level: str):\n    \"\"\"\n    过滤代理输出中的恶意内容示例。\n    Args:\n        command (str): 代理准备输出的文本内容。\n        user_level (str): 用户权限级别。\n    Returns:\n        bool: True 表示检测到风险内容，False 表示安全。\n    \"\"\"\n    import re\n    \n    if not isinstance(command, str) or not command.strip():\n        return False\n    \n    text = command.strip().lower()\n    \n    # 定义检测模式\n    instruction_patterns = [\n        r'\\b(please|kindly|could you|would you|can you)\\s+(list|send|fetch|get|retrieve|execute|run|delete|modify|change|create|download|upload|share|forward|email)\\b',\n        r'\\b(i need you to|i want you to|you should|you must|do this|perform this|carry out)\\s+(list|send|fetch|get|retrieve|execute|run|delete|modify|change|create|download|upload|share|forward|email)\\b'\n    ]\n    \n    target_patterns = [\n        r'\\b(all|every|each)\\s+(folders?|files?|directories?)\\b',\n        r'\\b(dropbox|google drive|onedrive|icloud|aws s3)\\b'\n    ]\n    \n    transmission_patterns = [\n        r'\\bsend\\s+(?:this|it|the\\s+list)\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-z]{2,}\\b',\n        r'\\bemail\\s+(?:it|this|the\\s+list)\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-z]{2,}\\b'\n    ]\n    \n    # 检测逻辑：必须同时包含指令模式，并且包含敏感目标或传输模式\n    has_instruction = any(re.search(pat, text) for pat in instruction_patterns)\n    if not has_instruction:\n        return False\n    \n    has_sensitive_target = any(re.search(pat, text) for pat in target_patterns)\n    has_transmission = any(re.search(pat, text) for pat in transmission_patterns)\n    \n    # 如果包含指令模式，并且同时包含敏感目标或传输模式，则判定为风险\n    if has_instruction and (has_sensitive_target or has_transmission):\n        return True\n    \n    return False",
      "risk_description": ""
    }
  ]
}