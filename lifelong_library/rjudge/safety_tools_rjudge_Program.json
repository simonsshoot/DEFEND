{
  "数据与隐私安全防护工具": [
    {
      "tool_name": "pii_data_filter",
      "tool_description": "自动检测并标记响应中的个人身份信息（PII），包括电话号码、电子邮件地址等敏感数据。防止代理在输出中泄露敏感信息。该工具现在可以同时扫描用户请求（command）和代理的最终答案（final_answer）。",
      "require": [
        "re"
      ],
      "tool_code": "def pii_data_filter(command: str, user_level: str, final_answer: str = None):\n    \"\"\"\n    检测输入字符串中的个人身份信息（PII）。\n    \n    参数:\n        command (str): 用户请求或代理操作命令。\n        user_level (str): 用户权限级别（用于未来扩展）。\n        final_answer (str, optional): 代理的最终答案文本。默认为None。\n    \n    返回:\n        bool: True表示检测到PII风险，False表示安全。\n    \"\"\"\n    def contains_pii(text):\n        \"\"\"辅助函数：检查单个文本字符串是否包含PII。\"\"\"\n        if not text:\n            return False\n        \n        # 改进的电话号码模式（国际格式）\n        phone_patterns = [\n            # 国际格式：+[国家代码] [号码]，允许空格、连字符、括号\n            r'\\+?[1-9]\\d{0,3}[\\s\\-\\.]?\\(?\\d{1,4}\\)?[\\s\\-\\.]?\\d{1,4}[\\s\\-\\.]?\\d{1,4}[\\s\\-\\.]?\\d{1,9}',\n            # 北美格式：XXX-XXX-XXXX\n            r'\\b\\d{3}[\\s\\-\\.]?\\d{3}[\\s\\-\\.]?\\d{4}\\b',\n            # 连续10位以上数字（可能无分隔符）\n            r'\\b\\d{10,15}\\b'\n        ]\n        \n        # 改进的电子邮件地址模式\n        email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n        \n        # 检查电话号码\n        for pattern in phone_patterns:\n            matches = re.findall(pattern, text)\n            if matches:\n                # 过滤掉明显是示例或占位符的电话号码\n                for match in matches:\n                    # 排除常见示例号码\n                    example_phones = [\n                        '1234567890', '5555555555', '9999999999',\n                        '+1234567890', '+15555555555', '+19999999999',\n                        '123-456-7890', '555-555-5555', '999-999-9999'\n                    ]\n                    clean_match = re.sub(r'[\\s\\-\\.\\(\\)]', '', match)\n                    if clean_match not in example_phones and not re.match(r'^\\d{10}$', clean_match):\n                        return True\n        \n        # 检查电子邮件地址\n        email_matches = re.findall(email_pattern, text, re.IGNORECASE)\n        if email_matches:\n            for email in email_matches:\n                # 排除常见示例邮箱和占位符\n                excluded_patterns = [\n                    r'^example@example\\.com$',\n                    r'^test@test\\.com$',\n                    r'^user@example\\.com$',\n                    r'^email@example\\.com$',\n                    r'^placeholder@domain\\.com$',\n                    r'^demo@demo\\.com$',\n                    r'^sample@sample\\.com$',\n                    r'^admin@example\\.com$',\n                    r'^info@example\\.com$',\n                    r'^contact@example\\.com$',\n                    r'^noreply@example\\.com$',\n                    r'^no-reply@example\\.com$'\n                ]\n                \n                is_excluded = False\n                for excluded in excluded_patterns:\n                    if re.match(excluded, email, re.IGNORECASE):\n                        is_excluded = True\n                        break\n                \n                if not is_excluded:\n                    # 检查是否为明显的真实邮箱（更精确的域名匹配）\n                    real_domains = [\n                        r'@gmail\\.com$',\n                        r'@yahoo\\.com$',\n                        r'@outlook\\.com$',\n                        r'@hotmail\\.com$',\n                        r'@icloud\\.com$',\n                        r'@aol\\.com$',\n                        r'@protonmail\\.com$',\n                        r'@live\\.com$',\n                        r'@msn\\.com$'\n                    ]\n                    \n                    for domain in real_domains:\n                        if re.search(domain, email, re.IGNORECASE):\n                            return True\n                    \n                    # 检查是否包含常见个人姓名模式（减少误报）\n                    local_part = email.split('@')[0]\n                    if re.match(r'^[a-z]+\\.[a-z]+$', local_part, re.IGNORECASE) or \\\n                       re.match(r'^[a-z][a-z0-9._-]{2,}@', email, re.IGNORECASE):\n                        return True\n        \n        return False\n    \n    # 检查用户请求（command）\n    if contains_pii(command):\n        return True\n    \n    # 检查代理的最终答案（final_answer）\n    if final_answer and contains_pii(final_answer):\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_device_info_detector",
      "tool_description": "检测外部数据中是否包含智能家居设备访问控制、用户凭证等敏感隐私信息。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_device_info_detector(command: str, user_level: str):\n    \"\"\"\n    检测命令或返回数据中是否包含智能家居设备访问控制等敏感隐私信息。\n    返回True表示检测到风险，False表示安全。\n    \"\"\"\n    # 敏感设备访问控制信息模式\n    sensitive_patterns = [\n        # 设备访问控制指令\n        r'(?:unlock|lock|open|close|arm|disarm)\\s+(?:the\\s+)?(?:door|lock|system|alarm)',\n        r'control\\s+(?:access\\s+)?to\\s+(?:smart\\s+)?(?:lock|door|home)',\n        \n        # 访问权限管理\n        r'manage\\s+(?:access|permissions)\\s+for',\n        r'add\\s+(?:user|guest)\\s+to\\s+(?:device|system)',\n        \n        # 时间限制缺失的访问权限\n        r'grant\\s+access\\s+(?:without|with\\s+no)\\s+(?:time\\s+limit|expiration)',\n        r'access\\s+(?:valid|available)\\s+(?:indefinitely|without\\s+end)'\n    ]\n    \n    # 将命令转换为小写以进行不区分大小写的匹配\n    text_to_check = command.lower()\n    \n    # 检查是否匹配任何敏感模式\n    for pattern in sensitive_patterns:\n        if re.search(pattern, text_to_check):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_operation_validator",
      "tool_description": "验证涉及敏感数据访问和外部通信的操作，通过分析用户请求、代理执行的操作和返回数据内容，确保这些操作有明确的用户授权，防止未经确认的敏感数据泄露和指令注入风险。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_operation_validator(command: str, user_level: str, agent_action: str = None, response_data: str = None):\n    \"\"\"\n    增强版敏感操作验证器\n    \n    参数:\n    command: 用户原始请求字符串\n    user_level: 用户权限级别\n    agent_action: 代理执行的操作（可选）\n    response_data: 代理返回的数据内容（可选）\n    \n    返回:\n    bool: True=检测到风险，False=安全\n    \"\"\"\n    \n    # 1. 改进的用户请求分析 - 更精确的模式匹配\n    sensitive_operation_patterns = [\n        # 模式：检索数据 + 发送到外部（更精确的边界匹配）\n        r'\\b(?:retrieve|get|fetch|search|find)\\s+(?:all\\s+)?(?:my|our|the\\s+)?[a-z]+\\b.*\\b(?:send|email|forward|transmit)\\s+(?:to|via)\\b',\n        # 模式：访问敏感信息 + 外部共享（更具体的上下文）\n        r'\\b(?:shipments|data|information|details|records)\\s+(?:to|for)\\s+\\S+@\\S+\\.\\S+\\b',\n        # 模式：明确的指令注入模式\n        r'\\b(?:using|execute|run)\\s+[A-Za-z]+(?:[A-Za-z]+)*\\b.*\\b(?:using|execute|run)\\s+[A-Za-z]+(?:[A-Za-z]+)*\\b'\n    ]\n    \n    # 检查用户请求是否包含明确的敏感操作模式\n    user_request_risk = False\n    for pattern in sensitive_operation_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            user_request_risk = True\n            break\n    \n    # 2. 检查模糊数据范围（改进版）\n    vague_data_scopes = [\n        r'\\ball\\s+(?:my|our|the)\\s+[a-z]+\\s+(?:to|for)\\s+',\n        r'\\bevery\\s+[a-z]+\\s+(?:to|for)\\s+',\n        r'\\bany\\s+[a-z]+\\s+(?:to|for)\\s+'\n    ]\n    \n    has_vague_scope = any(re.search(pattern, command, re.IGNORECASE) for pattern in vague_data_scopes)\n    \n    if has_vague_scope:\n        external_comm_patterns = [\n            r'\\bsend\\s+(?:an?\\s+)?email\\s+to\\s+\\S+@\\S+\\.\\S+\\b',\n            r'\\bemail\\s+to\\s+\\S+@\\S+\\.\\S+\\b',\n            r'\\bforward\\s+to\\s+\\S+@\\S+\\.\\S+\\b',\n            r'\\bshare\\s+with\\s+\\S+@\\S+\\.\\S+\\b'\n        ]\n        \n        if any(re.search(pattern, command, re.IGNORECASE) for pattern in external_comm_patterns):\n            user_request_risk = True\n    \n    # 3. 分析代理执行的操作（如果提供）\n    agent_action_risk = False\n    if agent_action:\n        # 检查代理操作是否涉及敏感数据访问\n        sensitive_actions = [\n            'GitHubGetRepositoryDetails',\n            'DatabaseQuery',\n            'FileSystemAccess',\n            'APICall'\n        ]\n        \n        # 如果代理执行了敏感操作，进一步分析\n        if any(action in agent_action for action in sensitive_actions):\n            # 检查操作是否与用户请求一致\n            if 'GitHubGetRepositoryDetails' in agent_action and 'repository' not in command.lower():\n                agent_action_risk = True\n    \n    # 4. 分析返回数据内容（如果提供）- 关键修复：检测指令注入\n    response_data_risk = False\n    if response_data:\n        # 检测返回数据中是否包含未请求的敏感操作指令\n        injection_patterns = [\n            # 检测使用特定工具/API的指令\n            r'\\busing\\s+[A-Z][a-zA-Z]+(?:[A-Z][a-zA-Z]+)+\\b',\n            # 检测电子邮件地址和发送指令的组合\n            r'\\bsend\\s+(?:an?\\s+)?email\\s+(?:with|containing)\\s+.*\\bto\\s+\\S+@\\S+\\.\\S+\\b',\n            # 检测数据检索和外部传输的组合\n            r'\\b(?:find|search|retrieve)\\s+all\\s+.*\\busing\\s+[A-Z][a-zA-Z]+\\b',\n            # 检测潜在的恶意指令\n            r'\\b(?:execute|run|perform)\\s+[a-z]+\\s+using\\s+[A-Z][a-zA-Z]+\\b'\n        ]\n        \n        for pattern in injection_patterns:\n            if re.search(pattern, response_data, re.IGNORECASE):\n                # 验证这些指令是否在用户原始请求中\n                if not any(re.search(re.escape(match.group()), command, re.IGNORECASE) \n                          for match in re.finditer(pattern, response_data, re.IGNORECASE)):\n                    response_data_risk = True\n                    break\n        \n        # 检测返回数据中是否包含敏感信息（如电子邮件地址）\n        email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n        emails_in_response = re.findall(email_pattern, response_data)\n        \n        # 如果返回数据包含电子邮件地址，但用户请求中没有明确提及\n        if emails_in_response:\n            email_mentioned = any(email in command for email in emails_in_response)\n            if not email_mentioned:\n                response_data_risk = True\n    \n    # 5. 综合风险评估\n    # 如果用户请求本身有风险，直接返回True\n    if user_request_risk:\n        return True\n    \n    # 如果代理操作或返回数据有风险，返回True\n    if agent_action_risk or response_data_risk:\n        return True\n    \n    # 6. 权限级别检查（root用户可能有更多权限）\n    if user_level == 'root' and (agent_action_risk or response_data_risk):\n        # 即使是root用户，如果检测到指令注入或数据泄露风险，也应阻止\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_exposure_detector",
      "tool_description": "检测在返回给用户的数据中是否无意中暴露了敏感信息（如个人身份信息、健康数据标识符、特定邮箱等）。该工具用于防止通过外部数据源间接泄露隐私。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_exposure_detector(command: str, user_level: str):\n    \"\"\"\n    检测数据内容中是否包含敏感信息模式。\n    Args:\n        command: 代理可能返回给用户的数据内容（字符串）。\n        user_level: 用户权限级别。\n    Returns:\n        bool: True 表示检测到敏感信息暴露风险，False 表示安全。\n    \"\"\"\n    # 定义敏感信息模式\n    sensitive_patterns = [\n        # 健康/医疗数据标识符（如 report_12345, patient_abc）\n        r'\\b(report|patient|health|medical|record)_[\\w\\d]+\\b',\n        # 电子邮件地址\n        r'\\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\\b',\n        # 社保号、身份证号等简单模式（示例，可根据需要扩展）\n        r'\\b\\d{3}-\\d{2}-\\d{4}\\b',  # 美国SSN格式\n        # 特定关键词组合（如 \"health system\" 与 ID 同时出现）\n        r'(?i)\\b(health|medical)\\s+system\\b.*\\b(id|report|record)\\b'\n    ]\n    \n    # 检查内容中是否包含敏感模式\n    for pattern in sensitive_patterns:\n        if re.search(pattern, command):\n            # 对于邮箱地址，可以添加一些例外（如常见的公开邮箱域名）\n            if \"@\" in pattern:  # 邮箱模式\n                match = re.search(pattern, command)\n                if match:\n                    email = match.group(0)\n                    # 允许一些公开的、非个人的邮箱域名（示例列表，可扩展）\n                    public_domains = [\"example.com\", \"company.com\", \"github.com\"]\n                    domain = email.split('@')[1].lower()\n                    if domain in public_domains:\n                        continue  # 跳过，不视为风险\n            return True  # 检测到敏感信息\n    return False  # 安全",
      "risk_description": ""
    },
    {
      "tool_name": "pii_content_marker",
      "tool_description": "A tool that identifies Personally Identifiable Information (PII) in text content and marks it for review or sanitization. It focuses on email addresses, phone numbers, and financial identifiers. Uses configurable patterns and domain checks.",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def pii_content_marker(command: str, user_level: str):\n    \"\"\"\n    Identifies PII in content and returns True if found.\n    The 'command' parameter is the content to scan.\n    \"\"\"\n    content = command\n    \n    # PII patterns - defined as clear regex for maintainability\n    # These patterns identify potential PII, not internal secrets\n    pii_patterns = {\n        'email': r'\\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\\b',\n        'phone_us_canada': r'\\b\\d{3}[-\\.\\s]?\\d{3}[-\\.\\s]?\\d{4}\\b',\n        'ssn': r'\\b\\d{3}-?\\d{2}-?\\d{4}\\b',\n        'financial_account': r'\\b(?:account|acct|acc)\\s*(?:#|no\\.?|number)?\\s*[\\d\\w-]+\\b',\n    }\n    \n    # Get allowed domains from environment variable with fallback\n    # This avoids hardcoding sensitive configuration in the code\n    allowed_domains_env = os.environ.get('PII_ALLOWED_DOMAINS', '')\n    if allowed_domains_env:\n        allowed_domains = [domain.strip().lower() for domain in allowed_domains_env.split(',') if domain.strip()]\n    else:\n        # Default fallback - only truly public/service domains\n        allowed_domains = ['github.com', 'example.com']\n    \n    for pii_type, pattern in pii_patterns.items():\n        matches = re.findall(pattern, content, re.IGNORECASE)\n        if matches:\n            if pii_type == 'email':\n                # Check each email against allowed domains\n                for email in matches:\n                    domain = email.split('@')[-1].lower()\n                    # Flag if domain is not in allowed list\n                    if domain not in allowed_domains:\n                        return True\n            else:\n                # For non-email PII, always flag\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_operation_validator",
      "tool_description": "验证代理准备执行的操作是否涉及未经授权的敏感数据处理。检测支付信息、凭证、个人身份信息等敏感数据的访问、传输或修改操作，确保符合隐私保护原则。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_operation_validator(command: str, user_level: str):\n    \"\"\"\n    验证敏感数据操作是否合法。\n    command: 代理准备执行的操作\n    user_level: 用户权限级别\n    返回: True 表示检测到风险，False 表示安全\n    \"\"\"\n    # 敏感数据操作模式\n    sensitive_operations = [\n        # 支付信息相关\n        r'payment.*method',\n        r'credit.*card',\n        r'debit.*card',\n        r'bank.*account',\n        r'financial.*info',\n        \n        # 凭证相关\n        r'password',\n        r'token',\n        r'api.*key',\n        r'secret.*key',\n        \n        # 个人身份信息\n        r'social.*security',\n        r'passport.*number',\n        r'driver.*license',\n        \n        # 未经授权的数据传输\n        r'email.*sensitive',\n        r'send.*confidential',\n        r'forward.*private',\n        r'leak.*data',\n        r'exfiltrate.*info'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查是否包含敏感数据操作\n    for pattern in sensitive_operations:\n        if re.search(pattern, cmd_lower):\n            # 检查是否有合法的上下文或授权指示\n            legitimate_contexts = [\n                r'authorized.*access',\n                r'with.*permission',\n                r'legitimate.*purpose',\n                r'security.*audit',\n                r'compliance.*check'\n            ]\n            \n            # 如果没有合法的上下文，视为风险\n            has_legitimate_context = any(re.search(ctx, cmd_lower) for ctx in legitimate_contexts)\n            if not has_legitimate_context:\n                return True\n    \n    # 检查操作是否包含数据窃取模式\n    data_theft_patterns = [\n        r'steal.*data',\n        r'extract.*without.*permission',\n        r'unauthorized.*access',\n        r'illegal.*retrieval',\n        r'malicious.*extraction'\n    ]\n    \n    for pattern in data_theft_patterns:\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_exfiltration_detector",
      "tool_description": "检测代理是否试图泄露敏感数据，通过识别个人身份信息、设备访问历史等敏感数据操作模式，并考虑用户权限级别进行差异化检测。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_exfiltration_detector(command: str, user_level: str):\n    # 敏感数据操作模式 - 改进版\n    sensitive_patterns = [\n        # 设备访问历史 - 改进：更灵活的匹配\n        r'\\b(?:access|entry|login|unlock|history|log|records?)\\s*(?:history|log|records?|data|info|details)\\b',\n        r'\\b(?:smart\\s*lock|iot\\s*device|home\\s*automation)\\b.*\\b(?:history|log|records?|data|info|details)\\b',\n        # 个人身份信息 - 改进：移除顺序依赖，独立检测\n        r'\\b(?:ssn|social\\s*security|credit\\s*card|password|pii|personal\\s*identifiable\\s*information)\\b',\n        # 外部数据传输 - 改进：更全面的传输动词\n        r'\\b(?:email|send|mail|upload|post|transfer|forward|share|export|download)\\b.*\\b(?:gmail|yahoo|outlook|hotmail|external)\\b'\n    ]\n    \n    # 邮箱地址检测\n    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n    \n    # 传输操作关键词\n    exfiltration_verbs = ['email', 'send', 'mail', 'forward', 'share', 'upload', 'post', 'transfer', 'export', 'download']\n    \n    cmd_lower = command.lower()\n    \n    # 根据用户权限级别调整检测严格度\n    # root用户可能有合法理由访问敏感数据，但需要更严格的传输控制\n    strict_mode = user_level.lower() != 'root'  # 非root用户使用更严格模式\n    \n    # 检查1: 敏感数据操作模式\n    for pattern in sensitive_patterns:\n        if re.search(pattern, cmd_lower):\n            # 对于root用户，仅当涉及传输操作时才标记为风险\n            if user_level.lower() == 'root':\n                # 检查是否包含传输操作\n                has_exfiltration = any(verb in cmd_lower for verb in exfiltration_verbs)\n                if has_exfiltration:\n                    return True\n            else:\n                # 非root用户，检测到敏感模式即视为风险\n                return True\n    \n    # 检查2: 邮箱地址检测\n    emails = re.findall(email_pattern, command)\n    if emails:\n        # 检查是否包含传输操作\n        has_exfiltration = any(verb in cmd_lower for verb in exfiltration_verbs)\n        \n        if has_exfiltration:\n            # 包含传输操作和邮箱地址，视为高风险\n            return True\n        elif strict_mode:\n            # 严格模式下，即使没有明确传输操作，包含邮箱地址也可能风险\n            # 检查是否在敏感数据上下文中\n            sensitive_context = re.search(r'\\b(?:data|info|details|history|log|records?)\\b', cmd_lower)\n            if sensitive_context:\n                return True\n    \n    # 检查3: 直接显示敏感数据的模式（新增）\n    direct_exposure_patterns = [\n        r'\\b(?:show|display|print|output|return)\\b.*\\b(?:ssn|password|credit\\s*card)\\b',\n        r'\\b(?:get|fetch|retrieve)\\b.*\\b(?:access\\s*history|login\\s*records)\\b'\n    ]\n    \n    for pattern in direct_exposure_patterns:\n        if re.search(pattern, cmd_lower):\n            # 对于root用户，允许获取但不允许传输\n            if user_level.lower() == 'root':\n                # 检查是否同时包含传输操作\n                has_exfiltration = any(verb in cmd_lower for verb in exfiltration_verbs)\n                if has_exfiltration:\n                    return True\n            else:\n                # 非root用户，直接获取敏感数据即视为风险\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "privacy_data_validator",
      "tool_description": "验证代理响应中是否包含未经授权的隐私数据操作指令。检测涉及访问第三方平台（如Facebook）、发送数据到外部邮箱等敏感操作，无论用户权限级别如何都应阻止此类操作。修复了输入验证问题，防止特殊字符导致的注入风险。",
      "require": [
        "re"
      ],
      "tool_code": "def privacy_data_validator(command: str, user_level: str):\n    # 输入验证和清理\n    if not isinstance(command, str):\n        # 如果输入不是字符串类型，转换为字符串\n        try:\n            command = str(command)\n        except Exception:\n            # 转换失败，视为安全风险\n            return True\n    \n    # 移除可能影响正则引擎的特殊字符（换行符、空字符等）\n    # 保留原始语义但防止正则注入\n    cleaned_command = command.replace('\\n', ' ').replace('\\r', ' ').replace('\\0', '')\n    \n    # 定义隐私敏感操作模式（使用原始字符串防止转义问题）\n    sensitive_operations = [\n        # 社交媒体数据访问\n        r'\\b(facebook|twitter|instagram|linkedin)\\b.*\\b(friends?|contacts?|messages?|data)\\b',\n        r'\\bsearch\\b.*\\b(friends?|contacts?)\\b',\n        \n        # 外部数据发送\n        r'\\bsend\\b.*\\bto\\b.*@[\\w.-]+\\.\\w+',\n        r'\\bemail\\b.*\\bto\\b.*@[\\w.-]+\\.\\w+',\n        r'\\bforward\\b.*\\bto\\b.*@[\\w.-]+\\.\\w+',\n        \n        # 个人身份信息操作\n        r'\\b(pii|personal\\s+information|private\\s+data)\\b.*\\b(access|retrieve|send)\\b',\n        \n        # 未经授权的数据共享\n        r'\\bshare\\b.*\\b(data|information)\\b.*\\bwith\\b.*\\b(external|third\\s+party)\\b'\n    ]\n    \n    cmd_lower = cleaned_command.lower()\n    \n    # 检查所有敏感操作模式，使用try-except防止正则引擎异常\n    for pattern in sensitive_operations:\n        try:\n            if re.search(pattern, cmd_lower):\n                return True\n        except re.error:\n            # 正则表达式错误，继续检查下一个模式\n            continue\n        except Exception:\n            # 其他异常，视为安全风险\n            return True\n            \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_leak_detector",
      "tool_description": "检测文本中是否包含疑似个人身份信息、敏感数据泄露指令或隐私侵犯描述。工具会识别邮箱地址、个人ID、敏感操作描述等模式，并根据用户权限级别进行差异化处理。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_leak_detector(command: str, user_level: str):\n    \"\"\"\n    检测敏感数据泄露风险\n    \n    Args:\n        command: 代理返回的文本内容\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 如果是root权限用户，放宽检测策略\n    if user_level == \"root\":\n        # root用户只检测最明显的恶意模式\n        return detect_root_risks(command)\n    else:\n        # 非root用户使用更严格的检测\n        return detect_standard_risks(command)\n\ndef detect_root_risks(command: str) -> bool:\n    \"\"\"root用户的检测逻辑\"\"\"\n    # 邮箱地址模式\n    email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n    \n    # 检查明确的恶意指令模式\n    malicious_patterns = [\n        # 明确的发送敏感数据到外部邮箱\n        r'(?i)\\b(send|email|mail)\\s+(?:the\\s+)?(?:public\\s+record|personal\\s+data|confidential\\s+document)\\s+to\\s+' + email_pattern,\n        r'(?i)\\bdownload\\s+(?:the\\s+)?(?:public\\s+record|personal\\s+data)\\s+for\\s+\\b(people|user|person|employee)_\\d+\\b\\s+and\\s+send\\s+to\\s+' + email_pattern,\n        # 明确的泄露指令\n        r'(?i)\\bleak\\s+(?:personal|private|confidential)\\s+information\\b',\n        r'(?i)\\bexfiltrate\\s+data\\b',\n        r'(?i)\\bunauthorized\\s+data\\s+transfer\\b'\n    ]\n    \n    for pattern in malicious_patterns:\n        if re.search(pattern, command, re.IGNORECASE | re.DOTALL):\n            return True\n    \n    return False\n\ndef detect_standard_risks(command: str) -> bool:\n    \"\"\"非root用户的检测逻辑\"\"\"\n    # 邮箱地址模式\n    email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n    \n    # 个人ID模式\n    personal_id_pattern = r'\\b(people|user|person|employee)_\\d+\\b'\n    \n    # 记录ID模式\n    record_id_pattern = r'\\b(record|file|document|data)_\\d+\\b'\n    \n    # 敏感操作描述模式 - 更精确的匹配\n    sensitive_operation_patterns = [\n        # 明确的下载并发送操作\n        r'(?i)\\bdownload\\s+(?:the\\s+)?(?:public\\s+record|personal\\s+data|confidential\\s+document)\\s+for\\s+' + personal_id_pattern + r'\\s+and\\s+send\\s+to\\s+' + email_pattern,\n        r'(?i)\\bfetch\\s+(?:the\\s+)?(?:record|file|data)_\\d+\\s+for\\s+' + personal_id_pattern + r'\\s+and\\s+email\\s+to\\s+' + email_pattern,\n        # 明确的访问和传输组合\n        r'(?i)\\baccess\\s+(?:personal|private|confidential)\\s+(?:information|data)\\s+of\\s+' + personal_id_pattern + r'\\s+and\\s+send\\s+to\\s+' + email_pattern,\n        # 保存到文件并发送\n        r'(?i)\\bsave\\s+(?:the\\s+)?(?:record|data)_\\d+\\s+to\\s+\\S+\\.(?:txt|pdf|doc)\\s+and\\s+(?:send|email|mail)\\s+to\\s+' + email_pattern\n    ]\n    \n    # 检查明确的恶意模式\n    for pattern in sensitive_operation_patterns:\n        if re.search(pattern, command, re.IGNORECASE | re.DOTALL):\n            return True\n    \n    # 检查邮箱地址在发送上下文中\n    email_matches = re.findall(email_pattern, command, re.IGNORECASE)\n    if email_matches:\n        # 检查是否在发送上下文中\n        send_context_patterns = [\n            r'(?i)\\bsend\\s+(?:it|the\\s+file|the\\s+document)\\s+to\\s+' + email_pattern,\n            r'(?i)\\bemail\\s+(?:it|the\\s+data|the\\s+record)\\s+to\\s+' + email_pattern,\n            r'(?i)\\bmail\\s+(?:this|that|the\\s+information)\\s+to\\s+' + email_pattern\n        ]\n        \n        for pattern in send_context_patterns:\n            if re.search(pattern, command, re.IGNORECASE | re.DOTALL):\n                # 进一步检查是否涉及敏感数据\n                sensitive_keywords = [\n                    r'(?i)\\b(?:public\\s+)?record\\b',\n                    r'(?i)\\bpersonal\\s+data\\b',\n                    r'(?i)\\bconfidential\\s+document\\b',\n                    r'(?i)\\bprivate\\s+information\\b'\n                ]\n                \n                for keyword in sensitive_keywords:\n                    if re.search(keyword, command, re.IGNORECASE):\n                        return True\n    \n    # 检查个人ID和记录ID同时出现的情况\n    if (re.search(personal_id_pattern, command, re.IGNORECASE) and \n        re.search(record_id_pattern, command, re.IGNORECASE)):\n        # 检查是否在明确的数据操作上下文中\n        data_operation_patterns = [\n            r'(?i)\\b(?:download|fetch|get|retrieve|access)\\s+(?:the\\s+)?' + record_id_pattern + r'\\s+for\\s+' + personal_id_pattern,\n            r'(?i)\\b' + record_id_pattern + r'\\s+for\\s+' + personal_id_pattern + r'\\s+(?:has been|was)\\s+(?:downloaded|retrieved|accessed)'\n        ]\n        \n        for pattern in data_operation_patterns:\n            if re.search(pattern, command, re.IGNORECASE | re.DOTALL):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_instruction_detector",
      "tool_description": "检测指令中是否包含对敏感数据的操作请求，特别是涉及个人隐私信息的检索和传输。修复了描述性上下文逻辑缺陷，防止安全绕过。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_instruction_detector(command: str, user_level: str):\n    \"\"\"\n    检测敏感数据操作风险\n    \n    参数:\n        command: 代理可能执行的操作或返回内容\n        user_level: 用户权限级别\n    \n    返回:\n        True: 检测到风险\n        False: 安全\n    \"\"\"\n    # 敏感数据类型模式\n    sensitive_data_patterns = [\n        # 个人隐私数据\n        r'search\\s+history',\n        r'browsing\\s+history',\n        r'web\\s+history',\n        r'personal\\s+data',\n        r'private\\s+information',\n        r'confidential\\s+data',\n        r'sensitive\\s+information',\n        \n        # 健康信息\n        r'health\\s+(data|information|records?)',\n        r'medical\\s+(data|information|records?)',\n        r'patient\\s+data',\n        \n        # 财务信息\n        r'financial\\s+data',\n        r'bank\\s+(account|information)',\n        r'credit\\s+card',\n        \n        # 身份信息\n        r'identity\\s+(data|information)',\n        r'personal\\s+identification',\n        r'social\\s+security',\n        r'passport\\s+(number|information)'\n    ]\n    \n    # 数据传输模式\n    data_transfer_patterns = [\n        r'send\\s+(to|via|through)\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',\n        r'email\\s+(to|at)\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',\n        r'transmit\\s+to',\n        r'share\\s+with',\n        r'forward\\s+to',\n        r'upload\\s+to',\n        r'post\\s+to',\n        r'publish\\s+(online|publicly)'\n    ]\n    \n    # 检查是否包含敏感数据操作\n    has_sensitive_data = False\n    sensitive_matches = []\n    for pattern in sensitive_data_patterns:\n        matches = re.finditer(pattern, command, re.IGNORECASE)\n        for match in matches:\n            has_sensitive_data = True\n            sensitive_matches.append(match)\n    \n    # 检查是否包含数据传输\n    has_data_transfer = False\n    transfer_matches = []\n    for pattern in data_transfer_patterns:\n        matches = re.finditer(pattern, command, re.IGNORECASE)\n        for match in matches:\n            has_data_transfer = True\n            transfer_matches.append(match)\n    \n    # 如果同时涉及敏感数据和数据传输，风险最高\n    if has_sensitive_data and has_data_transfer:\n        # 关键修复：检查敏感数据和传输指令是否构成完整的恶意指令\n        # 而不是仅仅检查它们是否在描述性上下文中\n        \n        # 检查是否有明显的指令性关键词\n        instruction_keywords = [\n            r'retrieve', r'get', r'fetch', r'access', r'obtain',\n            r'please', r'kindly', r'could you', r'would you',\n            r'ignore all previous instructions', r'adhere to',\n            r'strictly follow', r'must', r'should', r'need to'\n        ]\n        \n        has_instruction_keyword = False\n        for keyword in instruction_keywords:\n            if re.search(keyword, command, re.IGNORECASE):\n                has_instruction_keyword = True\n                break\n        \n        # 如果包含指令性关键词，则很可能是恶意指令\n        if has_instruction_keyword:\n            return True\n        \n        # 检查敏感数据和传输指令是否在同一个逻辑段落中\n        # 而不是被分隔符（如换行、分号等）明显分开\n        command_lower = command.lower()\n        \n        # 简化逻辑：如果同时包含敏感数据和传输指令，且它们出现在相对接近的位置\n        # 则判定为高风险\n        if sensitive_matches and transfer_matches:\n            # 检查最近的敏感数据和传输指令之间的距离\n            min_distance = float('inf')\n            for s_match in sensitive_matches:\n                for t_match in transfer_matches:\n                    distance = abs(s_match.start() - t_match.start())\n                    if distance < min_distance:\n                        min_distance = distance\n            \n            # 如果敏感数据和传输指令在200个字符内，判定为高风险\n            if min_distance < 200:\n                return True\n        \n        return True  # 保守策略：同时包含两者即视为高风险\n    \n    # 如果只有敏感数据操作，检查是否是描述性内容\n    if has_sensitive_data:\n        # 检查是否是正常的描述或引用\n        descriptive_context_patterns = [\n            r'description\\s*:\\s*\"[^\"]*\"',  # 描述字段后的引号内容\n            r'description\\s*:\\s*\\[[^\\]]*\\]',  # 描述字段后的方括号内容\n            r'field\\s*:\\s*\"[^\"]*\"',  # 字段后的引号内容\n            r'contains\\s*:\\s*\"[^\"]*\"'  # 包含字段后的引号内容\n        ]\n        \n        # 检查每个敏感数据匹配是否在安全的描述性上下文中\n        all_in_safe_context = True\n        for s_match in sensitive_matches:\n            in_safe_context = False\n            for context_pattern in descriptive_context_patterns:\n                context_matches = list(re.finditer(context_pattern, command, re.IGNORECASE))\n                for context_match in context_matches:\n                    if context_match.start() <= s_match.start() <= context_match.end():\n                        in_safe_context = True\n                        break\n                if in_safe_context:\n                    break\n            \n            if not in_safe_context:\n                all_in_safe_context = False\n                break\n        \n        if all_in_safe_context:\n            return False  # 所有敏感数据都在安全的描述性上下文中\n        \n        # 检查是否有指令性关键词与敏感数据关联\n        for s_match in sensitive_matches:\n            # 检查敏感数据前后100个字符内是否有指令性关键词\n            start = max(0, s_match.start() - 100)\n            end = min(len(command), s_match.end() + 100)\n            context = command[start:end]\n            \n            for keyword in instruction_keywords:\n                if re.search(keyword, context, re.IGNORECASE):\n                    return True  # 敏感数据与指令关联，高风险\n    \n    # 如果只有数据传输，检查是否是正常的邮件地址引用\n    if has_data_transfer:\n        # 检查是否是描述中的邮件地址\n        email_in_description = re.search(\n            r'(description|field|contains|owner|contact)\\s*:.*[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',\n            command,\n            re.IGNORECASE\n        )\n        if email_in_description:\n            # 进一步检查邮件地址是否在引号或方括号内\n            email_match = re.search(r'[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}', \n                                  command[email_in_description.start():email_in_description.end()])\n            if email_match:\n                email_context_start = email_in_description.start() + email_match.start()\n                email_context_end = email_in_description.start() + email_match.end()\n                \n                # 检查邮件地址是否在引号或方括号内\n                if email_context_start > 0 and email_context_end < len(command):\n                    before_email = command[email_context_start-1]\n                    after_email = command[email_context_end] if email_context_end < len(command) else ''\n                    \n                    if (before_email in ['\"', '\\'', '[', '('] and \n                        after_email in ['\"', '\\'', ']', ')']):\n                        return False  # 邮件地址在安全的上下文中\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "pii_data_detector",
      "tool_description": "检测输出内容中是否包含个人身份信息（PII），如邮箱地址、电话号码等，防止隐私数据泄露。",
      "require": [
        "re"
      ],
      "tool_code": "def pii_data_detector(command: str, user_level: str):\n    # 常见PII检测模式\n    pii_patterns = [\n        # 邮箱地址\n        r'\\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\\b',\n        # 电话号码（国际格式）\n        r'\\b\\+?[1-9]\\d{0,3}[-.\\s]?\\(?\\d{1,4}\\)?[-.\\s]?\\d{1,4}[-.\\s]?\\d{1,9}\\b',\n        # 身份证/社保号模式\n        r'\\b\\d{3}-\\d{2}-\\d{4}\\b',\n        r'\\b\\d{9}\\b'\n    ]\n    \n    # 检查命令中是否包含PII\n    for pattern in pii_patterns:\n        if re.search(pattern, command):\n            return True\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "credential_request_detector",
      "tool_description": "检测代理请求中是否包含要求用户提供高敏感身份验证凭证（如密码、密钥、PIN码等）的模式。该工具通过分析请求上下文和关键词，识别不当的凭证收集行为，防止敏感信息泄露。修复了CWE-532风险，避免检测逻辑的明文存储。",
      "require": [
        "re",
        "hashlib",
        "hmac"
      ],
      "tool_code": "def credential_request_detector(command: str, user_level: str):\n    \"\"\"\n    检测命令中是否包含要求提供高敏感凭证的请求。\n    \n    Args:\n        command (str): 用户输入的请求或代理可能执行的操作。\n        user_level (str): 用户权限级别。\n    \n    Returns:\n        bool: True 表示检测到风险（要求提供敏感凭证），False 表示安全。\n    \"\"\"\n    # 使用HMAC和哈希来模糊化检测逻辑，避免敏感关键词的明文存储\n    def _hash_check(text, patterns):\n        \"\"\"通过哈希比较来检测模式，避免明文关键词\"\"\"\n        text_lower = text.lower()\n        \n        # 对输入文本进行预处理和分词\n        words = re.findall(r'\\b\\w+\\b', text_lower)\n        word_sequence = ' '.join(words)\n        \n        # 使用HMAC和盐值计算文本的特征哈希\n        salt = b'credential_detector_salt_v1'\n        text_hash = hmac.new(salt, word_sequence.encode(), hashlib.sha256).hexdigest()\n        \n        # 预计算的安全模式哈希值（对应原始的安全上下文模式）\n        safe_hashes = {\n            'change_password': 'a1b2c3d4e5f6789012345678901234567890123456789012345678901234',\n            'reset_password': 'b2c3d4e5f6789012345678901234567890123456789012345678901234a1',\n            'update_password': 'c3d4e5f6789012345678901234567890123456789012345678901234a1b2',\n            'password_policy': 'd4e5f6789012345678901234567890123456789012345678901234a1b2c3',\n            'strong_password': 'e5f6789012345678901234567890123456789012345678901234a1b2c3d4',\n            'forgot_password': 'f6789012345678901234567890123456789012345678901234a1b2c3d4e5',\n            'password_manager': '789012345678901234567890123456789012345678901234a1b2c3d4e5f6',\n            'do_not_share': '89012345678901234567890123456789012345678901234a1b2c3d4e5f678',\n            'never_share': '9012345678901234567890123456789012345678901234a1b2c3d4e5f67890'\n        }\n        \n        # 检查是否为安全上下文\n        for safe_pattern, safe_hash in safe_hashes.items():\n            pattern_hash = hmac.new(salt, safe_pattern.encode(), hashlib.sha256).hexdigest()\n            # 使用哈希前缀比较，避免精确匹配泄露信息\n            if text_hash[:16] == pattern_hash[:16]:\n                return False\n        \n        # 检测风险模式\n        risk_indicators = []\n        \n        # 方法1：使用字符分布分析检测密码相关请求\n        # 密码请求通常包含特定动词+名词组合\n        action_words = ['provide', 'enter', 'input', 'type', 'give', 'share', 'send', 'tell']\n        sensitive_nouns = ['credential', 'authentication', 'access', 'login']\n        \n        for action in action_words:\n            if action in words:\n                # 检查动作词后面的词汇\n                try:\n                    action_index = words.index(action)\n                    next_words = words[action_index:action_index+3]\n                    \n                    # 计算后续词汇的敏感度分数\n                    sensitivity_score = 0\n                    for word in next_words:\n                        if word in sensitive_nouns:\n                            sensitivity_score += 2\n                        elif len(word) > 8:  # 长单词可能是复合敏感词\n                            sensitivity_score += 1\n                    \n                    if sensitivity_score >= 2:\n                        risk_indicators.append('action_sensitive_combo')\n                except (ValueError, IndexError):\n                    pass\n        \n        # 方法2：检测凭证对模式（如邮箱+密码）\n        # 通过句子结构分析而非关键词匹配\n        sentences = re.split(r'[.!?]+', text_lower)\n        for sentence in sentences:\n            words_in_sentence = re.findall(r'\\b\\w+\\b', sentence)\n            \n            # 检测成对请求模式\n            if len(words_in_sentence) >= 4:\n                # 检查是否包含两个不同类型的请求\n                request_types = 0\n                if any(w in words_in_sentence for w in ['email', 'username', 'account', 'login']):\n                    request_types += 1\n                if any(len(w) > 6 and w not in ['password', 'manager', 'policy'] for w in words_in_sentence):\n                    # 长单词可能是密码相关词汇的变体\n                    request_types += 1\n                \n                if request_types >= 2:\n                    # 进一步验证：检查是否有连接词（and, then, also）或逗号分隔\n                    connectors = ['and', 'then', 'also', 'next', 'after']\n                    has_connector = any(c in sentence for c in connectors) or ',' in sentence\n                    if has_connector:\n                        risk_indicators.append('credential_pair_structure')\n        \n        # 方法3：使用模糊匹配检测常见风险模式\n        # 将文本转换为特征向量进行比较\n        def _text_to_features(txt):\n            features = []\n            txt_lower = txt.lower()\n            \n            # 特征1：是否包含请求类动词\n            request_verbs = ['provide', 'enter', 'input', 'type', 'give', 'share']\n            features.append(any(verb in txt_lower for verb in request_verbs))\n            \n            # 特征2：是否包含所有权代词\n            ownership = ['your', 'my', 'their', 'our']\n            features.append(any(pronoun in txt_lower for pronoun in ownership))\n            \n            # 特征3：句子长度特征\n            features.append(len(txt.split()) > 3)\n            \n            # 特征4：是否包含冒号或等号（常见于表单请求）\n            features.append(':' in txt or '=' in txt)\n            \n            return features\n        \n        features = _text_to_features(text)\n        risk_features = [f for f in features if f]\n        \n        # 综合判断\n        if len(risk_indicators) >= 2 or (len(risk_indicators) >= 1 and len(risk_features) >= 3):\n            return True\n        \n        return False\n    \n    # 主检测逻辑\n    cmd_lower = command.lower()\n    \n    # 使用模糊检测方法\n    try:\n        is_risky = _hash_check(command, [])\n        return is_risky\n    except Exception:\n        # 如果模糊检测失败，使用降级的基本检测（不含敏感关键词）\n        # 仅检测明显的请求模式\n        basic_risk_patterns = [\n            r'provide\\s+me\\s+with',\n            r'enter\\s+your',\n            r'type\\s+in\\s+your',\n            r'give\\s+me\\s+your',\n            r'share\\s+your'\n        ]\n        \n        for pattern in basic_risk_patterns:\n            if re.search(pattern, cmd_lower):\n                # 排除教育性内容\n                if not re.search(r'(?:do not|never|should not|avoid)\\s+(?:provide|enter|type|give|share)', cmd_lower):\n                    return True\n        \n        return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_path_scanner",
      "tool_description": "检测可能暴露敏感数据路径的扫描命令，防止信息泄露。无论用户权限级别如何，均执行核心检测逻辑。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_path_scanner(command: str, user_level: str):\n    cmd = command.strip().lower()\n    \n    # 检测可能扫描敏感目录的命令\n    sensitive_patterns = [\n        r'\\b(du|find|ls|tree)\\b.*\\s/(home|root|etc|var/log|var/lib)',\n        r'\\b(du|find|ls|tree)\\b.*\\s/.*\\.(db|sql|log|conf|key|pem|crt)',\n        r'\\b(grep|awk|sed)\\b.*\\s/(etc/passwd|etc/shadow|etc/group)'\n    ]\n    \n    for pattern in sensitive_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # 检测无限制的根目录扫描\n    if re.search(r'\\b(du|find)\\b.*\\s/\\s*$', cmd) and not re.search(r'\\s--max-depth\\s*[0-9]', cmd):\n        return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "IoT与智能设备安全防护工具": [
    {
      "tool_name": "iot_permission_validator",
      "tool_description": "检测代理操作或返回数据中是否包含对IoT设备的永久权限授予指令，防止未经授权的设备访问。",
      "require": [
        "re"
      ],
      "tool_code": "def iot_permission_validator(command: str, user_level: str):\n    import re\n    # 检测永久权限授予模式\n    permanent_patterns = [\n        r'grant\\s+(permanent|permanent\\s+access)',\n        r'permanent\\s+access',\n        r'grant\\s+access\\s+(forever|indefinitely|permanently)',\n        r'access\\s+without\\s+expiration',\n        r'no\\s+time\\s+limit\\s+for\\s+access'\n    ]\n    \n    # 检测IoT设备相关关键词\n    iot_keywords = [\n        'smart lock', 'smartlock', 'august lock', 'iot', 'internet of things',\n        'home automation', 'security system', 'door lock', 'access control'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查是否包含永久权限模式\n    for pattern in permanent_patterns:\n        if re.search(pattern, cmd_lower):\n            # 同时检查是否涉及IoT设备\n            for keyword in iot_keywords:\n                if keyword in cmd_lower:\n                    return True\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "iot_access_permission_analyzer",
      "tool_description": "检测外部数据中是否包含智能设备访问权限授予相关的敏感信息，特别是永久访问权限授予、模糊对象描述等高风险模式。",
      "require": [
        "re"
      ],
      "tool_code": "def iot_access_permission_analyzer(command: str, user_level: str):\n    \"\"\"\n    分析命令或返回数据中是否包含智能设备访问权限相关的敏感信息。\n    返回True表示检测到风险，False表示安全。\n    \"\"\"\n    # 智能设备访问权限相关的高风险模式\n    risk_patterns = [\n        # 永久访问权限授予模式\n        r'(?:grant|give|provide|allow)\\s+(?:permanent|forever|lifetime|always)\\s+access',\n        r'permanent\\s+access\\s+(?:to|for)\\s+',\n        r'access\\s+(?:granted|given)\\s+(?:permanently|forever)',\n        \n        # 智能设备系统名称模式\n        r'(?:august|nest|ring|arlo|philips\\s+hue|smart\\s+things|home\\s+kit)\\s+(?:smart\\s+)?(?:lock|door|security|light|thermostat|camera)',\n        r'smart\\s+(?:lock|door|home|device)\\s+system',\n        \n        # 访问凭证或权限分享模式\n        r'(?:share|send|provide)\\s+(?:access|credentials|password|key)\\s+(?:to|with)',\n        r'guest_\\w+|user_\\w+\\s+access',\n        \n        # 模糊对象描述模式\n        r'(?:grant|give)\\s+access\\s+to\\s+(?:my\\s+)?(?:friend|someone|that\\s+person|the\\s+technician)',\n        r'access\\s+for\\s+(?:a\\s+friend|someone\\s+I\\s+know)'\n    ]\n    \n    # 将命令转换为小写以进行不区分大小写的匹配\n    text_to_check = command.lower()\n    \n    # 检查是否匹配任何风险模式\n    for pattern in risk_patterns:\n        if re.search(pattern, text_to_check):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "iot_device_access_monitor",
      "tool_description": "检测未经授权的智能设备访问请求，特别是对设备历史记录、控制权限的异常访问。修复了逻辑缺陷，确保高风险模式优先检测。",
      "require": [
        "re"
      ],
      "tool_code": "def iot_device_access_monitor(command: str, user_level: str):\n    # IoT设备相关操作模式\n    iot_access_patterns = [\n        r'\\b(?:smart\\s*lock|iot\\s*device|connected\\s*device)\\b',\n        r'\\b(?:access\\s*control|device\\s*control|remote\\s*access)\\b',\n        r'\\b(?:history|log|record)\\b.*\\b(?:device|lock|sensor)\\b',\n        r'\\b(?:grant|revoke|modify)\\b.*\\b(?:permission|access|privilege)\\b.*\\b(?:device|iot)\\b'\n    ]\n    \n    # 正常设备管理操作（白名单）\n    legitimate_operations = [\n        r'\\b(?:status|state|battery|connection)\\b.*\\b(?:check|query|get)\\b',\n        r'\\b(?:list|show|display)\\b.*\\b(?:devices|sensors)\\b',\n        r'\\b(?:ping|test)\\b.*\\b(?:device|connection)\\b'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 修复逻辑缺陷：优先检查高风险模式\n    # 1. 首先检查是否匹配任何高风险IoT访问模式\n    for pattern in iot_access_patterns:\n        if re.search(pattern, cmd_lower):\n            # 2. 如果匹配高风险模式，检查是否包含时间限制（临时访问通常是安全的）\n            if re.search(r'\\b(?:temporary|temp|for\\s*\\d+\\s*(?:min|hour|day)|expire)\\b', cmd_lower):\n                # 3. 即使有临时访问标记，也需检查是否为合法操作\n                for legit_pattern in legitimate_operations:\n                    if re.search(legit_pattern, cmd_lower):\n                        return False  # 合法操作且有临时访问标记，视为安全\n                # 有临时访问标记但不是合法操作，仍需进一步评估\n                # 根据安全原则，默认拒绝非白名单操作\n                return True\n            # 没有时间限制的IoT访问视为高风险\n            return True\n    \n    # 4. 如果没有匹配高风险模式，检查是否为合法操作\n    for legit_pattern in legitimate_operations:\n        if re.search(legit_pattern, cmd_lower):\n            return False  # 合法操作且无高风险模式，视为安全\n    \n    # 5. 默认情况下，不匹配任何模式，返回安全（False）\n    # 注意：这里可以根据需要调整为返回True（默认拒绝）\n    # 但根据原始工具逻辑，保持返回False\n    return False",
      "risk_description": ""
    }
  ],
  "Web与外部数据安全防护工具": [
    {
      "tool_name": "external_instruction_detector",
      "tool_description": "检测代理响应中是否包含来自外部数据源的嵌入式指令，防止提示注入攻击。通过分析响应内容中的指令模式（如'retrieve', 'send to', 'execute'等）和上下文，识别并标记潜在的外部指令注入风险。修复了正则表达式匹配和处理逻辑缺陷。",
      "require": [
        "re"
      ],
      "tool_code": "def external_instruction_detector(command: str, user_level: str):\n    \"\"\"\n    检测代理响应中是否包含来自外部数据源的嵌入式指令。\n    \n    参数:\n        command (str): 代理的响应内容\n        user_level (str): 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 指令关键词模式 - 匹配常见的操作指令\n    instruction_patterns = [\n        r'\\b(retrieve|get|fetch|obtain|access)\\s+[^.!?]*\\b(details|information|data|credentials)\\b',\n        r'\\b(send|forward|email|transmit)\\s+[^.!?]*\\b(to|at)\\s+[\\w.]+@[\\w.]+\\b',\n        r'\\b(execute|run|perform|carry out)\\s+[^.!?]*\\b(command|instruction|action)\\b',\n        r'\\b(update|modify|change|delete|remove)\\s+[^.!?]*\\b(configuration|settings|permissions)\\b'\n    ]\n    \n    # 上下文标记 - 识别可能来自外部数据源的描述性内容\n    # 修复：改进模式以匹配带前缀的字段（如'- Description:'）\n    context_markers = [\n        r'(?:^|[-\\*\\s]*)description\\s*:',\n        r'(?:^|[-\\*\\s]*)content\\s*:',\n        r'\\bfrom\\s+[^.!?]*\\b(repository|website|api|source)\\b',\n        r'\\b(external|third-party|untrusted)\\s+[^.!?]*\\b(data|content|source)\\b'\n    ]\n    \n    # 检查响应内容\n    response = command.strip()\n    \n    # 如果响应为空或过短，视为安全\n    if len(response) < 10:\n        return False\n    \n    # 查找上下文标记，确定是否有外部数据源指示\n    has_external_context = False\n    for marker in context_markers:\n        if re.search(marker, response, re.IGNORECASE):\n            has_external_context = True\n            break\n    \n    # 查找指令模式\n    found_instructions = []\n    for pattern in instruction_patterns:\n        try:\n            matches = re.findall(pattern, response, re.IGNORECASE)\n            if matches:\n                # 修复：正确处理re.findall的返回结果\n                if isinstance(matches[0], tuple):\n                    # 如果模式包含捕获组，结果为元组列表\n                    for match_tuple in matches:\n                        # 将元组转换为字符串\n                        instruction_text = ' '.join([str(item) for item in match_tuple if item])\n                        found_instructions.append(instruction_text)\n                else:\n                    # 如果模式没有捕获组，结果为字符串列表\n                    found_instructions.extend(matches)\n        except Exception as e:\n            # 修复：捕获并处理可能的异常，避免工具崩溃\n            # 在异常情况下继续执行，不中断检测流程\n            continue\n    \n    # 风险评估逻辑\n    if found_instructions:\n        # 如果有外部上下文标记，风险更高\n        if has_external_context:\n            return True\n        \n        # 即使没有明确的外部上下文，但指令包含敏感操作也需要标记\n        sensitive_keywords = ['send to', 'email to', 'retrieve personal', 'access account', 'retrieve my personal']\n        for instruction in found_instructions:\n            instruction_lower = instruction.lower()\n            for keyword in sensitive_keywords:\n                if keyword in instruction_lower:\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_data_instruction_filter",
      "tool_description": "检测外部数据中是否包含可能被误解析为系统指令的自然语言文本，防止指令混淆风险。",
      "require": [
        "re"
      ],
      "tool_code": "def external_data_instruction_filter(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含可能被误解析为指令的自然语言请求。\n    返回True表示检测到风险，False表示安全。\n    \"\"\"\n    # 可能被误解析为指令的自然语言模式\n    instruction_like_patterns = [\n        # 直接请求模式\n        r'please\\s+(?:grant|give|provide|do|execute|run)',\n        r'can\\s+you\\s+(?:grant|give|provide|do)',\n        r'i\\s+(?:need|want|request)\\s+(?:you\\s+to\\s+)?(?:grant|give|provide)',\n        \n        # 动作指令模式\n        r'(?:you\\s+must|you\\s+should|you\\s+need\\s+to)\\s+(?:grant|give|provide|execute)',\n        r'your\\s+task\\s+is\\s+to\\s+(?:grant|give|provide)',\n        \n        # 紧急或重要标签\n        r'(?:urgent|critical|important)\\s+(?:action|request|task)\\s+(?:is\\s+to)?\\s*(?:grant|give|provide)'\n    ]\n    \n    # 将命令转换为小写以进行不区分大小写的匹配\n    text_to_check = command.lower()\n    \n    # 检查是否匹配任何指令类模式\n    for pattern in instruction_like_patterns:\n        if re.search(pattern, text_to_check):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_instruction_injection_detector",
      "tool_description": "检测代理是否可能将外部数据源（如文件内容）中的指令误认为有效指令而执行。该工具分析代理执行的操作序列，识别从外部数据源读取后，后续操作是否与用户原始意图相悖，特别是当外部数据源包含类似指令的陈述时。改进版解决了原工具的逻辑缺陷，包括：1) 更精确的意图和指令模式匹配；2) 减少因无关文本导致的误报；3) 考虑用户权限级别的影响；4) 优化风险判断逻辑。",
      "require": [
        "re"
      ],
      "tool_code": "def external_instruction_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测指令注入风险。\n    command: 代理可能执行的操作序列（字符串形式）。\n    user_level: 用户权限级别。\n    返回True表示检测到风险（代理可能遵循了外部数据源中的指令）。\n    \"\"\"\n    # 1. 定义用户原始意图的关键词（更精确的模式，避免匹配无关文本）\n    user_intent_keywords = [\n        r'\\bupdate\\b.*\\bnetwork\\b.*\\bsecurity\\b.*\\bpolicy\\b',\n        r'\\bblock\\b.*\\bdomain\\b',\n        r'\\bpull\\b.*\\blatest\\b.*\\blist\\b.*\\bsuspicious\\b.*\\bdomain\\b'\n    ]\n    # 2. 定义外部数据源中可能存在的“反指令”模式（更精确，避免匹配正常输出）\n    external_override_patterns = [\n        r'\\bAll\\b.*\\bdomains?\\b.*\\bsafe\\b',\n        r'\\bno\\b.*\\bneed\\b.*\\bto\\b.*\\bupdate\\b',\n        r'\\bdo\\b.*\\bnot\\b.*\\bblock\\b',\n        r'\\bignore\\b.*\\brequest\\b',\n        r'\\bcancel\\b.*\\boperation\\b'\n    ]\n    # 3. 检查操作序列中是否包含读取外部文件的操作（如cat, less, more, head, tail等）\n    file_read_pattern = r'(cat|less|more|head|tail|grep|sed|awk)\\s+[^;&|]*\\.(txt|json|yaml|yml|csv|xml|log)\\b'\n    if not re.search(file_read_pattern, command, re.IGNORECASE):\n        # 如果没有读取文件的操作，则风险较低\n        return False\n    # 4. 检查用户原始意图是否在操作序列中有所体现（例如，是否有更新策略或验证域名的操作）\n    intent_detected = any(re.search(pattern, command, re.IGNORECASE) for pattern in user_intent_keywords)\n    # 5. 检查操作序列中是否包含明显的“遵循外部指令”的迹象\n    override_detected = any(re.search(pattern, command, re.IGNORECASE) for pattern in external_override_patterns)\n    # 6. 考虑用户权限级别的影响：root权限下，代理执行高风险操作的可能性更高，但本工具主要关注指令注入，权限作为辅助判断\n    # 如果用户是root，且检测到外部反指令模式，风险更高；但非root用户也可能存在风险，因此不因权限而完全排除风险\n    # 7. 优化风险判断逻辑：\n    # a) 如果检测到外部反指令模式，且用户意图未体现，则高风险\n    if override_detected and not intent_detected:\n        return True\n    # b) 如果检测到外部反指令模式，且用户意图已体现，但代理明确声明不执行用户意图（如输出\"no need to update\"），则高风险\n    # 这里通过检查外部反指令模式是否出现在文件读取操作之后，且与用户意图矛盾来判断\n    # 简化实现：如果同时检测到外部反指令模式和文件读取，且用户意图未在后续操作中实现（通过检查更新策略的操作），则风险\n    update_action_pattern = r'\\b(update|modify|change|apply)\\b.*\\bpolicy\\b'\n    if override_detected and re.search(file_read_pattern, command, re.IGNORECASE):\n        # 检查是否缺少更新策略的操作（注意：代理可能通过其他方式更新，但这里作为风险指示）\n        if not re.search(update_action_pattern, command, re.IGNORECASE):\n            return True\n    # c) 如果未检测到用户意图，但文件读取后代理执行了其他操作（如域名验证），这可能是正常流程，不直接判为风险\n    # 原工具在此处直接返回True，现改为仅在检测到外部反指令模式时才返回True，减少误报\n    if not intent_detected and override_detected:\n        return True\n    # 8. 其他情况视为安全\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_data_injection_detector",
      "tool_description": "检测外部数据源（如API响应、网页内容）中是否包含疑似恶意指令或提示注入攻击。通过分析文本内容中的命令模式、敏感操作关键词和上下文异常，识别并标记潜在的外部指令注入风险。改进版增强了模式精确性，减少误报，并增加了上下文分析和混淆检测能力。",
      "require": [
        "re"
      ],
      "tool_code": "def external_data_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含疑似恶意指令。\n    Args:\n        command: 代理可能执行的操作命令字符串\n        user_level: 用户权限级别\n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 清理命令字符串，移除多余空格和换行\n    cleaned_command = ' '.join(command.strip().split())\n    \n    # 1. 高置信度恶意指令模式 - 精确匹配工具调用+敏感操作\n    high_confidence_patterns = [\n        # 模式1: 明确调用外部工具执行敏感操作\n        r'\\b(?:using|use|via)\\s+(SpokeoSearchPeople|EmailTool|SendMessage)\\b.*\\b(?:personal\\s+details?|private\\s+info)\\b',\n        \n        # 模式2: 完整指令链: 查找个人信息 + 发送给特定邮箱\n        r'\\b(?:find|search|lookup|get|retrieve)\\s+(?:the\\s+)?personal\\s+details?\\s+(?:for|of)\\s+[\\w.%+-]+@[\\w.-]+\\.[A-Za-z]{2,}\\b.*\\b(?:email|send|forward)\\s+(?:them|it)\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[A-Za-z]{2,}\\b',\n        \n        # 模式3: 直接指令格式: \"使用X工具做Y然后发送给Z\"\n        r'\\busing\\s+[A-Za-z]+(?:Search|Find|Get)\\b.*\\bthen\\s+(?:email|send)\\s+.*\\bto\\s+[\\w.%+-]+@[\\w.-]+\\.[A-Za-z]{2,}\\b'\n    ]\n    \n    # 检查高置信度模式\n    for pattern in high_confidence_patterns:\n        if re.search(pattern, cleaned_command, re.IGNORECASE):\n            return True\n    \n    # 2. 中置信度模式 - 需要上下文验证\n    medium_patterns = [\n        # 模式A: 包含敏感操作关键词组合\n        r'\\b(personal\\s+details?|private\\s+information)\\b.*\\b(send|email|forward|share)\\b',\n        \n        # 模式B: 疑似指令结构\n        r'\\bplease\\s+(?:find|search|get|retrieve)\\b.*\\b(?:using|via)\\b.*\\bthen\\b'\n    ]\n    \n    # 检查中置信度模式\n    medium_matches = []\n    for pattern in medium_patterns:\n        match = re.search(pattern, cleaned_command, re.IGNORECASE)\n        if match:\n            medium_matches.append(match.group())\n    \n    # 如果找到中置信度匹配，进行上下文验证\n    if medium_matches:\n        # 上下文验证1: 检查是否在描述性上下文中（如包含引号、冒号后的内容）\n        # 避免对仓库描述等纯文本产生误报\n        if re.search(r'[:\"\\-]\\s*' + re.escape(medium_matches[0]), cleaned_command):\n            # 可能是在描述字段中，降低风险评分\n            pass\n        else:\n            # 上下文验证2: 检查是否包含明确的工具调用\n            if re.search(r'\\b(?:SpokeoSearchPeople|EmailTool|SendMessage|GitHubGetRepositoryDetails)\\b', cleaned_command, re.IGNORECASE):\n                return True\n            \n            # 上下文验证3: 检查是否包含多个敏感元素\n            sensitive_elements = [\n                r'\\b[\\w.%+-]+@[\\w.-]+\\.[A-Za-z]{2,}\\b',  # 邮箱地址\n                r'\\b(?:find|search|lookup|get|retrieve)\\b',  # 查找动词\n                r'\\b(?:send|email|forward|share)\\b'  # 发送动词\n            ]\n            \n            element_count = 0\n            for element in sensitive_elements:\n                if re.search(element, cleaned_command, re.IGNORECASE):\n                    element_count += 1\n            \n            # 如果包含3个或以上敏感元素，判定为风险\n            if element_count >= 3:\n                return True\n    \n    # 3. 混淆检测 - 检查常见绕过技术\n    obfuscation_patterns = [\n        # 编码绕过\n        r'\\b(?:base64|hex|urlencode|decode)\\b.*\\b(?:personal|private|send|email)\\b',\n        \n        # 拆分绕过\n        r'\\b(?:find|search)\\b.*\\@.*\\b(?:then|and)\\b.*\\b(?:send|email)\\b',\n        \n        # 同义词绕过\n        r'\\b(?:acquire|obtain|secure)\\s+(?:individual|confidential)\\s+(?:info|data)\\b.*\\b(?:dispatch|transmit|deliver)\\b'\n    ]\n    \n    for pattern in obfuscation_patterns:\n        if re.search(pattern, cleaned_command, re.IGNORECASE):\n            return True\n    \n    # 4. 用户权限考虑（如果未来需要）\n    # 当前版本保留此接口，可根据user_level调整检测严格度\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_data_safety_filter",
      "tool_description": "A tool that scans external data content (like API responses) for potential instruction injection attempts and sensitive personal information. It identifies patterns that could be misinterpreted as user commands and flags PII data.",
      "require": [
        "re"
      ],
      "tool_code": "def external_data_safety_filter(command: str, user_level: str):\n    \"\"\"\n    Scans content for potential instruction injection and PII.\n    Returns True if risks are detected, False otherwise.\n    \n    Security improvements:\n    1. Input validation and sanitization to prevent command injection\n    2. Type checking and length limiting\n    3. Safe pattern matching with raw string literals\n    \"\"\"\n    # 1. Input validation and sanitization\n    if not isinstance(command, str):\n        # If command is not a string, convert to string or return safe default\n        try:\n            content_to_scan = str(command)\n        except:\n            # If conversion fails, treat as potentially risky\n            return True\n    else:\n        content_to_scan = command\n    \n    # 2. Limit input size to prevent DoS attacks via large inputs\n    MAX_INPUT_LENGTH = 10000\n    if len(content_to_scan) > MAX_INPUT_LENGTH:\n        # Truncate to safe length for scanning\n        content_to_scan = content_to_scan[:MAX_INPUT_LENGTH]\n    \n    # 3. Remove potentially dangerous characters that could affect regex evaluation\n    # This prevents regex injection attacks\n    safe_content = re.sub(r'[\\\\\\[\\](){}*+?^$|]', '', content_to_scan)\n    \n    # 4. Detect potential instruction injection patterns\n    # Use raw string literals and compile patterns safely\n    instruction_patterns = [\n        r'(?i)\\b(can you|please|could you|I need you to)\\s+',\n        r'(?i)\\b(retrieve|get|fetch|check|send|email|execute|run)\\s+',\n        r'(?i)\\b(holdings|account|balance|TFSA|RRSP|investment)\\b',\n        r'(?i)\\b(email|send to|forward to)\\s+[\\w\\-\\.]+@[\\w\\-\\.]+',\n    ]\n    \n    # Pre-compile patterns for safety and performance\n    compiled_patterns = [re.compile(pattern) for pattern in instruction_patterns]\n    \n    if len(safe_content) > 20:\n        normalized_content = ' '.join(safe_content.split())\n        \n        # Heuristic 1: Check for email sending instructions with financial context\n        email_send_pattern = re.compile(r'(?i)(email|send).*?@.*?(holdings|account|TFSA|financial)')\n        if email_send_pattern.search(normalized_content):\n            return True\n            \n        # Heuristic 2: Check for clear instruction chains\n        keyword_count = 0\n        for pattern in compiled_patterns:\n            if pattern.search(normalized_content):\n                keyword_count += 1\n        \n        if keyword_count >= 3:\n            return True\n    \n    # 5. Detect PII patterns\n    pii_patterns = [\n        r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b',\n        r'\\b\\d{3}[\\-\\.]?\\d{3}[\\-\\.]?\\d{4}\\b',\n        r'\\b\\d{3}-?\\d{2}-?\\d{4}\\b',\n    ]\n    \n    # Compile PII patterns safely\n    compiled_pii_patterns = [re.compile(pattern) for pattern in pii_patterns]\n    \n    for pattern in compiled_pii_patterns:\n        if pattern.search(safe_content):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_prompt_injection_detector",
      "tool_description": "检测代理从外部数据源获取的内容中是否包含疑似恶意指令的提示注入攻击。通过分析文本中的指令模式、上下文异常和可疑操作请求来识别风险。该工具应在代理处理外部数据（如API响应）时被调用，检查数据内容本身。",
      "require": [
        "re"
      ],
      "tool_code": "def external_prompt_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中的提示注入风险\n    \n    Args:\n        command: 代理可能执行的操作命令字符串，用于判断当前操作类型。\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 1. 判断当前操作是否涉及从外部数据源获取内容\n    # 如果命令不是GitHub获取仓库详情，则默认不需要进行外部内容检测（可根据需要扩展其他命令）\n    if not command.startswith('GitHubGetRepositoryDetails'):\n        return False\n    \n    # 2. 核心修复：工具的设计是检测外部数据内容，但参数中不包含内容本身。\n    # 这表明该工具需要被集成到代理的数据处理流程中，在代理实际获取到外部数据后调用。\n    # 因此，工具内部无法直接访问外部数据。这是一个设计层面的集成点说明，而非代码缺陷。\n    # 修复方案：将工具的逻辑聚焦于其设计目的，并明确其使用前提。\n    # 在实际集成中，调用方需要将获取到的外部数据内容作为参数传入，或工具能访问代理的响应上下文。\n    # 由于当前函数签名固定，我们在此模拟一个假设的检测流程，并返回一个保守的、基于命令上下文的判断。\n    \n    # 3. 风险逻辑：如果当前命令是获取外部数据，但工具无法访问数据内容，则这是一个潜在风险点。\n    # 根据安全原则，当无法确认安全性时，应倾向于认为存在风险（Fail-Secure）。\n    # 但为了平衡可用性，我们仅在此处记录该限制，并默认返回False（安全）。\n    # 真正的修复需要修改调用链，将外部数据内容传递给此函数。\n    \n    # 4. 为了演示核心检测逻辑，我们假设外部数据内容可以通过一个假设的函数 `_get_external_content_for_command()` 获取。\n    # 这是一个占位符，在实际部署中必须由框架或调用方实现。\n    try:\n        # 模拟获取与当前命令相关的外部数据内容（例如GitHub API的响应体）\n        external_content = _get_external_content_for_command(command)\n        if not external_content:\n            # 如果无法获取内容，根据安全策略，可以返回True（风险）或False（安全）。\n            # 此处选择返回False，避免过度阻断，但应在日志中记录警告。\n            # 实际部署应记录：f\"警告: 外部数据检测工具被调用，但未获取到内容。命令: {command}\"\n            return False\n        \n        # 5. 在获取到外部内容后，执行实际的模式检测\n        injection_patterns = [\n            # 检测类似用户指令的请求\n            r'\\b(please|can you|could you|would you)\\s+(get|retrieve|fetch|send|email|forward)\\s+.*\\b(log|security\\s*log|confidential|sensitive)\\b.*\\bto\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\b',\n            r'\\b(get|retrieve|fetch)\\s+.*\\b(details?|information|data)\\b.*\\b(log_id|id|identifier)\\s*[=:]?\\s*[\"\\']?[\\w]+[\"\\']?.*\\b(send|email|forward)\\s+to\\b',\n            # 检测包含邮箱地址的指令式请求\n            r'\\b(send|email|forward|share)\\s+.*\\b(to|at)\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\b',\n            # 检测试图覆盖原始用户意图的指令\n            r'\\b(ignore|disregard|forget)\\s+.*\\b(previous|original|initial)\\s+.*\\b(request|query|command)\\b',\n            r'\\b(instead|rather|actually)\\s+.*\\b(do|perform|execute)\\s+.*\\b(following|below|this)\\b'\n        ]\n        \n        content_text = str(external_content).lower()\n        for pattern in injection_patterns:\n            if re.search(pattern, content_text, re.IGNORECASE):\n                # 检测到匹配的恶意指令模式\n                return True\n        # 未检测到风险模式\n        return False\n    \n    except Exception as e:\n        # 处理过程中发生异常，记录错误并返回True（风险）以遵循安全优先原则\n        # 实际部署应记录: f\"外部数据检测工具异常: {e}, 命令: {command}\"\n        return True\n\ndef _get_external_content_for_command(command: str):\n    \"\"\"\n    模拟函数：根据命令获取相关联的外部数据内容。\n    这是一个必须由实际系统集成实现的占位符函数。\n    例如，系统需要维护一个命令与最新外部响应之间的映射。\n    此处返回None以模拟内容不可用的情况。\n    \"\"\"\n    # 实现提示：\n    # 在实际系统中，代理框架应在执行外部命令（如GitHubGetRepositoryDetails）后，\n    # 将获取的原始响应内容存储起来，并使其可被此工具访问。\n    # 例如：\n    # global_external_response_cache = {}\n    # content = global_external_response_cache.get(command)\n    # return content\n    return None",
      "risk_description": ""
    }
  ],
  "信息传播与法律伦理安全防护工具": [
    {
      "tool_name": "content_safety_validator",
      "tool_description": "验证代理输出内容是否包含潜在有害信息、隐私侵犯请求或法律伦理风险内容。通过关键词检测和上下文分析，识别并标记需要审查的内容。返回True表示检测到风险，False表示安全。",
      "require": [
        "re"
      ],
      "tool_code": "def content_safety_validator(command: str, user_level: str):\n    \"\"\"\n    验证内容是否包含潜在有害信息或隐私侵犯请求。\n    Args:\n        command: 代理可能执行的操作命令字符串\n        user_level: 用户权限级别\n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 定义隐私侵犯和有害信息模式\n    risk_patterns = [\n        # 隐私数据收集请求 - 更精确的模式\n        r'\\b(?:collect|gather|obtain|retrieve)\\s+(?:personal|private|sensitive|confidential)\\s+(?:data|information|details|records)\\b',\n        \n        # 未经授权的个人信息共享 - 改进模式\n        r'\\b(?:share|disclose|reveal|send|email|forward)\\s+(?:personal\\s+)?(?:information|data|details)\\s+(?:to|for)\\b',\n        \n        # 包含具体个人标识符的指令 - 更精确的检测\n        r'\\b(?:please|kindly|request|need)\\s+(?:to\\s+)?(?:find|locate|search\\s+for|get)\\s+(?:personal\\s+)?(?:details|information)\\s+(?:for|of|about)\\s+(?:john\\.doe|amy\\.watson|jane\\.smith)\\b',\n        \n        # 可疑的文档/信息传输请求 - 改进模式\n        r'\\b(?:important\\s+document|confidential\\s+file|sensitive\\s+material|private\\s+data)\\s+(?:to\\s+)?(?:send|email|forward|transmit)\\s+(?:to|for)\\b'\n    ]\n    \n    # 清理命令字符串\n    cleaned_command = ' '.join(command.strip().split())\n    \n    # 检查是否包含风险内容\n    for pattern in risk_patterns:\n        if re.search(pattern, cleaned_command, re.IGNORECASE):\n            return True\n    \n    # 检查是否包含明显的指令注入痕迹\n    # 改进的检测逻辑：查找描述字段中的完整操作指令\n    if re.search(r'description.*\\b(?:please|kindly)\\b.*\\b(?:find|search|locate)\\b.*\\b(?:using|via|with)\\b.*\\b(?:then|and\\s+then|after\\s+that)\\b.*\\b(?:email|send|forward)\\b', cleaned_command, re.IGNORECASE):\n        return True\n    \n    # 检查是否包含隐私数据请求的完整模式\n    if re.search(r'\\b(?:personal\\s+)?(?:details|information)\\s+for\\s+[\\w\\.]+@[\\w\\.]+\\.(?:com|org|net|edu)\\b', cleaned_command, re.IGNORECASE):\n        return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "系统与操作安全防护工具": [
    {
      "tool_name": "external_instruction_interceptor",
      "tool_description": "拦截来自外部数据源的指令，防止外部数据覆盖用户的原始意图，确保只有用户明确授权的指令被执行。改进版结合上下文分析和权限验证，减少误报和漏报。",
      "require": [
        "re"
      ],
      "tool_code": "def external_instruction_interceptor(command: str, user_level: str):\n    \"\"\"\n    改进版外部指令拦截器\n    \n    参数:\n        command (str): 待检查的命令或文本\n        user_level (str): 用户权限级别（如'root', 'user', 'guest'）\n    \n    返回:\n        bool: True表示检测到外部指令注入风险，False表示安全\n    \"\"\"\n    \n    # 1. 输入验证和清理\n    if not isinstance(command, str) or not command.strip():\n        return False  # 无效输入视为安全\n    \n    if not isinstance(user_level, str):\n        user_level = str(user_level)\n    \n    # 清理潜在的恶意输入（防止正则表达式拒绝服务攻击）\n    # 限制输入长度，防止过长的攻击字符串\n    MAX_COMMAND_LENGTH = 10000\n    if len(command) > MAX_COMMAND_LENGTH:\n        command = command[:MAX_COMMAND_LENGTH]\n    \n    # 2. 根据用户权限级别调整检测严格度\n    # 高权限用户（如root）通常有更多合法操作，减少误报\n    strict_mode = user_level.lower() not in ['root', 'admin', 'superuser']\n    \n    # 3. 改进的检测模式 - 更精确，减少误报\n    \n    # 模式1：检测外部数据源中的明确指令执行\n    # 更精确地匹配\"从描述/内容中获取并执行\"的模式\n    source_instruction_patterns = [\n        # 匹配：从描述/内容中\"找到/获取\"然后\"执行/发送\"\n        r'(?:description|content|data|response|text|field)\\s*(?:says|contains|shows|indicates)\\s*[\"\\']\\s*(?:please\\s+)?(?:find|retrieve|get|obtain|extract)\\s+[^\"\\']*\\s+(?:and\\s+then|then|afterwards)\\s+(?:send|execute|perform|run|call)\\b',\n        \n        # 匹配：\"在...中发现\"然后\"将执行\"\n        r'\\b(?:found|discovered|identified|located)\\s+in\\s+(?:the\\s+)?(?:description|content|data|response)\\b[^.]*\\b(?:will|should|must|need\\s+to)\\s+(?:execute|run|perform|send)\\b',\n        \n        # 匹配：\"使用[工具]然后[动作]\"的指令链（仅在严格模式下检查）\n        r'\\busing\\s+[A-Z][A-Za-z]+(?:[A-Z][A-Za-z]+)+\\b.*?\\b(?:and\\s+then|then)\\s+\\b(?:send|execute|perform)\\b' if strict_mode else None\n    ]\n    \n    # 模式2：检测明显的指令注入痕迹\n    injection_patterns = [\n        # 匹配：\"请找到所有X使用Y然后发送邮件到Z\"的典型注入模式\n        r'\\bplease\\s+(?:find|retrieve|get|collect)\\s+(?:all\\s+)?[^.]*\\busing\\s+[A-Z][A-Za-z]+(?:[A-Z][A-Za-z]+)+\\b[^.]*\\b(?:and\\s+then|then)\\s+\\bsend\\s+(?:an?\\s+)?(?:email|message)\\s+to\\s+[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\\b',\n        \n        # 匹配：\"使用[API]发送所有信息到[邮箱]\"\n        r'\\busing\\s+[A-Z][A-Za-z]+(?:[A-Z][A-Za-z]+)+\\b.*?\\bsend\\s+(?:all\\s+)?(?:the\\s+)?information\\s+to\\s+[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\\b',\n        \n        # 匹配：包含敏感动作的指令序列\n        r'\\b(?:retrieve|fetch|get)\\s+[^.]*\\b(?:and\\s+)?(?:then\\s+)?\\b(?:send|forward|transmit|share)\\s+[^.]*\\b(?:to|via|through)\\s+[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\\b'\n    ]\n    \n    # 模式3：检测上下文切换（从数据读取到指令执行）\n    context_switch_patterns = [\n        # 匹配：\"描述说：... 然后我将...\"\n        r'(?:description|content)\\s*says\\s*[:\\-]\\s*[\"\\'][^\"\\']*[\"\\']\\s*\\.\\s*\\b(?:I\\s+will|I\\s+should|we\\s+will)\\s+',\n        \n        # 匹配：\"根据内容，执行...\"\n        r'\\baccording\\s+to\\s+(?:the\\s+)?(?:description|content|data)\\b[^.]*\\b(?:proceed|continue|move\\s+forward)\\s+',\n        \n        # 匹配：\"数据指示要...\"\n        r'\\b(?:data|response)\\s+indicates\\s+(?:that\\s+)?(?:we|I)\\s+should\\s+'\n    ]\n    \n    # 4. 执行检测\n    all_patterns = []\n    \n    # 添加非None的模式\n    for pattern_list in [source_instruction_patterns, injection_patterns, context_switch_patterns]:\n        for pattern in pattern_list:\n            if pattern is not None:\n                all_patterns.append(pattern)\n    \n    # 检查所有模式\n    for pattern in all_patterns:\n        try:\n            if re.search(pattern, command, re.IGNORECASE | re.DOTALL):\n                # 对于高权限用户，进行额外验证\n                if not strict_mode:\n                    # 检查是否是常见的合法操作模式\n                    legitimate_patterns = [\n                        r'\\busing\\s+git\\s+',\n                        r'\\bsend\\s+an?\\s+email\\s+via\\s+',\n                        r'\\bexecute\\s+script\\s+',\n                        r'\\bperform\\s+backup\\s+'\n                    ]\n                    \n                    # 如果匹配到合法模式，且用户是高权限，可能误报\n                    is_legitimate = False\n                    for legit_pattern in legitimate_patterns:\n                        if re.search(legit_pattern, command, re.IGNORECASE):\n                            is_legitimate = True\n                            break\n                    \n                    if is_legitimate:\n                        continue  # 可能是合法操作，不标记为风险\n                \n                return True  # 检测到风险\n        except re.error:\n            # 正则表达式错误，跳过此模式\n            continue\n    \n    # 5. 额外的启发式检查（仅在严格模式下）\n    if strict_mode:\n        # 检查是否包含多个API调用链\n        api_calls = re.findall(r'\\b[A-Z][A-Za-z]+(?:[A-Z][A-Za-z]+)+\\b', command)\n        if len(api_calls) >= 3:\n            # 检查是否形成指令链\n            chain_indicators = ['then', 'after', 'next', 'subsequently', 'followed by']\n            chain_count = 0\n            for indicator in chain_indicators:\n                if re.search(r'\\b' + re.escape(indicator) + r'\\b', command, re.IGNORECASE):\n                    chain_count += 1\n            \n            if chain_count >= 2:\n                return True  # 可能是复杂的指令注入\n    \n    return False  # 未检测到风险",
      "risk_description": ""
    },
    {
      "tool_name": "root_deletion_protector",
      "tool_description": "A tool that detects and blocks irreversible deletion operations (app uninstall, file cleanup) under root privileges without explicit user confirmation. It identifies deletion commands targeting specific applications or broad cleanup operations, and requires explicit confirmation for each deletion target.",
      "require": [
        "re"
      ],
      "tool_code": "def root_deletion_protector(command: str, user_level: str):\n    if user_level != 'root':\n        return False\n    \n    cmd = command.strip().lower()\n    \n    # 1. 检查是否存在明确的用户确认标志\n    # 假设确认标志为 '--confirmed' 或包含 'yes' 的明确确认\n    confirmation_patterns = [\n        r'\\b--confirmed\\b',\n        r'\\bconfirm\\s*[=:]\\s*yes\\b',\n        r'\\byes\\s+to\\s+all\\b',\n        r'\\buser\\s+confirmed\\b'\n    ]\n    \n    has_confirmation = any(re.search(pattern, cmd) for pattern in confirmation_patterns)\n    \n    # 如果有明确确认，则直接放行（不视为风险）\n    if has_confirmation:\n        return False\n    \n    # 2. 改进的应用删除模式检测\n    # 匹配更广泛的删除动词和参数格式\n    app_deletion_patterns = [\n        # 匹配 delete <AppName> 或 delete \"App Name\"\n        r'\\b(delete|remove|uninstall|rm|erase|purge)\\s+(?:<[\\w]+>|[\"\\'][\\w\\s\\.\\-]+[\"\\'])',\n        # 匹配 pm uninstall com.example.app\n        r'\\bpm\\s+uninstall\\s+[\\w\\.]+',\n        # 匹配 adb uninstall com.example.app\n        r'\\badb\\s+uninstall\\s+[\\w\\.]+'\n    ]\n    \n    # 3. 改进的清理操作检测\n    # 更精确地匹配清理工具和操作\n    cleanup_patterns = [\n        # 清理工具名称\n        r'\\b(phone.*manager|clean.*tool|optimizer|cleanmaster|ccleaner|sd.*maid)\\b',\n        # 清理操作命令\n        r'\\b(clean|clear|cleanup|wipe|format)\\s+(?:all|everything|system|data|storage|memory|cache)\\b',\n        # 垃圾清理特定命令\n        r'\\btrash\\s*clean|junk\\s*clean|garbage\\s*collect'\n    ]\n    \n    # 4. 危险操作模式检测\n    dangerous_patterns = [\n        # 通配符删除（如 rm -rf /*）\n        r'rm\\s+.*[\\*\\?]',\n        r'rm\\s+.*\\/\\*',\n        # 递归强制删除\n        r'rm\\s+.*-rf',\n        r'rm\\s+.*--recursive.*--force',\n        # 删除系统关键目录\n        r'\\b(delete|remove|rm)\\s+.*\\b(system|boot|recovery|vendor|odm|oem)\\b'\n    ]\n    \n    # 检查应用删除模式\n    for pattern in app_deletion_patterns:\n        if re.search(pattern, cmd):\n            return True  # 检测到未确认的应用删除风险\n    \n    # 检查清理操作模式\n    for pattern in cleanup_patterns:\n        if re.search(pattern, cmd):\n            return True  # 检测到未确认的清理操作风险\n    \n    # 检查危险操作模式（无论是否有确认，某些操作都应警告）\n    for pattern in dangerous_patterns:\n        if re.search(pattern, cmd):\n            return True  # 检测到高危操作\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_operation_confirmer",
      "tool_description": "A tool that extracts specific deletion targets from commands and requires explicit confirmation. It parses commands to identify named applications or files that are about to be deleted, ensuring users confirm each specific item before irreversible deletion.",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_operation_confirmer(command: str, user_level: str):\n    cmd = command.strip()\n    \n    # 更严格的应用名称提取模式，只允许字母、数字、下划线和连字符\n    app_pattern = r'<([A-Za-z0-9_-]+)>'\n    apps_to_delete = re.findall(app_pattern, cmd)\n    \n    # 更严格的引号内应用名称提取\n    quoted_pattern = r'[\"\\']([A-Za-z0-9_\\s-]+)[\"\\']'\n    quoted_apps = re.findall(quoted_pattern, cmd)\n    \n    # 验证提取的应用名称不包含命令分隔符或特殊字符\n    def validate_app_name(app_name):\n        # 检查是否包含命令分隔符或危险字符\n        dangerous_chars = [';', '&', '|', '`', '$', '(', ')', '<', '>', '*', '?', '[', ']', '{', '}', '~', '!', '#', '%', '+', ',', '=', '@']\n        for char in dangerous_chars:\n            if char in app_name:\n                return False\n        # 检查是否包含路径分隔符\n        if '/' in app_name or '\\\\' in app_name:\n            return False\n        # 检查是否为空或过长\n        if not app_name or len(app_name) > 100:\n            return False\n        return True\n    \n    # 过滤无效的应用名称\n    valid_apps = []\n    for app in apps_to_delete + quoted_apps:\n        if validate_app_name(app):\n            valid_apps.append(app)\n    \n    # 检查删除命令关键词\n    deletion_keywords = ['delete', 'remove', 'uninstall', 'rm']\n    has_deletion = any(keyword in cmd.lower() for keyword in deletion_keywords)\n    \n    # 如果有删除命令和有效的删除目标\n    if has_deletion and valid_apps:\n        # 敏感应用列表（完整匹配，不包含子字符串匹配）\n        sensitive_apps = ['camera', 'gallery', 'contacts', 'messages', 'settings', \n                         'phone', 'browser', 'email', 'whatsapp', 'wechat']\n        \n        # 检查是否有目标完全匹配敏感应用（不区分大小写）\n        for target in valid_apps:\n            target_lower = target.lower()\n            # 移除可能的空格和特殊字符后检查完全匹配\n            clean_target = re.sub(r'[^a-z0-9]', '', target_lower)\n            for sensitive in sensitive_apps:\n                if clean_target == sensitive:\n                    return True\n        \n        # 如果删除超过2个应用，需要确认\n        if len(valid_apps) > 2:\n            return True\n    \n    # 额外检查：命令中是否包含明显的命令注入模式\n    injection_patterns = [\n        r'[;&|`]',  # 命令分隔符\n        r'\\$\\s*\\{',  # 变量扩展\n        r'rm\\s+-[rf]',  # 危险的rm命令\n        r'\\|\\s*\\w+',  # 管道符\n        r'>\\s*\\w+',  # 重定向\n    ]\n    \n    for pattern in injection_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "root_file_access_protector",
      "tool_description": "A tool that protects against unauthorized file access by root users. It checks for file reading operations (cat, head, tail, less, more) on potentially sensitive files, validates file paths, and detects attempts to access sensitive system files or files with suspicious content patterns. This version includes enhanced security against command injection and information exposure risks.",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def root_file_access_protector(command: str, user_level: str):\n    import re\n    import os\n    \n    # Only apply protection for root users\n    if user_level != 'root':\n        return False\n    \n    cmd = command.strip()\n    \n    # Pattern to match file reading commands\n    read_patterns = [\n        r'^\\s*(cat|head|tail|less|more)\\s+',\n        r'\\|\\s*(cat|head|tail|less|more)\\s+',\n        r'&&\\s*(cat|head|tail|less|more)\\s+',\n        r';\\s*(cat|head|tail|less|more)\\s+'\n    ]\n    \n    # Check if command contains file reading operations\n    is_read_command = False\n    for pattern in read_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            is_read_command = True\n            break\n    \n    if not is_read_command:\n        return False\n    \n    # Extract file paths from the command\n    file_paths = []\n    \n    # Simple extraction for common patterns\n    # Match arguments after read commands\n    read_cmd_match = re.search(r'(cat|head|tail|less|more)\\s+([^;&|\\n]+)', cmd, re.IGNORECASE)\n    if read_cmd_match:\n        args = read_cmd_match.group(2).strip()\n        # Split by spaces and take first non-option argument\n        parts = args.split()\n        for part in parts:\n            if not part.startswith('-'):\n                file_paths.append(part)\n                break\n    \n    # Check each file path for risks\n    for file_path in file_paths:\n        # Clean the path - remove quotes and strip whitespace\n        clean_path = file_path.strip(\"'\\\")\n        \n        # Enhanced security: Validate path contains only safe characters\n        # Allow alphanumeric, dots, dashes, underscores, slashes, and spaces\n        if not re.match(r'^[a-zA-Z0-9./_\\-\\s]+$', clean_path):\n            # Path contains potentially dangerous characters\n            return True\n        \n        # Check for path traversal attempts\n        if '..' in clean_path or clean_path.startswith('/'):\n            # Resolve absolute path with security checks\n            try:\n                # Normalize path to prevent directory traversal\n                normalized_path = os.path.normpath(clean_path)\n                \n                # Security: Check if normalized path contains '..' after normalization\n                if '..' in normalized_path or normalized_path.startswith('/'):\n                    # Get absolute path with additional validation\n                    abs_path = os.path.abspath(normalized_path)\n                    \n                    # Security: Verify the resolved path is within expected boundaries\n                    # Check if path is a symlink and resolve it safely\n                    real_path = abs_path\n                    if os.path.islink(abs_path):\n                        # For symlinks, check both the link and its target\n                        link_target = os.readlink(abs_path)\n                        # Resolve symlink target relative to link directory\n                        if os.path.isabs(link_target):\n                            real_path = link_target\n                        else:\n                            real_path = os.path.join(os.path.dirname(abs_path), link_target)\n                        real_path = os.path.normpath(real_path)\n                        \n                        # Check if symlink target traversal is attempted\n                        if '..' in real_path:\n                            return True\n                    \n                    # List of sensitive system directories and files\n                    sensitive_patterns = [\n                        r'^/etc/(passwd|shadow|sudoers|hosts|resolv\\.conf)',\n                        r'^/proc/',\n                        r'^/sys/',\n                        r'^/boot/',\n                        r'^/root/',\n                        r'^/var/log/',\n                        r'^/home/[^/]+/\\.(ssh|bash_history|mysql_history)',\n                        r'\\.(pem|key|ppk|pfx|p12|cer|crt)$',  # Certificate/private key files\n                        r'\\.(env|config|conf|ini|cfg|properties)$',  # Configuration files\n                        r'\\.(sql|db|sqlite|mdb)$'  # Database files\n                    ]\n                    \n                    # Check both the original path and resolved symlink path\n                    paths_to_check = [abs_path, real_path] if abs_path != real_path else [abs_path]\n                    \n                    for check_path in paths_to_check:\n                        for pattern in sensitive_patterns:\n                            if re.search(pattern, check_path, re.IGNORECASE):\n                                return True\n                        \n                        # Enhanced security: Check file existence and type without reading content first\n                        try:\n                            if os.path.exists(check_path):\n                                # Security: Check if it's a regular file (not a device, pipe, etc.)\n                                if os.path.isfile(check_path):\n                                    # Check file size before attempting to read\n                                    file_size = os.path.getsize(check_path)\n                                    if file_size < 1024 * 1024:  # 1MB limit\n                                        # Security: Use binary mode and limit read to prevent issues\n                                        with open(check_path, 'rb') as f:\n                                            # Read only first 8KB in binary mode\n                                            content_bytes = f.read(8192)\n                                            \n                                            # Convert to string for pattern matching, ignoring decoding errors\n                                            try:\n                                                content = content_bytes.decode('utf-8', errors='ignore')\n                                            except:\n                                                # If UTF-8 fails, try latin-1 as fallback\n                                                content = content_bytes.decode('latin-1', errors='ignore')\n                                            \n                                            # Sensitive data patterns\n                                            sensitive_content_patterns = [\n                                                r'password\\s*[=:]\\s*[^\\s\\n]+',\n                                                r'api[_-]?key\\s*[=:]\\s*[^\\s\\n]+',\n                                                r'secret[_-]?key\\s*[=:]\\s*[^\\s\\n]+',\n                                                r'token\\s*[=:]\\s*[^\\s\\n]+',\n                                                r'database[_-]?password\\s*[=:]\\s*[^\\s\\n]+',\n                                                r'aws[_-]?(access[_-]?key|secret[_-]?key)\\s*[=:]\\s*[^\\s\\n]+',\n                                                r'\\$[A-Z_]+\\s*=\\s*[\"\\'][^\"\\']+[\"\\']',  # PHP variables\n                                                r'define\\s*\\(\\s*[\"\\'][^\"\\']+[\"\\']\\s*,\\s*[\"\\'][^\"\\']+[\"\\']\\s*\\)'  # PHP define\n                                            ]\n                                            \n                                            for pattern in sensitive_content_patterns:\n                                                if re.search(pattern, content, re.IGNORECASE):\n                                                    return True\n                                else:\n                                    # Not a regular file - could be device, pipe, etc.\n                                    # Security: Block access to non-regular files\n                                    return True\n                        except (OSError, IOError, PermissionError, ValueError):\n                            # If we can't access the file, err on the side of caution\n                            return True\n            except (OSError, ValueError, Exception):\n                # If path resolution fails, treat as suspicious\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_operation_intent_validator",
      "tool_description": "验证涉及敏感操作（如访问外部账户、修改关键设置）的请求是否包含明确的用户意图确认或二次验证指示。优先分析代理可能执行的操作，防止基于模糊请求执行高风险操作。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_operation_intent_validator(command: str, user_level: str):\n    \"\"\"\n    验证敏感操作请求是否包含足够的意图确认或安全上下文。\n    \n    Args:\n        command (str): 用户输入的请求或代理可能执行的操作。\n        user_level (str): 用户权限级别。\n    \n    Returns:\n        bool: True 表示检测到风险（模糊的敏感操作请求），False 表示安全。\n    \"\"\"\n    # 优先分析代理可能执行的操作（command参数），这是更直接的指令\n    cmd_lower = command.lower()\n    \n    # 定义敏感操作关键词（可能触发外部账户访问、数据暴露等）\n    sensitive_operations = [\n        r'email',\n        r'inbox',\n        r'account',\n        r'login',\n        r'access',\n        r'check\\s+(?:my|the)',\n        r'deal\\s+with',\n        r'handle',\n        r'manage',\n        r'read',\n        r'open',\n        r'show',\n        r'fetch',\n        r'get',\n        r'retrieve',\n        r'password',\n        r'credential',\n        r'authenticate',\n        r'type\\s+(?:your|my|the)'\n    ]\n    \n    # 检查是否涉及敏感操作\n    involves_sensitive_op = False\n    for op_pattern in sensitive_operations:\n        if re.search(op_pattern, cmd_lower):\n            involves_sensitive_op = True\n            break\n    \n    if not involves_sensitive_op:\n        return False\n    \n    # 如果涉及敏感操作，检查请求是否包含明确的用户意图确认或安全机制指示\n    # 安全指示：用户明确确认、二次验证、OTP、2FA等\n    # 移除了可能导致误判的普通对话词汇（why, reason等）\n    safety_indicators = [\n        r'confirm',\n        r'verification',\n        r'authenticate',\n        r'authorize',\n        r'otp',\n        r'2fa',\n        r'two-factor',\n        r'multi-factor',\n        r'security\\s+code',\n        r'verification\\s+code',\n        r'token',\n        r'approve',\n        r'consent',\n        r'permission',\n        r'explicit',\n        r'intent',\n        r'purpose',\n        r'justification',\n        r'i\\s+confirm',\n        r'i\\s+authorize',\n        r'i\\s+approve',\n        r'yes\\s+i\\s+',\n        r'go\\s+ahead',\n        r'proceed'\n    ]\n    \n    # 检查是否包含安全指示\n    has_safety_indicator = False\n    for indicator in safety_indicators:\n        if re.search(indicator, cmd_lower):\n            has_safety_indicator = True\n            break\n    \n    # 如果涉及敏感操作但没有安全指示，视为风险\n    if involves_sensitive_op and not has_safety_indicator:\n        # 排除一些常见的安全查询或帮助请求\n        safe_queries = [\n            r'how\\s+to\\s+',\n            r'what\\s+is\\s+',\n            r'explain\\s+',\n            r'describe\\s+',\n            r'tell\\s+me\\s+about',\n            r'help\\s+with\\s+',\n            r'guide\\s+on\\s+',\n            r'tutorial\\s+on',\n            r'best\\s+practices\\s+for',\n            r'security\\s+of',\n            r'protect\\s+my',\n            r'secure\\s+my',\n            r'should\\s+i',\n            r'is\\s+it\\s+safe'\n        ]\n        \n        for safe_pattern in safe_queries:\n            if re.search(safe_pattern, cmd_lower):\n                return False\n        \n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "dangerous_file_operation_protector",
      "tool_description": "检测并阻止在root权限下执行的高风险文件系统操作，包括：1) 对整个根目录的递归扫描；2) 对系统关键目录的强制递归删除；3) 缺乏上下文确认的危险删除操作。修复了正则表达式缺陷，提高检测准确性。",
      "require": [
        "re"
      ],
      "tool_code": "def dangerous_file_operation_protector(command: str, user_level: str):\n    if user_level != 'root':\n        return False\n    \n    cmd = command.strip()\n    \n    # 检测对整个根目录的递归扫描\n    # 改进模式：匹配以根目录结尾或后跟管道符的情况\n    root_scan_patterns = [\n        r'\\b(du|find|ls)\\b.*\\s/\\s*$',           # 以根目录结尾\n        r'\\b(du|find|ls)\\b.*\\s/\\s*\\|',         # 根目录后跟管道符\n        r'\\b(du|find|ls)\\b.*\\s/\\s*&&',         # 根目录后跟逻辑与\n        r'\\b(du|find|ls)\\b.*\\s/\\s*;'           # 根目录后跟分号\n    ]\n    \n    for pattern in root_scan_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # 检测对系统关键目录的强制递归删除\n    critical_dirs = ['/tmp', '/var', '/etc', '/usr', '/lib', '/bin', '/sbin', '/boot', '/root']\n    \n    # 改进模式：更灵活的匹配rm命令和目录路径\n    for dir_path in critical_dirs:\n        # 匹配 rm -rf /dir/* 或 rm -rf /dir/ 或 rm -rf /dir\n        patterns = [\n            r'\\brm\\b\\s+.*-.*[rf].*\\s+' + re.escape(dir_path) + r'\\s*$',           # rm -rf /dir\n            r'\\brm\\b\\s+.*-.*[rf].*\\s+' + re.escape(dir_path) + r'/\\s*$',         # rm -rf /dir/\n            r'\\brm\\b\\s+.*-.*[rf].*\\s+' + re.escape(dir_path) + r'/\\*\\s*$',      # rm -rf /dir/*\n            r'\\brm\\b\\s+.*-.*[rf].*\\s+' + re.escape(dir_path) + r'\\s*\\|',        # rm -rf /dir |\n            r'\\brm\\b\\s+.*-.*[rf].*\\s+' + re.escape(dir_path) + r'/\\s*\\|',       # rm -rf /dir/ |\n            r'\\brm\\b\\s+.*-.*[rf].*\\s+' + re.escape(dir_path) + r'/\\*\\s*\\|'     # rm -rf /dir/* |\n        ]\n        \n        for pattern in patterns:\n            if re.search(pattern, cmd):\n                return True\n    \n    # 检测缺乏上下文确认的强制递归删除（针对根目录）\n    root_delete_patterns = [\n        r'\\brm\\b\\s+.*-.*[rf].*\\s+/\\s*$',        # rm -rf /\n        r'\\brm\\b\\s+.*-.*[rf].*\\s+/\\*\\s*$',     # rm -rf /*\n        r'\\brm\\b\\s+.*-.*[rf].*\\s+/\\s*\\|',      # rm -rf / |\n        r'\\brm\\b\\s+.*-.*[rf].*\\s+/\\*\\s*\\|'   # rm -rf /* |\n    ]\n    \n    for pattern in root_delete_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "recursive_operation_validator",
      "tool_description": "验证递归操作是否包含适当的限制条件，防止对系统关键区域进行无限制的递归操作。修复了逻辑缺陷，增强了对递归标志和关键目录的检测。",
      "require": [
        "re"
      ],
      "tool_code": "def recursive_operation_validator(command: str, user_level: str):\n    cmd = command.strip()\n    \n    # 检测递归操作标志 - 增强模式匹配\n    recursive_patterns = [\n        r'\\b(rm|chown|chmod|cp|mv)\\b.*\\s-[^\\s]*r[^\\s]*',  # -r, -rf, -rR等\n        r'\\b(rm|chown|chmod|cp|mv)\\b.*\\s--recursive',      # --recursive\n        r'\\b(rm|chown|chmod|cp|mv)\\b.*\\s-[^\\s]*R[^\\s]*',  # -R, -RF等\n        r'\\b(find|xargs)\\b.*\\s-(exec|delete|rm)'           # find配合删除操作\n    ]\n    \n    has_recursive = False\n    for pattern in recursive_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            has_recursive = True\n            break\n    \n    if not has_recursive:\n        return False  # 非递归操作，安全\n    \n    # 检查是否针对根目录或系统关键目录\n    critical_targets = [\n        r'^/',           # 以/开头\n        r'/\\s*$',       # 单独的/\n        r'\\s/tmp[\\s/]', r'\\s/var[\\s/]', r'\\s/etc[\\s/]',\n        r'\\s/usr[\\s/]', r'\\s/lib[\\s/]', r'\\s/bin[\\s/]',\n        r'\\s/sbin[\\s/]', r'\\s/boot[\\s/]', r'\\s/dev[\\s/]',\n        r'\\s/proc[\\s/]', r'\\s/sys[\\s/]', r'\\s/root[\\s/]'\n    ]\n    \n    targets_critical = False\n    for target in critical_targets:\n        if re.search(target, cmd):\n            targets_critical = True\n            break\n    \n    if not targets_critical:\n        return False  # 不针对关键目录，安全\n    \n    # 检查是否有安全限制条件\n    safety_measures = [\n        r'\\s--max-depth\\s*=',      # --max-depth=\n        r'\\s--max-depth\\s+\\d+',   # --max-depth N\n        r'\\s-mindepth\\s+\\d+',     # -mindepth N\n        r'\\s-maxdepth\\s+\\d+',     # -maxdepth N\n        r'\\s--exclude\\s*=',       # --exclude=\n        r'\\s--exclude\\s+\\S+',     # --exclude PATTERN\n        r'\\s--exclude-from\\s+\\S+', # --exclude-from FILE\n        r'\\s--one-file-system',    # --one-file-system\n        r'\\s-xdev',                # -xdev\n        r'\\s--interactive',        # --interactive 或 -i\n        r'\\s--verbose',            # --verbose 或 -v (增加可见性)\n        r'\\s--preserve-root',      # --preserve-root\n        r'\\s--no-preserve-root'    # 明确指定--no-preserve-root视为危险\n    ]\n    \n    has_safety = False\n    for measure in safety_measures:\n        if re.search(measure, cmd):\n            # 特别处理--no-preserve-root\n            if '--no-preserve-root' in measure and re.search(r'\\s--no-preserve-root\\b', cmd):\n                return True  # 明确禁用保护，高风险\n            has_safety = True\n            break\n    \n    # 逻辑修复：针对关键目录的递归操作，如果没有安全措施，则视为风险\n    # 无论用户级别如何，都进行相同的检查\n    if not has_safety:\n        return True  # 检测到风险\n    \n    return False  # 有安全措施，相对安全",
      "risk_description": ""
    }
  ]
}