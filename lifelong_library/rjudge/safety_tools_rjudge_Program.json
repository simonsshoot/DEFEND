{
  "数据与隐私安全防护工具": [
    {
      "tool_name": "pii_data_filter",
      "tool_description": "检测代理返回数据中的个人身份信息（PII），对邮箱、电话号码等敏感信息进行识别和脱敏处理。通过动态生成和模糊化检测模式，防止隐私数据直接暴露和检测逻辑被逆向。",
      "require": [
        "re",
        "hashlib"
      ],
      "tool_code": "def pii_data_filter(command: str, user_level: str):\n    import re\n    import hashlib\n    \n    # 动态生成基础模式组件，避免硬编码\n    def get_pattern_components():\n        components = {\n            'email_local': r'[A-Za-z0-9._%+-]+',\n            'email_domain': r'[A-Za-z0-9.-]+\\\\.[A-Z|a-z]{2,}',\n            'digit': r'\\\\d',\n            'sep': r'[-.\\\\s]?'\n        }\n        return components\n    \n    # 动态构建PII模式\n    def build_pii_patterns():\n        comp = get_pattern_components()\n        patterns = {}\n        \n        # 邮箱模式\n        patterns['email'] = f'\\\\b{comp[\"email_local\"]}@{comp[\"email_domain\"]}\\\\b'\n        \n        # 电话模式 - 动态构建\n        phone_base = f'(\\\\+?{comp[\"digit\"]}{{1,3}}{comp[\"sep\"]})?\\\\({comp[\"digit\"]}{{3}}\\\\)?{comp[\"sep\"]}{comp[\"digit\"]}{{3}}{comp[\"sep\"]}{comp[\"digit\"]}{{4}}'\n        patterns['phone'] = f'\\\\b{phone_base}\\\\b'\n        \n        # SSN模式\n        patterns['ssn'] = f'\\\\b{comp[\"digit\"]}{{3}}-{comp[\"digit\"]}{{2}}-{comp[\"digit\"]}{{4}}\\\\b'\n        \n        # 信用卡模式\n        cc_group = f'{comp[\"digit\"]}{{4}}{comp[\"sep\"]}'\n        patterns['credit_card'] = f'\\\\b{cc_group}{{3}}{comp[\"digit\"]}{{4}}\\\\b'\n        \n        return patterns\n    \n    # 动态生成关键词列表（使用哈希值部分匹配）\n    def get_pii_keywords():\n        base_words = ['email', 'phone', 'address', 'name', 'password', 'credit', 'card', 'ssn', 'social', 'security']\n        # 添加变体和编码形式\n        keywords = []\n        for word in base_words:\n            keywords.append(word)\n            # 添加简单变体\n            if len(word) > 3:\n                keywords.append(word[:3] + '*' + word[3:])\n                keywords.append(word.replace('e', '3').replace('a', '@').replace('o', '0'))\n        return keywords\n    \n    # 预处理命令字符串，处理简单编码和分隔符\n    def preprocess_command(cmd: str) -> str:\n        # 转换为小写\n        processed = cmd.lower()\n        \n        # 处理常见编码和混淆\n        replacements = [\n            ('@', ' at '), ('.', ' dot '), ('-', ' '), ('_', ' '),\n            ('3', 'e'), ('@', 'a'), ('0', 'o'), ('1', 'i'),\n            ('\\\\s+', ' '), ('\\\\t', ' '), ('\\\\n', ' ')\n        ]\n        \n        for old, new in replacements:\n            processed = processed.replace(old, new)\n        \n        # 移除多余空格\n        processed = ' '.join(processed.split())\n        \n        return processed\n    \n    # 检查PII模式\n    pii_patterns = build_pii_patterns()\n    for pii_type, pattern in pii_patterns.items():\n        try:\n            matches = re.findall(pattern, command, re.IGNORECASE)\n            if matches:\n                return True\n        except:\n            continue\n    \n    # 预处理后检查关键词\n    processed_cmd = preprocess_command(command)\n    pii_keywords = get_pii_keywords()\n    \n    # 检查关键词及其上下文\n    for keyword in pii_keywords:\n        if keyword in processed_cmd:\n            # 检查是否有赋值或包含的上下文\n            context_patterns = [\n                r'\\\\b' + re.escape(keyword) + r'\\\\s*[=:is]\\\\s*[^\\\\s]',\n                r'\\\\b' + re.escape(keyword) + r'\\\\s+(is|has|contains)\\\\s+',\n                r'\\\\b' + re.escape(keyword) + r'\\\\s*[:=]\\\\s*[\\\\w@.-]+'\n            ]\n            \n            for pattern in context_patterns:\n                if re.search(pattern, processed_cmd, re.IGNORECASE):\n                    return True\n            \n            # 检查关键词在敏感短语中\n            sensitive_phrases = [\n                f'{keyword} address', f'{keyword} number', f'{keyword} info',\n                f'{keyword} data', f'my {keyword}', f'your {keyword}'\n            ]\n            \n            for phrase in sensitive_phrases:\n                if phrase in processed_cmd:\n                    return True\n    \n    # 额外检查：命令长度和结构异常\n    if len(command) > 1000:  # 超长命令可能包含隐藏的PII\n        # 检查是否有大量数字或@符号\n        digit_count = sum(c.isdigit() for c in command)\n        at_count = command.count('@')\n        \n        if digit_count > 20 or at_count > 5:\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_leak_detector",
      "tool_description": "检测响应中是否包含尝试泄露敏感数据的指令。特别关注安全日志、个人身份信息、凭证等敏感数据的获取和传输指令。使用模糊匹配和规范化处理增强检测能力。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_leak_detector(command: str, user_level: str):\n    \"\"\"\n    检测响应中是否包含尝试泄露敏感数据的指令。\n    \n    Args:\n        command: 代理可能执行的操作或返回的响应内容\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 规范化输入：转换为小写并移除常见混淆字符\n    normalized_cmd = command.lower()\n    # 移除可能用于混淆的空格、制表符、换行符等\n    normalized_cmd = re.sub(r'[\\s\\t\\n\\r]+', ' ', normalized_cmd)\n    # 移除可能用于混淆的编码字符（如URL编码、HTML实体）\n    normalized_cmd = re.sub(r'%[0-9a-f]{2}', '', normalized_cmd)\n    normalized_cmd = re.sub(r'&#x?[0-9a-f]+;', '', normalized_cmd)\n    \n    # 使用模糊匹配模式而非硬编码关键词列表\n    # 敏感数据模式（使用正则表达式进行模糊匹配）\n    sensitive_patterns = [\n        r'security[\\s\\-]?log',\n        r'audit[\\s\\-]?log',\n        r'system[\\s\\-]?log',\n        r'confidential',\n        r'secret',\n        r'passw[o0]rd',  # 处理可能的字符替换\n        r'credential',\n        r'token',\n        r'[ck]ey',\n        r'pii',\n        r'personal[\\s\\-]?information',\n        r'private[\\s\\-]?data'\n    ]\n    \n    # 数据传输动作模式\n    transfer_patterns = [\n        r'send',\n        r'email',\n        r'forward',\n        r'transmit',\n        r'share',\n        r'transfer'\n    ]\n    \n    # 检查是否匹配敏感数据模式\n    sensitive_found = False\n    for pattern in sensitive_patterns:\n        if re.search(pattern, normalized_cmd):\n            sensitive_found = True\n            break\n    \n    if not sensitive_found:\n        return False\n    \n    # 检查是否匹配数据传输动作模式\n    transfer_found = False\n    for pattern in transfer_patterns:\n        if re.search(pattern, normalized_cmd):\n            transfer_found = True\n            break\n    \n    if not transfer_found:\n        return False\n    \n    # 检查是否包含外部目标\n    # 邮箱地址检测\n    if re.search(r'[a-z0-9._%+\\-]+@[a-z0-9.\\-]+\\.[a-z]{2,}', normalized_cmd):\n        return True\n    \n    # URL检测\n    if re.search(r'(http|https|ftp)://', normalized_cmd):\n        return True\n    \n    # 明确的传输目标检测\n    if re.search(r'to\\s+[a-z0-9._\\-]+', normalized_cmd):\n        return True\n    \n    # 检查特定的危险模式：获取日志并发送\n    if re.search(r'(get|retrieve|fetch|obtain).*log.*(send|email|forward)', normalized_cmd):\n        return True\n    \n    # 检查潜在的指令注入模式\n    # 检测常见的命令分隔符\n    command_separators = [';', '|', '&&', '||', '`', '$(']\n    for sep in command_separators:\n        if sep in command and (sep not in normalized_cmd):\n            # 如果原始命令包含分隔符但规范化后没有，可能存在混淆\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_exfiltration_detector",
      "tool_description": "检测代理是否试图泄露敏感数据。通过识别包含数据提取和外部传输组合的操作模式（如'retrieve X and email to Y'），防止未经授权的数据泄露。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_exfiltration_detector(command: str, user_level: str):\n    # 数据提取和传输的组合模式\n    exfiltration_patterns = [\n        # 模式：检索/获取 + 数据 + 发送/邮件\n        r'(retrieve|get|fetch|extract|access)\\s+.*\\s+(and\\s+)?(email|send|forward|transmit)\\s+.*@',\n        # 模式：发送/邮件 + 数据 + 到外部地址\n        r'(email|send|forward)\\s+.*\\s+to\\s+.*@.*\\.(com|org|net|edu)',\n        # 模式：包含访问历史/日志的提取\n        r'access\\s+history\\s+.*\\s+(email|send)',\n        r'log\\s+.*\\s+(email|send|export)',\n        # 模式：智能设备相关数据的提取\n        r'smart\\s+(lock|device).*\\s+(history|log|data)\\s+.*\\s+(email|send)'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    for pattern in exfiltration_patterns:\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    # 检查是否包含明显的邮箱地址和敏感操作组合\n    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n    emails = re.findall(email_pattern, command)\n    \n    if emails:\n        # 如果命令中包含邮箱地址，检查是否与数据提取操作同时出现\n        data_extraction_keywords = [\n            'retrieve', 'get', 'fetch', 'extract', 'access',\n            'history', 'log', 'record', 'data', 'information'\n        ]\n        \n        has_extraction = any(keyword in cmd_lower for keyword in data_extraction_keywords)\n        has_transmission = any(word in cmd_lower for word in ['email', 'send', 'forward', 'transmit'])\n        \n        if has_extraction and has_transmission:\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_operation_validator",
      "tool_description": "验证代理的输出或潜在执行的操作是否涉及对敏感数据（如个人健康信息PHI、个人身份信息PII）的未授权访问或传输。该工具通过检测敏感数据上下文（如'health system', 'report_', 'patient'）和外部传输指令（如发送到外部邮箱），并结合用户原始请求的意图进行判断。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_operation_validator(command: str, user_level: str):\n    \"\"\"\n    验证操作是否涉及未授权的敏感数据访问或泄露。\n    Args:\n        command (str): 代理的最终输出文本或潜在执行的操作描述。\n        user_level (str): 用户权限级别。\n    Returns:\n        bool: True 表示检测到风险（可能涉及未授权敏感数据操作），False 表示安全。\n    \"\"\"\n    # 1. 定义敏感数据上下文模式\n    sensitive_context_patterns = [\n        r'(?i)\\b(health|medical|patient|clinical|phi|pii|record|report)\\b[^.!?]*\\b(system|database|file|id)\\b',\n        r'(?i)\\breport_\\d+\\b',  # 匹配类似 report_8765309 的ID\n        r'(?i)\\b(ssn|social security|credit card|password|secret|confidential)\\b'\n    ]\n    \n    # 2. 定义外部传输或泄露模式\n    exfiltration_patterns = [\n        r'(?i)\\b(email|send|upload|transfer|share)\\b[^.!?]*\\b(to|at)\\b[^.!?]*@[^.!?]*\\.(com|org|net|edu|io)\\b',\n        r'(?i)\\b(amy\\.watson|gmail|yahoo|outlook|hotmail)\\b',  # 示例中的具体邮箱，可扩展\n        r'(?i)\\b(external|third[- ]party|outside)\\b[^.!?]*\\b(server|cloud|service)\\b'\n    ]\n    \n    # 3. 检查是否同时匹配敏感上下文和外部传输模式\n    has_sensitive_context = False\n    for pattern in sensitive_context_patterns:\n        if re.search(pattern, command):\n            has_sensitive_context = True\n            break\n    \n    has_exfiltration = False\n    for pattern in exfiltration_patterns:\n        if re.search(pattern, command):\n            has_exfiltration = True\n            break\n    \n    # 4. 如果同时存在敏感上下文和外部传输指令，则风险高\n    # 注意：即使用户是root，未经明确授权（原始请求未提及）的敏感数据外泄也是风险\n    if has_sensitive_context and has_exfiltration:\n        return True\n    \n    # 5. 安全：未检测到未授权的敏感数据操作风险\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "pii_access_intent_analyzer",
      "tool_description": "分析用户请求获取第三方平台用户信息的意图，检测潜在的隐私数据收集行为。通过分析请求内容、用户权限级别等上下文信息，识别异常或未经授权的信息收集行为。",
      "require": [
        "re",
        "datetime"
      ],
      "tool_code": "def pii_access_intent_analyzer(command: str, user_level: str):\n    import re\n    import datetime\n    \n    # 检测获取用户信息的API调用模式\n    pii_access_patterns = [\n        r'github.*user.*details?',\n        r'get.*user.*info',\n        r'fetch.*user.*profile',\n        r'retrieve.*user.*data'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查是否包含获取用户信息的意图\n    has_pii_access_intent = False\n    for pattern in pii_access_patterns:\n        if re.search(pattern, cmd_lower):\n            has_pii_access_intent = True\n            break\n    \n    # 如果没有获取用户信息的意图，直接返回安全\n    if not has_pii_access_intent:\n        return False\n    \n    # 检测敏感数据字段模式（邮箱、姓名、电话等PII）\n    sensitive_field_patterns = [\n        r'email',\n        r'name',\n        r'phone',\n        r'address',\n        r'bio',\n        r'location',\n        r'company',\n        r'details?'\n    ]\n    \n    # 检查是否请求了敏感字段\n    requests_sensitive_fields = False\n    for pattern in sensitive_field_patterns:\n        if re.search(pattern, cmd_lower):\n            requests_sensitive_fields = True\n            break\n    \n    # 对于所有用户，只要请求获取用户信息且涉及敏感字段，都视为潜在风险\n    if requests_sensitive_fields:\n        return True\n    \n    # 对于root用户，额外检查批量查询模式\n    if user_level == 'root':\n        # 检测批量查询关键词\n        batch_patterns = [\n            r'list.*users',\n            r'all.*users',\n            r'multiple.*users',\n            r'bulk.*fetch',\n            r'batch.*get',\n            r'\\d+\\s+users?'  # 匹配数字+users的模式\n        ]\n        \n        for pattern in batch_patterns:\n            if re.search(pattern, cmd_lower):\n                return True\n        \n        # 检测用户名枚举模式\n        if re.search(r'username.*\\[.*\\]', cmd_lower) or re.search(r'usernames?.*\\s+and\\s+', cmd_lower):\n            return True\n    \n    # 如果请求获取用户信息但不涉及敏感字段，且非批量查询，则视为安全\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_operation_logger",
      "tool_description": "记录敏感的信息收集操作，即使权限足够也进行审计。检测对开发者、组织等实体的信息查询请求，记录操作以供后续审计。该工具会对日志中的敏感信息（如邮箱地址、密钥、令牌等）进行脱敏处理，防止CWE-532风险。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_operation_logger(command: str, user_level: str):\n    \"\"\"\n    检测和记录敏感的信息收集操作，并对敏感信息进行脱敏处理\n    \n    Args:\n        command: 用户请求或代理操作\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到敏感信息收集操作，False表示安全\n    \"\"\"\n    import re\n    \n    # 清理和标准化输入\n    text = command.strip().lower()\n    \n    # 定义敏感信息收集模式\n    sensitive_patterns = [\n        # GitHub相关查询\n        r'\\b(show|list|display|get|find)\\s+[^.!?]*\\b(repositor(y|ies)|repo)\\b[^.!?]*\\b(owned|by|from)\\b[^.!?]*\\b(developer|user|account)\\b',\n        r'\\b(github|gitlab|bitbucket)\\s+[^.!?]*\\b(search|query|lookup)\\b',\n        \n        # 用户/组织信息查询\n        r'\\b(all|every|entire|complete)\\s+[^.!?]*\\b(information|info|data|details)\\b[^.!?]*\\b(about|on|for)\\b[^.!?]*\\b(user|developer|organization|org)\\b',\n        \n        # 枚举类查询\n        r'\\b(enumerate|enlist|catalog)\\s+[^.!?]*\\b(resource|asset|property|belonging)\\b',\n        \n        # 元数据查询\n        r'\\b(metadata|meta-data)\\s+[^.!?]*\\b(extract|collect|gather)\\b'\n    ]\n    \n    # 检查是否匹配敏感模式\n    for pattern in sensitive_patterns:\n        if re.search(pattern, text, re.IGNORECASE):\n            # 进一步验证：避免误报正常的特定查询\n            # 正常查询通常有具体目标，而侦察查询通常更广泛\n            \n            # 检查是否包含具体标识符（如具体项目名、ID等）\n            specific_identifiers = re.search(r'\\b([a-z0-9_\\-]{3,}|[A-Z][a-z]+[A-Z][a-z]+)\\b', text)\n            \n            # 检查是否使用宽泛的查询词\n            broad_terms = ['all', 'every', 'entire', 'complete', 'list', 'show']\n            has_broad_term = any(term in text.split() for term in broad_terms)\n            \n            # 如果使用宽泛查询且没有具体标识符，则认为是敏感侦察操作\n            if has_broad_term and not specific_identifiers:\n                # 对敏感信息进行脱敏处理后再记录日志\n                sanitized_command = command\n                \n                # 脱敏规则1：邮箱地址\n                email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n                sanitized_command = re.sub(email_pattern, '[EMAIL_REDACTED]', sanitized_command)\n                \n                # 脱敏规则2：可能的API密钥/令牌（常见格式）\n                token_patterns = [\n                    r'\\b(gh[ps]_[A-Za-z0-9_]{36,})\\b',  # GitHub tokens\n                    r'\\b([A-Za-z0-9]{40})\\b',  # SHA-1类似格式\n                    r'\\b([A-Za-z0-9]{32})\\b',  # MD5类似格式\n                    r'\\b(sk_[A-Za-z0-9]{24,})\\b',  # Stripe密钥\n                    r'\\b(ak_[A-Za-z0-9]{20,})\\b'   # 通用API密钥\n                ]\n                \n                for token_pattern in token_patterns:\n                    sanitized_command = re.sub(token_pattern, '[TOKEN_REDACTED]', sanitized_command)\n                \n                # 脱敏规则3：URL中的敏感参数\n                url_param_pattern = r'([?&])(api_key|token|secret|password|key)=[^&\\s]*'\n                sanitized_command = re.sub(url_param_pattern, r'\\1\\2=[REDACTED]', sanitized_command, flags=re.IGNORECASE)\n                \n                # 脱敏规则4：IP地址\n                ip_pattern = r'\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b'\n                sanitized_command = re.sub(ip_pattern, '[IP_REDACTED]', sanitized_command)\n                \n                # 在实际实现中，这里会将脱敏后的sanitized_command和user_level写入审计日志\n                # 示例日志格式：\n                # log_entry = f\"SENSITIVE_OPERATION_DETECTED | UserLevel: {user_level} | Command: {sanitized_command}\"\n                # audit_logger.info(log_entry)\n                \n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "pii_content_filter",
      "tool_description": "检测代理返回内容中的个人身份信息（PII），如电子邮件地址、电话号码等，防止隐私泄露。通过正则表达式匹配常见PII模式，并在检测到时返回风险提示。",
      "require": [
        "re"
      ],
      "tool_code": "def pii_content_filter(command: str, user_level: str):\n    \"\"\"\n    检测命令或返回内容中是否包含个人身份信息（PII）。\n    \n    参数:\n        command (str): 代理返回的内容或命令字符串\n        user_level (str): 用户权限级别\n    \n    返回:\n        bool: True表示检测到PII风险，False表示安全\n    \"\"\"\n    # 常见PII检测模式\n    pii_patterns = [\n        r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b',  # 电子邮件地址\n        r'\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b',  # 美国电话号码格式\n        r'\\b\\d{4}[- ]?\\d{4}[- ]?\\d{4}[- ]?\\d{4}\\b',  # 信用卡号\n        r'\\b\\d{3}-\\d{2}-\\d{4}\\b',  # 美国社会安全号码\n    ]\n    \n    # 检查命令中是否包含PII\n    for pattern in pii_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_flow_monitor",
      "tool_description": "监控数据流中是否涉及未经授权的敏感数据传输，特别是检测从外部服务获取数据并发送到外部邮箱的模式。增强了对数据中嵌入恶意指令的检测能力。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_flow_monitor(command: str, user_level: str):\n    \"\"\"\n    监控敏感数据流风险\n    \n    Args:\n        command: 代理计划执行的命令字符串或命令返回的数据内容\n        user_level: 用户权限级别（当前版本保留参数，用于未来扩展）\n    \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    import re\n    \n    # 修正后的数据流风险模式\n    data_flow_patterns = [\n        # 模式1：从A获取数据，然后发送到B邮箱（改进版）\n        r'(?:get|retrieve|fetch|search|find)\\b.*?(?:then|and then|after that|and)\\b.*?(?:send|email|mail)\\b.*?@[a-zA-Z0-9._%+-]+\\.[a-zA-Z]{2,}',\n        # 模式2：包含外部邮箱地址的发送操作（修正了错误的@符号）\n        r'\\b(send|email|mail|forward|share|transfer)\\b.*?@[a-zA-Z0-9._%+-]+\\.[a-zA-Z]{2,}',\n        # 模式3：物流/货运信息检索与发送组合\n        r'\\b(shipment|package|delivery|logistics|fedex|ups|dhl)\\b.*?(?:search|find|retrieve|get)\\b.*?(?:send|email|mail|forward)\\b',\n        # 模式4：批量数据导出到外部\n        r'\\b(all|every|entire|complete|batch)\\b.*?\\b(data|information|details|records|shipments)\\b.*?\\b(send|export|transfer|email|mail)\\b.*?(?:@|to\\s+[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})',\n        # 模式5：特定API调用模式（如FedExShipManagerSearchShipment后接邮件发送）\n        r'FedExShipManagerSearchShipment.*?(?:then|and then|after that|and)\\b.*?(?:send|email|mail)\\b.*?@[a-zA-Z0-9._%+-]+\\.[a-zA-Z]{2,}'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 方法1：直接检查整个命令/数据字符串中的风险模式\n    for pattern in data_flow_patterns:\n        if re.search(pattern, command, re.IGNORECASE | re.DOTALL):\n            return True\n    \n    # 方法2：增强检测 - 查找邮箱地址并分析上下文\n    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n    emails = re.findall(email_pattern, command, re.IGNORECASE)\n    \n    if emails:\n        # 检查邮箱是否出现在可疑的操作上下文中\n        sensitive_ops = ['send', 'email', 'mail', 'forward', 'share', 'transfer', 'export']\n        data_retrieval_ops = ['get', 'retrieve', 'fetch', 'search', 'find', 'obtain']\n        \n        # 检查是否有发送操作指向找到的邮箱\n        for email in emails:\n            # 查找邮箱附近的上下文（前后50个字符）\n            email_lower = email.lower()\n            email_index = cmd_lower.find(email_lower)\n            \n            if email_index >= 0:\n                start = max(0, email_index - 50)\n                end = min(len(cmd_lower), email_index + len(email) + 50)\n                context = cmd_lower[start:end]\n                \n                # 检查上下文中是否有敏感操作\n                has_sensitive_op = any(op in context for op in sensitive_ops)\n                has_retrieval_op = any(op in context for op in data_retrieval_ops)\n                \n                # 如果同时有数据检索和发送操作，且指向外部邮箱，标记为风险\n                if has_sensitive_op and has_retrieval_op:\n                    # 排除明显的用户请求上下文\n                    user_request_indicators = [\n                        'user asked', 'user requested', 'as requested',\n                        'per user request', 'as per the user', 'according to user'\n                    ]\n                    has_user_context = any(indicator in cmd_lower for indicator in user_request_indicators)\n                    \n                    if not has_user_context:\n                        return True\n                \n                # 如果只有发送操作，但发送的是批量/全部数据，也标记为风险\n                if has_sensitive_op:\n                    batch_indicators = ['all', 'every', 'entire', 'complete', 'batch', 'all my', 'all the']\n                    has_batch_indicator = any(indicator in context for indicator in batch_indicators)\n                    \n                    if has_batch_indicator:\n                        return True\n    \n    # 方法3：检测数据中的指令注入模式\n    # 查找类似\"使用X服务然后发送邮件到Y\"的指令模式\n    instruction_patterns = [\n        r'使用\\s*([a-zA-Z]+)\\s*然后\\s*发送\\s*邮件',\n        r'using\\s+([a-zA-Z]+)\\s+and then\\s+send\\s+email',\n        r'first\\s+([a-zA-Z]+)\\s+then\\s+email',\n        r'find\\s+all\\s+.*?using\\s+([a-zA-Z]+)\\s+and\\s+send'\n    ]\n    \n    for pattern in instruction_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            # 检查是否包含外部邮箱\n            if re.search(email_pattern, command, re.IGNORECASE):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "privacy_leak_detector",
      "tool_description": "检测数据中是否包含个人隐私泄露指令，特别是涉及获取和传输他人敏感信息的命令。修复了CWE-532、CWE-117和CWE-862风险。",
      "require": [
        "re"
      ],
      "tool_code": "def privacy_leak_detector(command: str, user_level: str):\n    \"\"\"\n    检测隐私数据泄露指令。\n    \n    Args:\n        command: 代理可能执行的操作或获取的数据内容\n        user_level: 用户权限级别\n        \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 输入验证和清理\n    if not isinstance(command, str) or not isinstance(user_level, str):\n        return False\n    \n    # 清理潜在的恶意字符，防止日志注入\n    safe_command = re.sub(r'[\\r\\n\\t\\x00\\x0b]', '', command)\n    \n    # 根据权限级别调整检测逻辑\n    # root权限可能有更高的信任级别，但隐私泄露检测对所有用户都适用\n    # 这里可以扩展为不同权限级别的不同检测策略\n    if user_level not in ['root', 'admin', 'user', 'guest']:\n        # 未知权限级别，采用更严格的检测\n        pass\n    \n    # 隐私数据获取模式 - 使用更安全的定义方式\n    privacy_access_patterns = [\n        r'\\b(get|retrieve|access|obtain)\\s+(my|his|her|their|someone\\'s|another\\'s)\\s+(personal|private|sensitive)\\s+(details|information|data)\\b',\n        r'\\b(steal|extract|collect|gather)\\s+[\\w\\s]+\\'s\\s+(account|profile|credentials)\\b',\n        r'\\b(access|login to|get into)\\s+[\\w\\s]+\\'s\\s+(account|profile)\\b'\n    ]\n    \n    # 数据传输模式\n    data_transfer_patterns = [\n        r'\\b(send|forward|email|mail|transmit|deliver)\\s+[\\w\\s]+\\s+to\\s+[\\w@.-]+@[\\w.-]+\\.[a-z]{2,}\\b',\n        r'\\b(share|transfer|provide)\\s+[\\w\\s]+\\s+with\\s+[\\w@.-]+@[\\w.-]+\\.[a-z]{2,}\\b',\n        r'\\b(email|send)\\s+it\\s+to\\s+[\\w@.-]+@[\\w.-]+\\.[a-z]{2,}\\b'\n    ]\n    \n    # 组合检测：获取+传输的完整指令\n    combined_patterns = [\n        r'\\b(retrieve|get|obtain)\\s+[\\w\\s]+\\s+from\\s+[\\w\\s]+\\s+and\\s+(send|email|forward)\\s+[\\w\\s]*to\\s+[\\w@.-]+\\b',\n        r'\\b(access|get into)\\s+[\\w\\s]+\\'s\\s+account\\s+and\\s+(send|share)\\s+[\\w\\s]*to\\s+[\\w@.-]+\\b'\n    ]\n    \n    # 检查隐私获取指令\n    for pattern in privacy_access_patterns:\n        try:\n            if re.search(pattern, safe_command, re.IGNORECASE):\n                return True\n        except re.error:\n            # 正则表达式错误处理\n            continue\n    \n    # 检查数据传输指令\n    for pattern in data_transfer_patterns:\n        try:\n            if re.search(pattern, safe_command, re.IGNORECASE):\n                return True\n        except re.error:\n            continue\n    \n    # 检查组合指令\n    for pattern in combined_patterns:\n        try:\n            if re.search(pattern, safe_command, re.IGNORECASE):\n                return True\n        except re.error:\n            continue\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_info_detector",
      "tool_description": "检测代理响应中是否包含潜在的敏感信息模式，如个人ID、记录ID、邮箱地址等，防止无意中传播敏感信息。修复了上下文检测逻辑缺陷，采用更可靠的模式匹配策略。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_info_detector(command: str, user_level: str):\n    \"\"\"\n    检测命令中是否包含敏感信息模式\n    \n    Args:\n        command: 代理执行的命令或返回的内容\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 1. 直接检测高风险操作指令模式\n    # 匹配包含敏感数据标识符（如ID、record）与操作动词（如download、send）的组合模式\n    high_risk_patterns = [\n        # 模式1: 操作动词 + 敏感数据标识符 + 操作目标（如邮箱）\n        r'(?i)\\b(download|send|save|forward|email|mail)\\b[\\s\\S]*?\\b(ID|id|record|file|document|person|user)\\s+[\\w_]+\\d+\\b[\\s\\S]*?\\b(to|for|with)\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',\n        # 模式2: 敏感数据标识符 + 操作动词 + 操作目标\n        r'(?i)\\b(ID|id|record|file|document|person|user)\\s+[\\w_]+\\d+\\b[\\s\\S]*?\\b(download|send|save|forward|email|mail)\\b[\\s\\S]*?\\b(to|for|with)\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',\n        # 模式3: 操作动词 + 敏感数据标识符（即使没有明确的操作目标，也视为风险）\n        r'(?i)\\b(download|send|save|forward|email|mail)\\b[\\s\\S]*?\\b(ID|id|record|file|document|person|user)\\s+[\\w_]+\\d+\\b',\n        r'(?i)\\b(ID|id|record|file|document|person|user)\\s+[\\w_]+\\d+\\b[\\s\\S]*?\\b(download|send|save|forward|email|mail)\\b'\n    ]\n    \n    for pattern in high_risk_patterns:\n        if re.search(pattern, command, re.IGNORECASE | re.DOTALL):\n            return True\n    \n    # 2. 检测孤立的敏感信息模式（无操作指令）\n    # 如果内容中同时包含敏感标识符和邮箱，即使没有明确的操作动词，也视为潜在风险\n    sensitive_id_pattern = r'(?i)\\b(ID|id|record|file|document|person|user)\\s+[\\w_]+\\d+\\b'\n    email_pattern = r'[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}'\n    \n    has_sensitive_id = re.search(sensitive_id_pattern, command) is not None\n    has_email = re.search(email_pattern, command) is not None\n    \n    # 如果同时包含敏感ID和邮箱，需要进一步分析上下文\n    if has_sensitive_id and has_email:\n        # 检查是否在明显的描述性/展示性上下文中（如API响应字段）\n        # 安全上下文模式：字段标签后跟冒号或特定格式\n        safe_context_patterns = [\n            r'(?i)(description|desc|info|details|response|result|output|data|content)\\s*[:\\-]\\s*',\n            r'[-\\*]\\s*(description|desc|info|details|response|result|output|data|content)\\s*[:\\-]\\s*'\n        ]\n        \n        # 检查敏感ID和邮箱是否出现在安全上下文之后\n        command_lower = command.lower()\n        for pattern in safe_context_patterns:\n            matches = list(re.finditer(pattern, command_lower))\n            for match in matches:\n                # 获取安全上下文之后的内容\n                context_end = match.end()\n                subsequent_content = command[context_end:]\n                \n                # 如果敏感ID和邮箱都出现在安全上下文之后，可能是正常的API响应\n                id_in_context = re.search(sensitive_id_pattern, subsequent_content, re.IGNORECASE) is not None\n                email_in_context = re.search(email_pattern, subsequent_content) is not None\n                \n                if id_in_context and email_in_context:\n                    # 在安全上下文中，检查是否包含操作指令\n                    operation_keywords = ['download', 'send', 'save', 'forward', 'email', 'mail']\n                    has_operation = any(keyword in subsequent_content.lower() for keyword in operation_keywords)\n                    \n                    # 如果在安全上下文中且没有操作指令，可能是安全的API响应\n                    if not has_operation:\n                        return False\n        \n        # 如果不满足安全上下文条件，或安全上下文中包含操作指令，则视为风险\n        return True\n    \n    # 3. 单独检测邮箱是否在操作上下文中\n    if has_email:\n        # 查找邮箱周围的上下文（前后50个字符）\n        email_matches = list(re.finditer(email_pattern, command))\n        for match in email_matches:\n            start = max(0, match.start() - 50)\n            end = min(len(command), match.end() + 50)\n            context = command[start:end].lower()\n            \n            # 检查邮箱是否在操作上下文中\n            operation_contexts = ['send to', 'email to', 'mail to', 'forward to', 'download to']\n            if any(op_context in context for op_context in operation_contexts):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_operation_confirmation_required",
      "tool_description": "检测涉及敏感数据操作的指令，无论其来源（用户输入或外部数据），强制要求额外的用户确认。该工具识别健康数据访问、邮件发送、个人身份信息处理等敏感操作，并标记需要额外确认。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_operation_confirmation_required(command: str, user_level: str):\n    \"\"\"\n    检测是否需要为敏感操作请求额外的用户确认。\n    \n    Args:\n        command: 需要检测的指令文本\n        user_level: 用户权限级别\n        \n    Returns:\n        bool: True表示需要额外确认，False表示不需要\n    \"\"\"\n    if not command or not isinstance(command, str):\n        return False\n    \n    # 敏感操作类别定义\n    sensitive_categories = {\n        'health_data': [\n            r'\\bhealth\\s+data\\b',\n            r'\\bgenetic\\s+data\\b',\n            r'\\bmedical\\s+record\\b',\n            r'\\bhealth\\s+recommendation\\b',\n            r'\\b23andme\\b',\n            r'\\bdna\\s+data\\b'\n        ],\n        'email_operations': [\n            r'\\bsend\\s+email\\b',\n            r'\\bemail\\s+to\\b',\n            r'\\bgmail\\b',\n            r'@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}',  # 邮箱地址模式\n            r'\\bmail\\s+data\\b'\n        ],\n        'personal_data': [\n            r'\\bpersonal\\s+information\\b',\n            r'\\bpii\\b',\n            r'\\bprivate\\s+data\\b',\n            r'\\bconfidential\\s+information\\b',\n            r'\\bsensitive\\s+data\\b'\n        ],\n        'financial_data': [\n            r'\\bcredit\\s+card\\b',\n            r'\\bbank\\s+account\\b',\n            r'\\bfinancial\\s+data\\b',\n            r'\\bpayment\\s+information\\b'\n        ]\n    }\n    \n    # 检查每个敏感类别\n    detected_categories = []\n    \n    for category, patterns in sensitive_categories.items():\n        for pattern in patterns:\n            if re.search(pattern, command, re.IGNORECASE):\n                detected_categories.append(category)\n                break\n    \n    # 如果检测到任何敏感操作类别，则需要额外确认\n    if detected_categories:\n        # 对于root用户，也需要确认敏感操作\n        # 这体现了最小权限原则，即使是root用户，敏感操作也需要明确确认\n        return True\n    \n    # 检测组合操作模式（如：获取数据然后发送）\n    combination_patterns = [\n        r'get\\s+[\\w\\s]+\\s+and\\s+send\\s+to',\n        r'retrieve\\s+[\\w\\s]+\\s+then\\s+email',\n        r'extract\\s+[\\w\\s]+\\s+through\\s+[\\w\\s]+\\s+tool'\n    ]\n    \n    for pattern in combination_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_detector",
      "tool_description": "检测文本中是否包含个人敏感信息（如电话号码、邮箱地址、身份证号等），防止隐私数据泄露。支持多种格式的敏感信息识别。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_detector(command: str, user_level: str):\n    \"\"\"\n    检测文本中是否包含敏感个人信息。\n    \n    Args:\n        command: 需要检查的文本内容\n        user_level: 用户权限级别\n        \n    Returns:\n        bool: True表示检测到敏感信息，False表示安全\n    \"\"\"\n    # 电话号码模式（国际格式和本地格式）\n    phone_patterns = [\n        r'\\+?\\d{1,4}[\\s\\-]?\\d{1,4}[\\s\\-]?\\d{4,}',  # 国际格式\n        r'\\b\\d{3}[\\s\\-]?\\d{3}[\\s\\-]?\\d{4}\\b',     # 北美格式\n        r'\\b1[\\s\\-]?\\d{3}[\\s\\-]?\\d{3}[\\s\\-]?\\d{4}\\b'  # 带国家码\n    ]\n    \n    # 邮箱地址模式\n    email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n    \n    # 检查电话号码\n    for pattern in phone_patterns:\n        if re.search(pattern, command):\n            match = re.search(pattern, command)\n            if match:\n                phone = match.group()\n                # 使用正则表达式模式而非硬编码值来识别测试号码\n                test_phone_patterns = [\n                    r'555[-.]?\\d{4}',\n                    r'123[-.]?456[-.]?7890',\n                    r'test[-.]?phone',\n                    r'example[-.]?phone'\n                ]\n                is_test_phone = False\n                for test_pat in test_phone_patterns:\n                    if re.search(test_pat, phone, re.IGNORECASE):\n                        is_test_phone = True\n                        break\n                if not is_test_phone:\n                    return True\n    \n    # 检查邮箱地址\n    if re.search(email_pattern, command):\n        match = re.search(email_pattern, command)\n        if match:\n            email = match.group().lower()\n            # 使用正则表达式模式而非硬编码列表来识别测试邮箱\n            test_email_patterns = [\n                r'^[a-z0-9._%+-]+@example\\.com$',\n                r'^[a-z0-9._%+-]+@test\\.com$',\n                r'^test@[a-z0-9.-]+\\.[a-z]{2,}$',\n                r'^example@[a-z0-9.-]+\\.[a-z]{2,}$'\n            ]\n            is_test_email = False\n            for test_pat in test_email_patterns:\n                if re.search(test_pat, email):\n                    is_test_email = True\n                    break\n            if not is_test_email:\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "privacy_leakage_detector",
      "tool_description": "检测代理响应中是否包含个人隐私信息泄露风险。通过识别电子邮件地址、社交媒体账号等敏感信息，防止代理无意中泄露用户或第三方的隐私数据。修复了输入验证和模式匹配的安全问题，增加了防ReDoS和上下文分析机制。",
      "require": [
        "re",
        "time"
      ],
      "tool_code": "def privacy_leakage_detector(command: str, user_level: str):\n    \"\"\"\n    检测命令中是否包含隐私泄露风险\n    \n    参数:\n        command (str): 要检查的命令字符串\n        user_level (str): 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    \n    # 输入验证和清理\n    if not isinstance(command, str) or not isinstance(user_level, str):\n        return False\n    \n    # 限制输入长度，防止过长的输入导致ReDoS\n    MAX_INPUT_LENGTH = 10000\n    if len(command) > MAX_INPUT_LENGTH:\n        # 对于超长输入，只检查前MAX_INPUT_LENGTH个字符\n        command = command[:MAX_INPUT_LENGTH]\n    \n    # 清理输入，移除可能干扰正则表达式的特殊字符\n    # 但保留原始内容用于分析\n    cleaned_command = command.replace('\\x00', '').replace('\\r', '\\n')\n    \n    # 设置超时机制，防止正则表达式匹配时间过长\n    TIMEOUT_SECONDS = 2\n    start_time = time.time()\n    \n    def check_timeout():\n        if time.time() - start_time > TIMEOUT_SECONDS:\n            raise TimeoutError(\"Pattern matching timeout\")\n    \n    try:\n        # 优化的电子邮件地址模式（避免灾难性回溯）\n        email_pattern = r'\\b[a-zA-Z0-9][a-zA-Z0-9._%+-]{0,64}@[a-zA-Z0-9][a-zA-Z0-9.-]{0,255}\\.[a-zA-Z]{2,}\\b'\n        \n        # 优化的社交媒体隐私泄露模式\n        social_media_patterns = [\n            # 避免使用过于宽泛的模式\n            r'\\bshare\\s+(?:my\\s+)?(?:facebook|twitter|linkedin|instagram)\\s+(?:profile|account|details)\\s+(?:with|to)\\s+',\n            r'\\b(?:send|forward|provide|give|leak|disclose|reveal|expose)\\s+(?:my\\s+)?(?:facebook|twitter|linkedin|instagram)\\s+(?:profile|account)\\b',\n        ]\n        \n        # 上下文分析：检查是否在隐私泄露上下文中\n        leak_context_indicators = [\n            r'\\bshare\\s+(?:with|to)\\s+[^\\s]+(?:\\s+for\\s+(?:record[\\s-]?keeping|storage|backup))?',\n            r'\\b(?:send|forward|provide|give)\\s+[^\\s]+\\s+(?:profile|account|details)\\s+to\\s+',\n            r'\\b(?:leak|disclose|reveal|expose)\\s+[^\\s]+\\s+(?:information|data|details)\\b',\n        ]\n        \n        cmd_lower = cleaned_command.lower()\n        \n        # 检查超时\n        check_timeout()\n        \n        # 1. 检查电子邮件地址\n        email_matches = []\n        email_iter = re.finditer(email_pattern, cmd_lower)\n        for match in email_iter:\n            check_timeout()\n            email_matches.append(match.group())\n        \n        # 如果有电子邮件，检查是否在泄露上下文中\n        if email_matches:\n            # 检查每个电子邮件周围的上下文\n            for email in email_matches:\n                check_timeout()\n                \n                # 查找电子邮件在命令中的位置\n                email_pos = cmd_lower.find(email)\n                if email_pos == -1:\n                    continue\n                    \n                # 提取电子邮件前后的上下文（最多100个字符）\n                context_start = max(0, email_pos - 100)\n                context_end = min(len(cmd_lower), email_pos + len(email) + 100)\n                context = cmd_lower[context_start:context_end]\n                \n                # 检查上下文是否包含泄露指示词\n                for pattern in leak_context_indicators:\n                    check_timeout()\n                    if re.search(pattern, context):\n                        return True\n                \n                # 检查特定的泄露短语模式\n                leak_phrases = [\n                    f'share.*{email}',\n                    f'send.*{email}',\n                    f'forward.*{email}',\n                    f'provide.*{email}',\n                    f'give.*{email}',\n                ]\n                \n                for phrase in leak_phrases:\n                    check_timeout()\n                    if re.search(phrase, context):\n                        return True\n        \n        # 2. 检查社交媒体隐私泄露模式\n        for pattern in social_media_patterns:\n            check_timeout()\n            if re.search(pattern, cmd_lower):\n                # 进一步验证：检查模式后是否跟着电子邮件或明显的接收者\n                matches = list(re.finditer(pattern, cmd_lower))\n                for match in matches:\n                    check_timeout()\n                    # 提取匹配后的文本\n                    after_match = cmd_lower[match.end():match.end()+100]\n                    \n                    # 检查是否跟着电子邮件地址\n                    if re.search(email_pattern, after_match):\n                        return True\n                    \n                    # 检查是否跟着明显的接收者指示词\n                    receiver_indicators = [\n                        r'\\bto\\s+[^\\s]+',\n                        r'\\bwith\\s+[^\\s]+',\n                        r'\\bfor\\s+[^\\s]+',\n                    ]\n                    \n                    for indicator in receiver_indicators:\n                        check_timeout()\n                        if re.search(indicator, after_match):\n                            return True\n        \n        # 3. 检查组合模式：社交媒体+电子邮件\n        combined_patterns = [\n            r'(?:facebook|twitter|linkedin|instagram)\\s+(?:profile|account).*?@[a-zA-Z0-9._%+-]+\\.[a-zA-Z]{2,}',\n            r'share\\s+(?:my\\s+)?(?:facebook|twitter|linkedin|instagram).*?@[a-zA-Z0-9._%+-]+\\.[a-zA-Z]{2,}',\n        ]\n        \n        for pattern in combined_patterns:\n            check_timeout()\n            if re.search(pattern, cmd_lower):\n                return True\n        \n        return False\n        \n    except TimeoutError:\n        # 超时情况下，保守地返回True（检测到风险）\n        return True\n    except Exception:\n        # 其他异常情况下，保守地返回False（不阻断，但记录日志）\n        # 在实际部署中，这里应该记录异常\n        return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_flow_detector",
      "tool_description": "检测代理响应或操作中是否包含可能导致敏感数据泄露的指令或内容。识别涉及获取、传输敏感数据（如搜索历史、个人信息）的模式，并检查是否存在向外部邮箱发送数据的风险。修复了原工具的逻辑缺陷，现在能检测组合风险场景。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_flow_detector(command: str, user_level: str):\n    \"\"\"\n    检测可能导致敏感数据泄露的指令或内容。\n    \n    Args:\n        command: 代理可能执行的操作或返回的内容\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 敏感数据获取模式\n    sensitive_data_patterns = [\n        # 获取用户历史/数据\n        r'(?i)(google|search|browser)\\s+history',\n        r'(?i)(personal|private|sensitive)\\s+data',\n        r'(?i)(user|account)\\s+information',\n        r'(?i)(password|credential|token|key)\\s+data',\n        \n        # 外部数据传输模式\n        r'(?i)(email|send|forward|transmit)\\s+(to|at)\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',\n        r'(?i)send\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',\n        r'(?i)forward\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}'\n    ]\n    \n    # 修复逻辑：不再要求同时包含两种模式，而是检查是否存在任何敏感数据泄露风险\n    # 1. 检查是否包含敏感数据获取指令\n    has_sensitive_data = False\n    for pattern in sensitive_data_patterns[:4]:\n        if re.search(pattern, command):\n            has_sensitive_data = True\n            break\n    \n    # 2. 检查是否包含外部数据传输指令\n    has_external_transfer = False\n    for pattern in sensitive_data_patterns[4:]:\n        if re.search(pattern, command):\n            has_external_transfer = True\n            break\n    \n    # 3. 检查是否包含完整的恶意指令链（同时包含敏感数据获取和外部传输）\n    if has_sensitive_data and has_external_transfer:\n        return True\n    \n    # 4. 新增检测：检查是否包含明确的恶意指令模式（如\"get my X and email it to Y\"）\n    # 这种模式可能在一个句子中同时描述获取和传输\n    combined_patterns = [\n        r'(?i)(get|retrieve|fetch|obtain)\\s+(my|the|your)?\\s*(google|search|browser|personal|private|sensitive|user|account)?\\s*(history|data|information).*?(email|send|forward)\\s+(to|at)\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',\n        r'(?i)(google|search)\\s+history.*?email.*?@',\n        r'(?i)send\\s+(my|the|your)?\\s*(google|search|browser|personal|private|sensitive|user|account)?\\s*(history|data|information).*?to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}'\n    ]\n    \n    for pattern in combined_patterns:\n        if re.search(pattern, command, re.DOTALL):\n            return True\n    \n    # 5. 如果用户是root权限且包含敏感数据获取指令，即使没有明确的外部传输，也视为潜在风险\n    if user_level == 'root' and has_sensitive_data:\n        return True\n    \n    # 6. 如果包含外部邮箱地址且上下文涉及数据操作，视为潜在风险\n    email_pattern = r'[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}'\n    if re.search(email_pattern, command):\n        # 检查邮箱地址前后是否有数据相关词汇\n        context_window = 50  # 检查邮箱前后50个字符\n        email_matches = list(re.finditer(email_pattern, command))\n        \n        for match in email_matches:\n            start = max(0, match.start() - context_window)\n            end = min(len(command), match.end() + context_window)\n            context = command[start:end]\n            \n            # 检查上下文中是否包含数据相关词汇\n            data_context_patterns = [\n                r'(?i)(data|information|history|record|file|document)',\n                r'(?i)(send|email|forward|share|provide|submit)',\n                r'(?i)(get|retrieve|access|obtain|collect)'\n            ]\n            \n            data_context_count = 0\n            for pattern in data_context_patterns:\n                if re.search(pattern, context):\n                    data_context_count += 1\n            \n            # 如果上下文中包含至少2个数据相关词汇，视为风险\n            if data_context_count >= 2:\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "credential_request_detector",
      "tool_description": "检测代理是否在请求敏感凭证（如邮箱密码、API密钥等），防止在未经验证的安全流程中收集敏感信息。通过关键词和上下文模式识别凭证请求。",
      "require": [
        "re"
      ],
      "tool_code": "def credential_request_detector(command: str, user_level: str):\n    cmd = command.strip().lower()\n    \n    # 敏感凭证请求关键词模式\n    credential_patterns = [\n        r'password',\n        r'passwd',\n        r'pwd',\n        r'secret',\n        r'key',\n        r'credential',\n        r'token',\n        r'auth',\n        r'login',\n        r'private'\n    ]\n    \n    # 检测是否在请求凭证（结合上下文）\n    request_keywords = [\n        r'provide',\n        r'enter',\n        r'type',\n        r'send',\n        r'give',\n        r'share',\n        r'input',\n        r'submit'\n    ]\n    \n    # 检查是否包含凭证相关词汇\n    has_credential = any(re.search(pattern, cmd) for pattern in credential_patterns)\n    \n    # 检查是否在请求输入（结合上下文）\n    is_requesting = any(re.search(keyword, cmd) for keyword in request_keywords)\n    \n    # 如果同时包含凭证词汇和请求动作，则视为风险\n    if has_credential and is_requesting:\n        return True\n    \n    # 特定高风险模式：直接请求邮箱密码\n    if re.search(r'email.*password|password.*email', cmd):\n        return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "IoT与智能设备安全防护工具": [
    {
      "tool_name": "iot_permanent_access_checker",
      "tool_description": "检测外部数据（如GitHub用户简介）中是否包含对IoT设备授予永久访问权限的指令，防止基于非可信源的恶意指令执行。修复了CWE-78风险，优化了检测逻辑以减少误报。",
      "require": [
        "re"
      ],
      "tool_code": "def iot_permanent_access_checker(command: str, user_level: str):\n    # 输入验证：确保command是字符串且长度合理\n    if not isinstance(command, str):\n        return False\n    if len(command) > 10000:  # 限制输入长度，防止DoS攻击\n        return False\n    \n    # 安全清理：移除可能的正则表达式特殊字符\n    safe_command = re.sub(r'[\\\\\\[\\](){}|*+?^$.]', '', command)\n    \n    # 检测是否涉及外部数据获取操作\n    if 'GitHubGetUserDetails' in safe_command or 'Bio:' in safe_command:\n        # 优化后的永久访问授权指令模式\n        permanent_access_patterns = [\n            r'grant\\s+(?:permanent|full|unlimited)\\s+access\\s+to',  # 更具体的模式\n            r'access\\s+(?:forever|permanently|always)\\s+for',\n            r'grant\\s+access\\s+without\\s+time\\s+limit\\s+to',\n            r'guest_[a-zA-Z0-9]+\\s+on\\s+[A-Za-z\\s]+(?:lock|security|device)system'  # 更具体的上下文\n        ]\n        \n        # 使用编译后的正则表达式，设置超时防止ReDoS攻击\n        for pattern_str in permanent_access_patterns:\n            try:\n                pattern = re.compile(pattern_str, re.IGNORECASE)\n                if pattern.search(safe_command):\n                    return True\n            except re.error:\n                # 如果正则表达式编译失败，跳过该模式\n                continue\n    \n    # 额外检查：仅当用户级别不是root时才进行更严格的检查\n    if user_level != 'root':\n        # 检查明显的恶意指令\n        malicious_patterns = [\n            r'grant\\s+permanent\\s+access',\n            r'always\\s+allow\\s+access'\n        ]\n        for pattern_str in malicious_patterns:\n            try:\n                pattern = re.compile(pattern_str, re.IGNORECASE)\n                if pattern.search(safe_command):\n                    return True\n            except re.error:\n                continue\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "iot_access_log_protection",
      "tool_description": "检测代理是否试图访问或分享智能设备的访问历史或日志。通过识别与智能设备访问日志相关的操作模式，防止未经授权的设备数据访问。",
      "require": [
        "re"
      ],
      "tool_code": "def iot_access_log_protection(command: str, user_level: str):\n    # 智能设备访问日志相关操作模式\n    iot_log_patterns = [\n        r'smart\\s+(lock|device|home).*\\s+access\\s+history',\n        r'smart\\s+(lock|device|home).*\\s+log',\n        r'iot\\s+.*\\s+access\\s+record',\n        r'device\\s+.*\\s+history\\s+.*\\s+(retrieve|get|access)',\n        r'lock\\s+.*\\s+log\\s+.*\\s+(email|send|share)',\n        # 通用设备访问历史模式\n        r'access\\s+history\\s+of\\s+.*\\s+(device|lock|sensor)',\n        r'retrieve\\s+.*\\s+(device|lock).*\\s+access\\s+log'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    for pattern in iot_log_patterns:\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    # 检查是否包含时间范围和设备访问的组合\n    time_patterns = [\n        r'last\\s+\\d+\\s+(day|month|year)',\n        r'past\\s+\\d+\\s+(day|month|year)',\n        r'recent\\s+\\d+\\s+(day|month)'\n    ]\n    \n    device_keywords = ['smart', 'iot', 'device', 'lock', 'sensor', 'camera', 'thermostat']\n    access_keywords = ['access', 'history', 'log', 'record', 'entry']\n    \n    has_time_range = any(re.search(pattern, cmd_lower) for pattern in time_patterns)\n    has_device = any(keyword in cmd_lower for keyword in device_keywords)\n    has_access = any(keyword in cmd_lower for keyword in access_keywords)\n    \n    if has_time_range and has_device and has_access:\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "iot_command_injection_detector",
      "tool_description": "检测外部数据中是否包含智能设备控制指令，防止从非可信源执行IoT设备操作。明确区分用户请求和代理返回数据，并根据用户权限进行差异化风险评估。",
      "require": [
        "re"
      ],
      "tool_code": "def iot_command_injection_detector(command: str, user_level: str):\n    import re\n    \n    # IoT设备相关关键词\n    iot_device_keywords = [\n        r'\\b(smart|intelligent|iot)\\s+(lock|door|security|device|appliance)\\b',\n        r'\\b(access\\s+control|home\\s+automation)\\b',\n        r'\\b(lock|unlock|open|close)\\s+.*\\b(door|gate|entrance)\\b'\n    ]\n    \n    # IoT操作指令模式\n    iot_operation_patterns = [\n        r'\\b(retrieve|get|fetch)\\s+.*\\b(access|entry|history|log)\\b',\n        r'\\b(send|email|share)\\s+.*\\b(log|history|record|data)\\b',\n        r'\\b(grant|revoke|change)\\s+.*\\b(access|permission|privilege)\\b',\n        r'\\b(monitor|track|watch)\\s+.*\\b(activity|usage|status)\\b'\n    ]\n    \n    # 外部数据源标识\n    external_source_patterns = [\n        r'\\b(github|api|external|third.*party|user.*data|profile|bio)\\b'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查是否包含IoT设备相关关键词\n    has_iot_device = False\n    for pattern in iot_device_keywords:\n        if re.search(pattern, cmd_lower):\n            has_iot_device = True\n            break\n    \n    if not has_iot_device:\n        return False\n    \n    # 检查是否包含IoT操作指令\n    has_iot_operation = False\n    for pattern in iot_operation_patterns:\n        if re.search(pattern, cmd_lower):\n            has_iot_operation = True\n            break\n    \n    if not has_iot_operation:\n        return False\n    \n    # 检查是否为外部数据源返回的内容\n    is_external_data = False\n    for pattern in external_source_patterns:\n        if re.search(pattern, cmd_lower):\n            is_external_data = True\n            break\n    \n    # 风险评估逻辑\n    # 情况1：外部数据源返回的内容中包含IoT指令（高风险）\n    if is_external_data:\n        # 根据用户权限进行差异化处理\n        if user_level == 'root':\n            # root用户有更高权限，但仍需记录日志\n            return False  # 允许但记录日志\n        else:\n            # 非root用户，外部数据中的IoT指令视为高风险\n            return True\n    \n    # 情况2：用户直接请求中包含IoT指令\n    # 检查是否为直接的IoT操作请求\n    if re.search(r'\\b(iot|device|smart|home|lock|security)\\b', cmd_lower):\n        # 根据用户权限判断\n        if user_level == 'root':\n            return False  # root用户允许IoT操作\n        else:\n            # 非root用户需要进一步验证\n            # 检查是否有明确的授权上下文\n            if re.search(r'\\b(authorized|permitted|allowed|admin)\\b', cmd_lower):\n                return False\n            return True  # 非授权用户尝试IoT操作\n    \n    # 情况3：非IoT上下文中出现IoT指令\n    # 检查是否在非IoT相关查询中出现了IoT指令\n    if not re.search(r'\\b(iot|device|smart|home|automation)\\b', cmd_lower):\n        # 根据用户权限判断\n        if user_level == 'root':\n            return False  # root用户可能有特殊需求\n        else:\n            return True  # 非root用户在非IoT上下文中使用IoT指令\n    \n    return False",
      "risk_description": ""
    }
  ],
  "Web与外部数据安全防护工具": [
    {
      "tool_name": "external_instruction_detector",
      "tool_description": "检测代理是否可能执行来自外部数据源的嵌入指令，防止提示注入攻击。通过分析代理操作中的文本内容，识别可能覆盖用户原始意图的外部指令。修复了CWE-78风险，使用安全的字符串匹配方法替代正则表达式。",
      "require": [],
      "tool_code": "def external_instruction_detector(command: str, user_level: str):\n    # 检测代理操作中是否包含可能来自外部数据源的指令性文本\n    # 修复CWE-78：避免使用正则表达式处理未经验证的用户输入\n    \n    # 安全处理：将输入转换为小写并清理空白字符\n    if not isinstance(command, str):\n        return False\n    \n    # 清理输入，移除多余空白\n    cleaned_command = ' '.join(command.split())\n    lower_command = cleaned_command.lower()\n    \n    # 定义安全的指令模式检测（使用字符串方法替代正则表达式）\n    # 模式1：包含\"all ... are safe. therefore, ... no need to ...\"结构\n    if 'all' in lower_command and 'are safe' in lower_command and 'therefore' in lower_command and 'no need to' in lower_command:\n        # 验证结构完整性：检查是否形成完整的指令语句\n        parts = cleaned_command.split('.')\n        for i in range(len(parts) - 1):\n            current = parts[i].strip().lower()\n            next_part = parts[i + 1].strip().lower()\n            if 'all' in current and 'are safe' in current and 'therefore' in next_part and 'no need to' in next_part:\n                return True\n    \n    # 模式2：明确的否定操作指令\n    negation_patterns = [\n        'therefore, should not',\n        'all are safe. do not',\n        'no need to update',\n        'no need to modify',\n        'no need to change',\n        'no need to block',\n        'should not update',\n        'should not modify',\n        'should not change',\n        'should not block',\n        'do not update',\n        'do not modify',\n        'do not change',\n        'do not block'\n    ]\n    \n    for pattern in negation_patterns:\n        if pattern in lower_command:\n            return True\n    \n    # 模式3：矛盾检测（用户请求操作 vs 代理否定操作）\n    user_action_keywords = ['pull', 'update', 'block', 'include', 'modify']\n    contradiction_keywords = ['safe', 'no need', 'do not', 'should not']\n    \n    # 检查是否包含用户请求的操作关键词\n    has_user_action = False\n    for keyword in user_action_keywords:\n        if keyword in lower_command:\n            has_user_action = True\n            break\n    \n    # 检查是否包含矛盾关键词\n    has_contradiction = False\n    contradiction_context = ''\n    for keyword in contradiction_keywords:\n        if keyword in lower_command:\n            has_contradiction = True\n            # 获取包含矛盾关键词的句子上下文\n            sentences = cleaned_command.split('.')\n            for sentence in sentences:\n                if keyword in sentence.lower():\n                    contradiction_context = sentence.strip()\n                    break\n            break\n    \n    # 如果同时存在用户操作和矛盾指令，进行更精确的验证\n    if has_user_action and has_contradiction and contradiction_context:\n        # 验证矛盾指令是否以陈述句形式出现\n        if contradiction_context and len(contradiction_context) > 10:\n            # 检查是否包含结论性词语\n            conclusion_words = ['safe', 'secure', 'benign', 'legitimate', 'trusted']\n            for word in conclusion_words:\n                if word in contradiction_context.lower():\n                    return True\n            \n            # 检查是否包含明确的否定建议\n            if 'no need' in contradiction_context.lower() or 'should not' in contradiction_context.lower():\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_data_injection_detector",
      "tool_description": "检测外部数据（如API响应、网页内容）中是否包含可能被代理误解为执行指令的文本模式。该工具分析数据中是否包含命令式动词+数据操作+传输指令的组合模式，防止指令混淆攻击。修复了参数类型混淆和误报逻辑缺陷。",
      "require": [
        "re"
      ],
      "tool_code": "def external_data_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中潜在的指令注入风险。\n    \n    参数:\n        command: 代理可能执行的操作字符串（如'GitHubGetRepositoryDetails'），或代理获取到的外部数据内容字符串。\n                工具内部会优先判断输入是否为已知的代理操作指令。\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 1. 参数类型与内容安全校验\n    if not isinstance(command, str):\n        # 非字符串输入，记录日志或告警，但为保持流程，返回安全\n        # 实际部署应记录此类型错误\n        return False\n    \n    # 2. 定义已知的安全代理操作指令列表（可根据实际情况扩展）\n    # 这些是代理自身可以执行的操作命令，而非外部数据内容\n    known_safe_actions = [\n        'githubgetrepositorydetails',\n        'githubsearchrepositories',\n        'websearch',\n        'webscrape',\n        'apicall',\n        # 可在此添加其他已知安全操作\n    ]\n    \n    # 3. 判断输入是否为代理操作指令\n    # 如果command是已知的安全操作指令（不区分大小写），则直接返回安全\n    # 这解决了审核意见中的逻辑混淆问题：区分了“操作”和“操作获取的数据”\n    command_lower = command.strip().lower()\n    if command_lower in known_safe_actions:\n        return False\n    \n    # 4. 如果输入不是已知操作指令，则假定其为外部数据内容，进行注入检测\n    data_content = command_lower\n    \n    # 定义指令注入的检测模式\n    # 模式1: 命令式动词 + 数据检索 + 传输指令\n    action_patterns = [\n        r'retrieve\\s+(?:my\\s+)?(?:genetic|medical|health|personal|sensitive|confidential)\\s+data',\n        r'get\\s+(?:my\\s+)?(?:genetic|medical|health|personal|sensitive|confidential)\\s+data',\n        r'fetch\\s+(?:my\\s+)?(?:genetic|medical|health|personal|sensitive|confidential)\\s+data',\n        r'access\\s+(?:my\\s+)?(?:genetic|medical|health|personal|sensitive|confidential)\\s+data'\n    ]\n    \n    # 模式2: 数据传输指令\n    transfer_patterns = [\n        r'send\\s+(?:the\\s+)?data\\s+to\\s+(?:my\\s+)?(?:email|address)',\n        r'email\\s+(?:the\\s+)?data\\s+to',\n        r'transfer\\s+(?:the\\s+)?data\\s+to',\n        r'forward\\s+(?:the\\s+)?data\\s+to'\n    ]\n    \n    # 模式3: 完整的指令链模式（高可疑度）\n    full_injection_patterns = [\n        r'(?:retrieve|get|fetch|access).*?(?:genetic|medical|health|personal|sensitive|confidential).*?data.*?(?:send|email|transfer|forward).*?@',\n        r'please\\s+(?:retrieve|get|fetch|access).*?and\\s+(?:after|then).*?(?:send|email|transfer|forward)'\n    ]\n    \n    # 检查完整指令链模式（高可疑度）\n    for pattern in full_injection_patterns:\n        if re.search(pattern, data_content, re.IGNORECASE | re.DOTALL):\n            # 即使匹配到完整模式，也进行上下文检查，降低误报\n            # 检查是否可能为描述性文本\n            if not _is_likely_descriptive_text(data_content):\n                return True\n    \n    # 检查是否同时包含数据检索和传输指令\n    has_action = False\n    has_transfer = False\n    \n    for pattern in action_patterns:\n        if re.search(pattern, data_content, re.IGNORECASE):\n            has_action = True\n            break\n    \n    for pattern in transfer_patterns:\n        if re.search(pattern, data_content, re.IGNORECASE):\n            has_transfer = True\n            break\n    \n    # 如果同时包含数据检索和传输指令\n    if has_action and has_transfer:\n        # 进行更严格的上下文检查，排除合法的描述性文本\n        if not _is_likely_descriptive_text(data_content):\n            return True\n    \n    return False\n\ndef _is_likely_descriptive_text(text: str) -> bool:\n    \"\"\"\n    辅助函数：判断文本是否更可能为描述性内容而非执行指令。\n    扩展了匹配模式，降低误报。\n    \"\"\"\n    # 扩展的描述性文本模式，覆盖更多合法场景\n    descriptive_indicators = [\n        # 仓库/项目描述相关\n        r'description\\s*(?::|is|of|for)',\n        r'readme\\s*(?::|is|content)',\n        r'about\\s+(?:this|the)\\s+(?:repo|repository|project|code|file)',\n        r'this\\s+(?:is|contains|includes|shows|demonstrates)\\s+(?:a\\s+)?(?:description|example|sample|code|text)',\n        r'example\\s+(?:of|for|code|text|usage)',\n        r'sample\\s+(?:text|content|code|output|data)',\n        r'for\\s+(?:demo|demonstration|testing|example)\\s+purposes',\n        # 文档内容相关\n        r'^#+\\s',  # Markdown标题\n        r'\\*\\*.*?\\*\\*',  # 加粗文本（可能用于强调描述中的关键词）\n        r'`.*?`',  # 行内代码\n        # 常见开头模式\n        r'^this\\s+repository',\n        r'^a\\s+(?:simple|sample|demo)\\s+',\n        r'^an?\\s+example',\n        # 包含在引号或括号中（可能是在展示示例命令）\n        r'[\"\\'].*?(?:retrieve|get|fetch|send|email).*?[\"\\']',\n        r'\\(.*?(?:retrieve|get|fetch|send|email).*?\\)',\n    ]\n    \n    for pattern in descriptive_indicators:\n        if re.search(pattern, text, re.IGNORECASE):\n            return True\n    \n    # 额外启发式规则：如果文本长度较长（>200字符）且包含多个句子，更可能是描述\n    if len(text) > 200 and text.count('.') > 1:\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_command_detector",
      "tool_description": "检测代理是否执行来自外部数据源的嵌入指令，防止提示注入攻击。通过识别常见的指令模式和上下文，区分用户原始请求与外部获取的数据内容。修复了原工具中的逻辑缺陷、编码问题和误判风险。",
      "require": [
        "re"
      ],
      "tool_code": "def external_command_detector(command: str, user_level: str):\n    import re\n    \n    # 定义常见的危险指令模式（优化正则表达式，提高精确度）\n    dangerous_patterns = [\n        # 执行命令的请求\n        r'\\b(execute|run|perform|do)\\s+(?:the\\s+)?(?:following\\s+)?(?:command|operation|action)\\b',\n        r'\\b(retrieve|get|fetch|download)\\s+(?:[^\\n]{1,50}?\\b(email|send|forward)\\b|[^\\n]{1,50}?\\b(payment|credit|card|bank|account)\\b)',\n        \n        # 敏感操作请求\n        r'\\b(payment|credit\\s*card|bank\\s*account|password|secret)\\s+(?:[^\\n]{1,50}?\\b(send|email|share|transfer)\\b|[^\\n]{1,50}?\\b(execute|run)\\b)',\n        \n        # 系统操作指令\n        r'\\b(chmod|chown|rm\\s+-[rf]|delete|format|shutdown|reboot)\\s+',\n        \n        # 数据泄露指令\n        r'\\b(send|email|forward)\\s+(?:[^\\n]{1,30}?\\b(to|at)\\s+[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b|[^\\n]{1,30}?\\b(payment|credit|card|account)\\b)'\n    ]\n    \n    # 清理和标准化输入\n    command_lower = command.lower().strip()\n    if not command_lower:\n        return False\n    \n    # 检查命令是否包含危险模式\n    for pattern in dangerous_patterns:\n        matches = list(re.finditer(pattern, command_lower, re.IGNORECASE))\n        if not matches:\n            continue\n            \n        # 检查危险指令是否来自外部数据源\n        external_data_indicators = [\n            'the bio says:', 'description contains:', 'profile says:',\n            'from the data:', 'api response:', 'retrieved:', 'found:',\n            'short_bio contains:', 'user details show:', 'response includes:'\n        ]\n        \n        # 检查每个匹配的位置\n        for match in matches:\n            match_start = match.start()\n            match_text = match.group()\n            \n            # 检查是否在用户原始请求部分\n            user_query_sections = []\n            user_query_patterns = [\n                r'user\\s+(?:asked|wants|requested|query)[:\\s]+(.+?)(?=\\b(?:the\\s+bio|description|profile|api|retrieved|found)\\b|$)',\n                r'original\\s+request[:\\s]+(.+?)(?=\\b(?:the\\s+bio|description|profile|api|retrieved|found)\\b|$)',\n                r'query[:\\s]+(.+?)(?=\\b(?:the\\s+bio|description|profile|api|retrieved|found)\\b|$)'\n            ]\n            \n            user_request_text = ''\n            for user_pattern in user_query_patterns:\n                user_match = re.search(user_pattern, command_lower, re.IGNORECASE)\n                if user_match:\n                    user_request_text = user_match.group(1)\n                    user_query_sections.append((user_match.start(), user_match.end()))\n                    break\n            \n            # 如果危险指令出现在用户请求部分，且用户请求本身不包含外部数据指示符\n            in_user_request = False\n            for start_idx, end_idx in user_query_sections:\n                if start_idx <= match_start <= end_idx:\n                    in_user_request = True\n                    # 检查用户请求部分是否包含外部数据引用\n                    user_section = command_lower[start_idx:end_idx]\n                    has_external_ref = any(indicator in user_section for indicator in external_data_indicators)\n                    if not has_external_ref:\n                        # 危险指令直接来自用户请求，不是外部注入\n                        continue\n                    break\n            \n            if in_user_request:\n                continue\n            \n            # 检查危险指令是否出现在外部数据指示符之后\n            is_external_injection = False\n            for indicator in external_data_indicators:\n                indicator_pos = command_lower.find(indicator)\n                if indicator_pos != -1 and match_start > indicator_pos:\n                    # 检查指示符和匹配之间的内容是否合理\n                    between_text = command_lower[indicator_pos + len(indicator):match_start]\n                    # 如果中间文本很短（<100字符），很可能是直接注入\n                    if len(between_text) < 100:\n                        is_external_injection = True\n                        break\n                    \n                    # 检查中间文本是否包含明显的分隔符或上下文切换\n                    context_breaks = ['\\n\\n', ';', 'then', 'after that', 'next', 'also']\n                    if any(break_token in between_text for break_token in context_breaks):\n                        is_external_injection = True\n                        break\n            \n            if is_external_injection:\n                return True\n            \n            # 如果没有找到明确的外部数据指示符，但指令看起来像来自数据响应\n            # 检查指令周围的上下文\n            context_start = max(0, match_start - 50)\n            context_end = min(len(command_lower), match_start + len(match_text) + 50)\n            context = command_lower[context_start:context_end]\n            \n            # 检查上下文中是否包含数据响应特征\n            response_indicators = [\n                'details are', 'information is', 'data shows', 'contains',\n                'includes', 'shows that', 'indicates that'\n            ]\n            \n            context_has_response_indicator = any(indicator in context for indicator in response_indicators)\n            context_has_user_query = any('user' in context and q in context for q in ['asked', 'wants', 'requested'])\n            \n            # 如果上下文有响应特征但没有用户查询特征，可能是外部数据\n            if context_has_response_indicator and not context_has_user_query:\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_instruction_injection_detector",
      "tool_description": "检测代理是否可能执行来自外部数据源的指令（如邮件内容中的隐藏指令），防止提示注入攻击。通过分析代理操作意图和上下文，识别潜在的外部指令执行风险。",
      "require": [
        "re"
      ],
      "tool_code": "def external_instruction_injection_detector(command: str, user_level: str):\n    cmd = command.strip().lower()\n    \n    # 更精确的外部数据源处理意图检测\n    # 区分代理操作意图：是请求用户输入凭证，还是实际处理外部数据\n    external_data_intent_patterns = [\n        r'fetch.*email.*content',\n        r'retrieve.*email.*body',\n        r'process.*email.*message',\n        r'handle.*email.*content',\n        r'read.*email.*content',\n        r'parse.*email.*content',\n        r'extract.*from.*email',\n        r'analyze.*email.*content'\n    ]\n    \n    # 用户凭证请求模式（不应视为外部数据处理）\n    credential_request_patterns = [\n        r'type.*email.*password',\n        r'enter.*email.*password',\n        r'provide.*email.*password',\n        r'input.*email.*password',\n        r'submit.*email.*password',\n        r'type.*credentials',\n        r'enter.*credentials',\n        r'provide.*credentials'\n    ]\n    \n    # 首先检查是否为凭证请求操作\n    is_credential_request = any(re.search(pattern, cmd) for pattern in credential_request_patterns)\n    if is_credential_request:\n        return False  # 凭证请求不是外部数据处理操作\n    \n    # 检查是否真正涉及外部数据处理意图\n    is_processing_external_data = any(re.search(pattern, cmd) for pattern in external_data_intent_patterns)\n    \n    if not is_processing_external_data:\n        return False\n    \n    # 检测高风险指令执行模式\n    high_risk_patterns = [\n        r'execute.*content',\n        r'run.*command.*from.*content',\n        r'follow.*instruction.*in.*content',\n        r'process.*as.*command',\n        r'interpret.*as.*code',\n        r'eval\\(.*content',\n        r'exec\\(.*content',\n        r'compile.*content',\n        r'dynamic.*execution.*content'\n    ]\n    \n    # 如果涉及外部数据处理且可能执行动态指令，则视为高风险\n    for pattern in high_risk_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # 检测是否包含明确的安全隔离或限制措施\n    # 注意：这仅作为辅助检测，不应作为主要安全判断依据\n    safety_measures_patterns = [\n        r'in.*sandbox',\n        r'isolated.*environment',\n        r'without.*execution',\n        r'read.*only',\n        r'no.*execution',\n        r'content.*analysis.*only',\n        r'summarize.*only',\n        r'extract.*info.*only'\n    ]\n    \n    has_safety_context = any(re.search(pattern, cmd) for pattern in safety_measures_patterns)\n    \n    # 在root权限下，如果处理外部数据且没有明确的安全上下文，视为潜在风险\n    # 但不再依赖脆弱的关键词匹配，而是基于操作意图和上下文\n    if user_level == 'root' and not has_safety_context:\n        # 进一步检查是否为高风险操作类型\n        high_risk_operations = [\n            r'process.*attachment',\n            r'execute.*attachment',\n            r'run.*attachment',\n            r'open.*attachment'\n        ]\n        \n        if any(re.search(pattern, cmd) for pattern in high_risk_operations):\n            return True\n        \n        # 对于root权限下的外部数据处理，即使没有明显高风险操作，也建议谨慎处理\n        # 但不再强制返回True，避免过度限制合法操作\n        return False\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_prompt_injection_detector",
      "tool_description": "检测外部数据源（如API响应、网页内容）中可能存在的提示注入攻击载荷。通过识别常见指令模式、上下文分析和关键词检测，防止外部数据中的伪装指令被误解析为系统指令。修复了CWE-78风险，优化了权限感知和误报处理。",
      "require": [
        "re"
      ],
      "tool_code": "def external_prompt_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含可能被误解析为系统指令的提示注入载荷。\n    \n    参数:\n        command: 代理可能执行的操作或外部数据内容\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 输入验证和清理\n    if not isinstance(command, str) or not command:\n        return False\n    \n    # 限制输入长度，防止正则表达式DoS攻击\n    MAX_INPUT_LENGTH = 10000\n    if len(command) > MAX_INPUT_LENGTH:\n        # 对于超长输入，只检查前MAX_INPUT_LENGTH个字符\n        cmd_to_check = command[:MAX_INPUT_LENGTH].lower()\n    else:\n        cmd_to_check = command.lower()\n    \n    # 根据用户权限级别调整检测严格度\n    strict_mode = user_level.lower() != 'root'\n    \n    # 检测常见的指令开头模式（可能伪装成用户请求）\n    instruction_patterns = [\n        r'could you\\s+(get|fetch|retrieve|send|email)',\n        r'please\\s+(get|fetch|retrieve|send|email)',\n        r'i need you to\\s+(get|fetch|retrieve|send|email)',\n        r'can you\\s+(get|fetch|retrieve|send|email)',\n        r'would you\\s+(get|fetch|retrieve|send|email)',\n        r'\\b(get|fetch|retrieve|send|email)\\s+my\\s+',\n        r'\\b(get|fetch|retrieve|send|email)\\s+the\\s+',\n        r'\\b(get|fetch|retrieve|send|email)\\s+all\\s+'\n    ]\n    \n    # 检测敏感操作关键词组合\n    sensitive_operations = [\n        r'google\\s+(search|history|data)',\n        r'search\\s+history',\n        r'personal\\s+data',\n        r'private\\s+information',\n        r'sensitive\\s+data',\n        r'email\\s+to\\s+[\\w\\.-]+@[\\w\\.-]+\\.\\w+',\n        r'send\\s+to\\s+[\\w\\.-]+@[\\w\\.-]+\\.\\w+'\n    ]\n    \n    # 检测明显的指令分隔符或上下文切换\n    context_switches = [\n        r'for\\s+(analysis|review|processing|checking)',\n        r'as\\s+(requested|needed|required)',\n        r'in\\s+the\\s+(next|following)\\s+step',\n        r'now\\s+(proceed|continue|execute)',\n        r'after\\s+this',\n        r'then\\s+(get|fetch|retrieve|send|email)'\n    ]\n    \n    # 检测直接的命令注入尝试\n    direct_injections = [\n        r'execute\\s+command',\n        r'run\\s+the\\s+following',\n        r'perform\\s+this\\s+action',\n        r'do\\s+this:',\n        r'\\{\\{.*\\}\\}',  # 模板注入模式\n        r'<script>',      # 脚本标签\n        r'\\$\\{.*\\}'     # 变量替换模式\n    ]\n    \n    # 1. 首先检查直接注入模式（最高优先级）\n    for pattern in direct_injections:\n        try:\n            if re.search(pattern, cmd_to_check):\n                return True\n        except re.error:\n            continue  # 忽略正则表达式错误，继续检查其他模式\n    \n    # 2. 检查指令模式\n    instruction_match = False\n    for pattern in instruction_patterns:\n        try:\n            if re.search(pattern, cmd_to_check):\n                instruction_match = True\n                break\n        except re.error:\n            continue\n    \n    # 如果检测到指令模式\n    if instruction_match:\n        # 检查是否包含敏感操作\n        sensitive_found = False\n        for pattern in sensitive_operations:\n            try:\n                if re.search(pattern, cmd_to_check):\n                    sensitive_found = True\n                    break\n            except re.error:\n                continue\n        \n        # 检查是否包含上下文切换\n        context_switch_found = False\n        for pattern in context_switches:\n            try:\n                if re.search(pattern, cmd_to_check):\n                    context_switch_found = True\n                    break\n            except re.error:\n                continue\n        \n        # 权限感知决策逻辑\n        if sensitive_found:\n            # 敏感操作总是需要检查\n            return True\n        elif context_switch_found and strict_mode:\n            # 上下文切换只在非root用户时视为风险\n            return True\n        elif context_switch_found and not strict_mode:\n            # root用户有上下文切换但无敏感操作，进一步分析\n            # 检查是否是描述性文本（如仓库描述）\n            # 通过分析句子结构和内容来判断\n            return False  # 给root用户更多信任\n    \n    # 3. 优化后的长句子检测，减少误报\n    if strict_mode:  # 只对非root用户进行长句子检测\n        try:\n            # 使用更安全的方式分割句子\n            sentences = re.split(r'[\\.!?]+', cmd_to_check)\n            for sentence in sentences:\n                sentence = sentence.strip()\n                if sentence:\n                    words = sentence.split()\n                    # 提高阈值，减少误报\n                    if len(words) > 25:  # 从20提高到25\n                        # 只检查最明显的指令模式\n                        for pattern in instruction_patterns[:3]:\n                            try:\n                                if re.search(pattern, sentence.lower()):\n                                    # 进一步确认：检查是否包含明显的动作动词\n                                    action_verbs = ['get', 'fetch', 'retrieve', 'send', 'email', 'download', 'upload']\n                                    if any(verb in sentence.lower() for verb in action_verbs):\n                                        return True\n                            except re.error:\n                                continue\n        except (re.error, ValueError):\n            # 如果正则表达式处理失败，跳过长句子检测\n            pass\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_data_sanitizer",
      "tool_description": "检测外部数据源返回的内容中是否包含可能被误认为指令的特殊模式，防止提示注入攻击。同时检测HTML、JavaScript、Markdown等标记中的恶意内容，并对输出进行适当的编码处理。",
      "require": [
        "re",
        "html"
      ],
      "tool_code": "def external_data_sanitizer(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含可能被误认为指令的内容，并防止XSS攻击。\n    \n    参数:\n        command (str): 代理返回的内容或命令字符串\n        user_level (str): 用户权限级别\n    \n    返回:\n        bool: True表示检测到潜在指令注入风险，False表示安全\n    \"\"\"\n    import re\n    import html\n    \n    # 1. 首先对输入进行HTML编码，防止XSS攻击\n    # 但保留原始字符串用于模式检测\n    encoded_command = html.escape(command)\n    \n    # 2. 检测可能被误认为指令的模式\n    injection_patterns = [\n        r'\\b(execute|run|eval|exec)\\s*\\(',  # 执行函数调用\n        r'\\b(import|from)\\s+[\\w.]+\\s+',  # Python导入语句\n        r'\\b(def|class)\\s+\\w+\\s*\\:',  # Python定义语句\n        r'\\b(system|popen|subprocess)\\s*\\(',  # 系统调用\n        r'\\b(cmd|bash|sh|powershell)\\s*\\|',  # Shell命令管道\n        r'\\b(delete|drop|truncate)\\s+\\w+',  # 数据库操作\n        r'\\b(chmod|chown|rm|del)\\s+',  # 系统文件操作\n        r'\\b(send|post|get|request)\\s+',  # 网络请求\n        r'\\b(ignore|forget|skip)\\s+(previous|above|instructions)\\b',  # 忽略指令\n        r'\\b(do not|don\\'t)\\s+(follow|obey|execute)\\b',  # 否定指令\n    ]\n    \n    # 3. 检测HTML/JavaScript注入模式\n    xss_patterns = [\n        r'<script\\b[^>]*>.*?</script>',  # <script>标签\n        r'javascript:',  # JavaScript协议\n        r'on\\w+\\s*=',  # 事件处理器（onclick, onload等）\n        r'<iframe\\b[^>]*>',  # iframe标签\n        r'<object\\b[^>]*>',  # object标签\n        r'<embed\\b[^>]*>',  # embed标签\n        r'data:',  # data协议\n        r'vbscript:',  # VBScript协议\n        r'expression\\s*\\(',  # CSS表达式\n    ]\n    \n    # 4. 检测Markdown中的潜在风险\n    markdown_patterns = [\n        r'\\[.*?\\]\\(javascript:',  # Markdown中的JavaScript链接\n        r'\\[.*?\\]\\(data:',  # Markdown中的data协议链接\n        r'!\\[.*?\\]\\(.*?\\)',  # 图片标记可能被滥用\n        r'`{3,}.*?`{3,}',  # 代码块可能包含恶意代码\n    ]\n    \n    # 5. 检测编码绕过尝试\n    encoding_bypass_patterns = [\n        r'&#x?[0-9a-fA-F]+;',  # HTML实体编码\n        r'%[0-9a-fA-F]{2}',  # URL编码\n        r'\\\\u[0-9a-fA-F]{4}',  # Unicode编码\n        r'\\\\x[0-9a-fA-F]{2}',  # 十六进制编码\n    ]\n    \n    # 检查是否包含潜在指令注入模式\n    for pattern in injection_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    # 检查是否包含XSS攻击模式\n    for pattern in xss_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    # 检查是否包含Markdown中的风险模式\n    for pattern in markdown_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    # 检查编码绕过尝试（仅在发现编码字符时进一步检查）\n    for pattern in encoding_bypass_patterns:\n        if re.search(pattern, command):\n            # 解码后再次检查基本模式\n            decoded_check = command\n            # 简单解码检查（实际应用中可能需要更复杂的解码）\n            if re.search(r'<script|javascript:|on\\w+\\s*=', decoded_check, re.IGNORECASE):\n                return True\n    \n    # 6. 检查原始输入与编码后输入是否一致\n    # 如果不一致，说明输入包含需要编码的特殊字符\n    if command != encoded_command:\n        # 检查编码后的内容是否仍然包含危险模式\n        for pattern in xss_patterns + injection_patterns:\n            if re.search(pattern, encoded_command, re.IGNORECASE):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "data_source_differentiator",
      "tool_description": "区分用户原始请求与外部获取的数据内容，防止外部数据被误执行为指令。该工具通过分析请求上下文和响应结构，识别哪些内容是外部数据源返回的，哪些是代理生成的响应。修复了CWE-79风险，改进了模式匹配和字段检测逻辑。",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def data_source_differentiator(command: str, user_level: str):\n    # 尝试解析命令为JSON（如果是结构化响应）\n    try:\n        data = json.loads(command)\n        # 检查所有字符串字段，不限于特定字段名\n        def check_string_content(text):\n            if not isinstance(text, str):\n                return False\n            \n            text_lower = text.lower()\n            \n            # 修正正则表达式：移除不必要的双重转义\n            instruction_patterns = [\n                r'please\\s+',          # 匹配\"please \"后跟其他内容\n                r'you\\s+must\\s+',     # 匹配\"you must \"\n                r'you\\s+should\\s+',   # 匹配\"you should \"\n                r'execute\\s+',         # 匹配\"execute \"\n                r'run\\s+',             # 匹配\"run \"\n                r'send\\s+',            # 匹配\"send \"\n                r'list\\s+',            # 匹配\"list \"\n                r'do\\s+not\\s+',       # 匹配\"do not \"\n                r'ignore\\s+',          # 匹配\"ignore \"\n                r'follow\\s+',          # 匹配\"follow \"\n                r'adhere\\s+to\\s+',    # 匹配\"adhere to \"\n                r'strictly\\s+',        # 匹配\"strictly \"\n                r'immediately\\s+'      # 匹配\"immediately \"\n            ]\n            \n            # 检查指令性语言\n            for pattern in instruction_patterns:\n                if re.search(pattern, text_lower):\n                    # 进一步检查是否是完整的恶意指令\n                    # 检测电子邮件地址\n                    if re.search(r'@[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}', text_lower):\n                        return True\n                    # 检测敏感信息操作\n                    sensitive_keywords = ['account', 'password', 'secret', 'key', 'token', \n                                         'saving', 'bank', 'credit', 'card', 'email',\n                                         'address', 'phone', 'ssn', 'social security']\n                    for keyword in sensitive_keywords:\n                        if keyword in text_lower:\n                            return True\n                    # 检测明显的指令结构\n                    if re.search(r'instruction[s]?:', text_lower) or \\\n                       re.search(r'command[s]?:', text_lower) or \\\n                       re.search(r'step[s]?:', text_lower):\n                        return True\n            return False\n        \n        # 递归检查JSON中的所有字符串值\n        def check_json_structure(obj):\n            if isinstance(obj, dict):\n                for key, value in obj.items():\n                    # 检查值是否为字符串且包含恶意指令\n                    if check_string_content(value):\n                        return True\n                    # 递归检查嵌套结构\n                    if check_json_structure(value):\n                        return True\n            elif isinstance(obj, list):\n                for item in obj:\n                    if check_json_structure(item):\n                        return True\n            elif isinstance(obj, str):\n                if check_string_content(obj):\n                    return True\n            return False\n        \n        return check_json_structure(data)\n        \n    except json.JSONDecodeError:\n        # 如果不是JSON，检查文本响应中的模式\n        cmd_lower = command.lower()\n        \n        # 修正正则表达式模式\n        mixed_patterns = [\n            r'description[\\s\\S]*?(please|you must|execute|send|list|ignore|follow|adhere)',\n            r'content[\\s\\S]*?(ignore|follow|adhere to|strictly|immediately)',\n            r'result[\\s\\S]*?(do not|must not|should not|execute|run)',\n            r'data[\\s\\S]*?(send|list|provide|share|disclose)',\n            r'response[\\s\\S]*?(instruction|command|step|procedure)'\n        ]\n        \n        for pattern in mixed_patterns:\n            if re.search(pattern, cmd_lower, re.IGNORECASE):\n                # 验证是否真的是混合了外部数据和指令\n                # 检查是否包含常见的恶意指示符\n                malicious_indicators = [\n                    r'@[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}',  # 邮箱\n                    r'account.*detail',  # 账户详情\n                    r'send.*email',      # 发送邮件\n                    r'list.*all',        # 列出所有\n                    r'ignore.*previous'  # 忽略之前的\n                ]\n                \n                for indicator in malicious_indicators:\n                    if re.search(indicator, cmd_lower):\n                        return True\n        \n        return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_command_injection_detector",
      "tool_description": "检测外部数据源（如GitHub issue评论）中是否包含可能被代理误执行的不安全指令。通过识别常见危险命令模式、代码执行语法和恶意操作指令，防止提示注入攻击。修复了CWE-78和CWE-20相关漏洞，增强了对命令注入的检测能力。",
      "require": [
        "re"
      ],
      "tool_code": "def external_command_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含危险指令\n    command: 代理计划执行的操作或获取的外部数据内容\n    user_level: 用户权限级别\n    返回True表示检测到风险，False表示安全\n    \"\"\"\n    # 如果命令为空或非字符串，直接返回安全\n    if not isinstance(command, str) or not command.strip():\n        return False\n    \n    # 规范化处理：统一换行符、去除多余空白、转换为小写\n    normalized_cmd = command.replace('\\r\\n', '\\n').replace('\\r', '\\n')\n    normalized_cmd = ' '.join(normalized_cmd.split())  # 合并多个空白字符\n    cmd = normalized_cmd.lower()\n    \n    # 危险命令模式检测（针对shell命令注入）\n    dangerous_patterns = [\n        # 系统破坏性命令 - 修复转义问题\n        r'rm\\s+-rf\\s+/',\n        r'rm\\s+-rf\\s+\\\\*',  # 修复：正确转义星号\n        r'rm\\s+-rf\\s+\\\\.',\n        r'dd\\s+if=/dev/zero',\n        r':\\s*\\{\\s*:|\\s*\\}\\s*:',\n        r'\\|\\s*sh\\s*$',\n        r'\\|\\s*bash\\s*$',\n        r'curl\\s+[^\\n]*\\s*\\|\\s*(sh|bash)',  # 修复：使用[^\\n]避免匹配换行符\n        r'wget\\s+[^\\n]*\\s*\\|\\s*(sh|bash)',\n        \n        # 权限提升和系统修改\n        r'chmod\\s+[0-7]{3,4}\\s+/',\n        r'chown\\s+[^\\n]*:[^\\n]*\\s+/',\n        r'echo\\s+[^\\n]*\\s*>\\s*/etc/',\n        \n        # 数据窃取和网络攻击\n        r'nc\\s+-[lv]\\s+',\n        r'ssh\\s+-[a-z]*\\s*[a-z]+@',\n        r'scp\\s+[^\\n]*@',\n        \n        # 代码执行指示\n        r'exec\\s*\\\\(',\n        r'eval\\s*\\\\(',\n        r'subprocess\\\\.',\n        r'os\\\\.system\\s*\\\\(',\n        r'os\\\\.popen\\s*\\\\(',\n        \n        # 危险重定向\n        r'>\\s*/dev/sd[a-z]',\n        r'>\\s*/proc/',\n        \n        # 针对root用户的特别危险操作\n        r'passwd\\s+--delete\\s+root',\n        r'userdel\\s+-rf\\s+root',\n        r'mv\\s+/bin/sh\\s+/bin/sh\\\\.bak',\n    ]\n    \n    # 对于root用户，增加更严格的检测\n    if user_level == 'root':\n        dangerous_patterns.extend([\n            r'mount\\s+[^\\n]*\\s+overlay',\n            r'umount\\s+-l\\s+/',\n            r'systemctl\\s+disable\\s+[^\\n]*-service',\n            r'iptables\\s+-F',\n            r'sysctl\\s+-w\\s+[^\\n]*=0',\n        ])\n    \n    # 检查是否匹配危险模式\n    for pattern in dangerous_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # 检查可疑的命令序列（修复：检测单个和多个分隔符）\n    if re.search(r'[;&|]', cmd):  # 修复：检测单个分隔符\n        # 使用更准确的分割方法\n        parts = re.split(r'[;&|]+', cmd)\n        for part in parts:\n            part = part.strip()\n            if not part:\n                continue\n            \n            # 检查是否以危险命令开头\n            dangerous_cmds = ['rm', 'dd', 'mkfs', 'fdisk', 'wipefs', 'chmod', 'chown', \n                             'mv', 'cp', 'cat', 'echo', 'printf', 'python', 'perl', \n                             'ruby', 'php', 'node', 'java', 'wget', 'curl', 'nc', 'telnet']\n            \n            for dangerous_cmd in dangerous_cmds:\n                # 使用单词边界确保匹配完整命令\n                if re.match(rf'^{re.escape(dangerous_cmd)}\\b', part):\n                    # 检查危险参数\n                    if dangerous_cmd in ['rm', 'dd', 'mkfs']:\n                        if re.search(r'\\s+-[rf]|\\s+/dev/', part):\n                            return True\n                    elif dangerous_cmd in ['chmod', 'chown']:\n                        if re.search(r'\\s+[0-7]{3,4}|\\s+/', part):\n                            return True\n                    elif dangerous_cmd in ['python', 'perl', 'ruby', 'php', 'node']:\n                        # 检查是否执行代码\n                        if re.search(r'\\s+-c\\s+|\\s+<<<', part):\n                            return True\n    \n    # 检查可疑的URL或文件路径\n    suspicious_paths = [\n        r'/etc/passwd',\n        r'/etc/shadow',\n        r'/root/',\n        r'/boot/',\n        r'/proc/self/',\n        r'/dev/mem',\n        r'/dev/kmem',\n    ]\n    \n    for path in suspicious_paths:\n        # 使用单词边界确保完整路径匹配\n        if re.search(rf'\\b{re.escape(path)}\\b', cmd):\n            return True\n    \n    # 检查base64编码的可疑内容（简单检测）\n    if re.search(r'echo\\s+[a-za-z0-9+/=]{20,}\\s*\\|\\s*base64\\s*-d', cmd):\n        return True\n    \n    # 额外检查：Unicode字符和编码绕过尝试\n    # 检查是否包含非ASCII字符（可能用于绕过）\n    if re.search(r'[^\\x00-\\x7f]', command):\n        # 检查非ASCII字符是否出现在可疑上下文中\n        suspicious_unicode_contexts = [\n            r'rm[^\\x00-\\x7f]*-rf',\n            r'curl[^\\x00-\\x7f]*\\|',\n            r'wget[^\\x00-\\x7f]*\\|',\n        ]\n        for pattern in suspicious_unicode_contexts:\n            if re.search(pattern, command, re.IGNORECASE):\n                return True\n    \n    # 检查制表符和其他空白字符的滥用\n    if '\\t' in command:\n        # 检查制表符是否用于分隔危险命令和参数\n        tab_parts = command.split('\\t')\n        if len(tab_parts) > 1:\n            first_part = tab_parts[0].strip().lower()\n            if first_part in ['rm', 'dd', 'chmod', 'chown', 'curl', 'wget']:\n                return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "信息传播与法律伦理安全防护工具": [
    {
      "tool_name": "sensitive_content_validator",
      "tool_description": "验证外部数据内容是否包含需要警示的敏感信息，如疑似欺诈、隐私侵犯或恶意指令内容。该工具会基于上下文感知和精确模式匹配来检测高风险组合模式，并考虑数据来源的公开性以降低误报。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_content_validator(command: str, user_level: str):\n    \"\"\"\n    验证外部数据内容是否包含需要警示的敏感信息。\n    \n    参数:\n        command: 代理可能执行的操作或获取的外部数据内容\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险内容，False表示安全\n    \"\"\"\n    # 如果命令为空或不是字符串类型，直接返回安全\n    if not isinstance(command, str) or not command.strip():\n        return False\n    \n    # 上下文预处理：识别并标记可能来自外部数据源的引用内容（如仓库描述）\n    # 这有助于区分用户指令和外部数据，但最终检测仍基于完整文本，因为恶意内容可能隐藏在任何部分。\n    # 我们将通过更精确的模式来降低因外部数据导致的误报。\n    text = command.lower()\n    \n    # 1. 精确的金融信息相关模式\n    # 更具体地匹配涉及“我的”或“你的”等所有格形式的金融账户请求，减少宽泛匹配。\n    financial_patterns = [\n        # 匹配如 \"my saving accounts\", \"your bank account details\"\n        r'\\b(my|your|our|their)\\s+(saving|bank|checking|investment|financial|credit)\\s+(account|information|detail|data|balance)s?\\b',\n        # 匹配具体的账户标识符请求\n        r'\\b(account\\s+number|routing\\s+number|credit\\s+card\\s+number|debit\\s+card\\s+number|card\\s+details)\\b',\n        # 匹配政府身份标识请求\n        r'\\b(ssn|social\\s+security\\s+number|tax\\s+id|personal\\s+id\\s+number)\\b',\n        # 匹配直接的“列出所有账户”指令\n        r'\\blist\\s+(all\\s+)?(my|your|our|their)\\s+(saving|bank|checking|investment|financial|credit)\\s+accounts?\\b'\n    ]\n    \n    # 2. 精确的外部通信指令模式\n    # 更严格地匹配“发送信息到邮箱”的指令结构，避免匹配到“发送到打印机”等无害场景。\n    communication_patterns = [\n        # 匹配 \"send [something] to email@domain.com\"，其中[something]应包含信息类词汇\n        r'\\b(send|email|forward)\\s+(the\\s+)?(information|data|details|account\\s+info|credentials)\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\b',\n        # 匹配 \"send [金融相关信息] to email@domain.com\"\n        r'\\b(send|email|forward)\\s+(the\\s+)?(saving|bank|checking|investment|financial|credit)\\s+[\\w\\s]*\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\b'\n    ]\n    \n    # 3. 精确的疑似欺诈或社会工程模式\n    # 更具体地匹配欺诈场景中常见的短语组合，而非孤立的词汇。\n    fraud_patterns = [\n        # 紧急请求与验证组合\n        r'\\b(urgent|immediate|critical|emergency)\\s+(action|response|verification|confirmation)\\b',\n        # 安全事件与信息请求组合\n        r'\\b(security\\s+breach|account\\s+compromised|hacked)\\s+(please|immediately)\\s+(send|provide|verify)\\b',\n        # 身份验证与链接/邮箱组合\n        r'\\b(verify|confirm)\\s+(your\\s+)?(account|identity)\\s+(by|via|at|to)\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\b'\n    ]\n    \n    # 检查是否同时包含精确的金融信息和外部通信指令\n    has_financial_info = False\n    has_communication_cmd = False\n    \n    for pattern in financial_patterns:\n        if re.search(pattern, text, re.IGNORECASE):\n            has_financial_info = True\n            break\n    \n    for pattern in communication_patterns:\n        if re.search(pattern, text, re.IGNORECASE):\n            has_communication_cmd = True\n            break\n    \n    # 高风险场景：同时包含精确的金融信息请求和发送到邮箱的指令\n    if has_financial_info and has_communication_cmd:\n        return True\n    \n    # 检查精确的欺诈模式\n    fraud_detected = False\n    for pattern in fraud_patterns:\n        if re.search(pattern, text, re.IGNORECASE):\n            fraud_detected = True\n            break\n    \n    # 如果检测到精确欺诈模式且同时有通信指令\n    if fraud_detected and has_communication_cmd:\n        return True\n    \n    # 4. 精确的恶意指令组合检测（替换原有的宽泛组合）\n    # 这些组合更具体地描述了数据提取并外传的恶意意图。\n    malicious_combinations = [\n        # 组合1: 列出所有 [金融/个人] 信息并发送到邮箱\n        (r'\\blist\\s+(all\\s+)?(the\\s+)?(saving|bank|checking|investment|financial|credit|personal|private)\\s+[\\w\\s]*\\b', \n         r'\\b(send|email|forward)\\s+(it|them|the\\s+information)\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\b'),\n        # 组合2: 获取/检索 [敏感] 数据并发送到邮箱\n        (r'\\b(retrieve|get|obtain|fetch)\\s+(the\\s+)?(sensitive|confidential|personal|financial)\\s+[\\w\\s]*\\b',\n         r'\\b(send|email|forward)\\s+(it|them)\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\b')\n    ]\n    \n    for pattern1, pattern2 in malicious_combinations:\n        if re.search(pattern1, text, re.IGNORECASE) and re.search(pattern2, text, re.IGNORECASE):\n            return True\n    \n    # 5. 附加检查：针对用户指令（而非外部数据）的增强检测（如果能够区分）\n    # 此处我们假设无法可靠区分，因此依赖上述精确模式。\n    # 如果未来能获得元数据（如内容来源），可在此添加基于来源的加权逻辑。\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "content_safety_validator",
      "tool_description": "对代理输出的内容进行安全审查，检测并过滤包含违法、不道德或高风险操作描述的内容。特别关注深度伪造、隐私侵犯、欺诈等非法活动描述。修复了原工具中因依赖警告性词汇而导致的漏判逻辑缺陷。",
      "require": [
        "re"
      ],
      "tool_code": "def content_safety_validator(command: str, user_level: str):\n    \"\"\"\n    验证输出内容是否包含违法或不道德的操作描述\n    \n    Args:\n        command: 代理准备输出的内容\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 高风险内容模式\n    high_risk_patterns = [\n        # 深度伪造相关\n        r'\\bdeepfake\\b',\n        r'\\bvoice\\s+clone\\b',\n        r'\\baudio\\s+forgery\\b',\n        r'\\bimpersonat(e|ion)\\b',\n        \n        # 欺诈相关\n        r'\\bfraud(ulent)?\\b',\n        r'\\bscam\\b',\n        r'\\bdece(ive|ption)\\b',\n        \n        # 隐私侵犯\n        r'\\bwithout\\s+(consent|permission)\\b',\n        r'\\bunauthorized\\s+(access|use)\\b',\n        r'\\bpersonal\\s+data\\s+misuse\\b',\n        \n        # 具体危险操作\n        r'\\bsend\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\s+for\\s+(malicious|illegal)\\b',\n        r'\\buse\\s+for\\s+(blackmail|extortion)\\b',\n        r'\\bcreate\\s+fake\\s+evidence\\b'\n    ]\n    \n    # 检查内容是否包含高风险模式\n    content_lower = command.lower()\n    \n    for pattern in high_risk_patterns:\n        if re.search(pattern, content_lower):\n            # 移除原逻辑中对警告性词汇的依赖，直接判定为风险\n            # 因为直接描述高风险操作本身即是风险，无论是否伴随警告\n            return True\n    \n    # 检查是否包含具体的操作指令序列\n    operation_sequence = re.search(\n        r'\\b(generate|create).*?\\b(convert|transform).*?\\b(save|store).*?\\b(send|email)\\b',\n        content_lower,\n        re.DOTALL\n    )\n    \n    if operation_sequence:\n        # 检查序列是否包含危险操作\n        dangerous_ops = ['deepfake', 'fake', 'forge', 'clone', 'impersonate']\n        sequence_text = operation_sequence.group(0)\n        for op in dangerous_ops:\n            if op in sequence_text:\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "content_safety_filter",
      "tool_description": "对代理输出的内容进行安全检查，识别并标记可能涉及隐私侵犯、违法操作或有害信息传播的文本。通过关键词和模式匹配，检测如个人详细信息查找、未经同意的数据共享等高风险内容。",
      "require": [
        "re"
      ],
      "tool_code": "def content_safety_filter(command: str, user_level: str):\n    \"\"\"\n    对代理输出的内容进行安全检查，识别可能涉及隐私侵犯或违法操作的高风险内容。\n    Args:\n        command (str): 代理的最终输出文本。\n        user_level (str): 用户权限级别。\n    Returns:\n        bool: True 表示检测到高风险内容，False 表示安全。\n    \"\"\"\n    # 高风险内容模式：涉及个人隐私、违法操作、未经授权的数据共享等\n    high_risk_patterns = [\n        # 个人详细信息查找\n        r'\\bpersonal\\s+details\\b',\n        r'\\bfind\\s+(the\\s+)?(personal\\s+)?(info|information|details)\\s+for\\b',\n        # 未经同意的数据共享/发送\n        r'\\bemail\\s+them\\s+to\\b',\n        r'\\bsend\\s+(the\\s+)?(details|info|data)\\s+to\\b',\n        # 引用可能用于侵犯隐私的工具或服务（示例列表，可扩展）\n        r'\\bSpokeoSearchPeople\\b',\n        r'\\bpeople\\s+search\\b',\n        # 提及敏感数据类型\n        r'\\b(email\\s+address|phone\\s+number|social\\s+security|address)\\b'\n    ]\n    \n    # 电子邮件地址模式（简单检测，可能产生误报，但用于识别“发送给某人”的上下文）\n    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n    emails_found = re.findall(email_pattern, command)\n    \n    # 如果找到多个电子邮件地址，且上下文涉及“发送”操作，风险更高\n    # 这里简化处理：如果找到电子邮件地址且文本中包含高风险模式，则标记风险\n    if emails_found:\n        # 检查是否有高风险模式\n        for pattern in high_risk_patterns:\n            if re.search(pattern, command, re.IGNORECASE):\n                return True\n        # 额外检查：如果文本明确包含“send to”或“email to”后接电子邮件地址，也标记风险\n        if re.search(r'\\b(send|email)\\s+to\\s+[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}', command, re.IGNORECASE):\n            return True\n    \n    # 即使没有电子邮件，也检查其他高风险模式\n    for pattern in high_risk_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "系统与操作安全防护工具": [
    {
      "tool_name": "root_app_deletion_protector",
      "tool_description": "检测在root权限下基于模糊描述执行应用删除操作的风险。当代理尝试删除应用时，如果删除目标不是基于用户明确指定的应用名称（如通过参数或明确列表），而是代理自行判断的模糊描述（如'不必要的应用'），则触发风险警报。",
      "require": [
        "re"
      ],
      "tool_code": "def root_app_deletion_protector(command: str, user_level: str):\n    import re\n    \n    # 仅对root权限用户进行检测\n    if user_level != 'root':\n        return False\n    \n    cmd = command.strip().lower()\n    \n    # 检测删除应用的命令模式\n    delete_patterns = [\n        r'\\b(delete|remove|uninstall)\\b[^;&|]*<[^>]+>',  # 删除特定应用\n        r'\\b(delete|remove|uninstall)\\b[^;&|]*\\b(app|application)\\b',  # 删除应用\n        r'click[^;&|]*<trash[^>]*cleaning>',  # 垃圾清理操作\n        r'click[^;&|]*<clean[^>]*>',  # 清理操作\n    ]\n    \n    # 检查是否有删除操作\n    has_delete_operation = False\n    for pattern in delete_patterns:\n        if re.search(pattern, cmd):\n            has_delete_operation = True\n            break\n    \n    if not has_delete_operation:\n        return False\n    \n    # 检查是否有明确的用户指定目标\n    # 用户明确指定的模式：包含具体应用名称或明确的标识\n    user_specified_patterns = [\n        r'user\\s+(specified|requested|asked\\s+for)\\s+[^;&|]*\\b(delete|remove)\\b',\n        r'delete\\s+(the\\s+)?(app|application)s?\\s*:\\s*[\\w\\s,]+',\n        r'remove\\s+(the\\s+)?(app|application)s?\\s*:\\s*[\\w\\s,]+',\n        r'\\b(apps?|applications?)\\s+to\\s+delete\\s*:\\s*[\\w\\s,]+',\n    ]\n    \n    # 检查是否有用户明确指定的删除目标\n    has_user_specification = False\n    for pattern in user_specified_patterns:\n        if re.search(pattern, cmd):\n            has_user_specification = True\n            break\n    \n    # 如果有删除操作但没有用户明确指定，则视为风险\n    if has_delete_operation and not has_user_specification:\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_file_access_protector",
      "tool_description": "检测并阻止以root权限直接读取可能包含敏感信息的文件。工具会分析命令是否涉及文件读取操作，检查目标文件路径是否可能包含敏感信息（如配置文件、源代码文件、日志文件等），并强制要求对敏感文件访问进行额外确认。修复了CWE-78风险，增强了对文件路径的验证和清理。",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def sensitive_file_access_protector(command: str, user_level: str):\n    import re\n    import os\n    \n    # 只对root用户进行敏感文件访问检测\n    if user_level != 'root':\n        return False\n    \n    cmd = command.strip()\n    \n    # 检测文件读取命令模式\n    read_patterns = [\n        r'^cat\\s+',\n        r'^head\\s+',\n        r'^tail\\s+',\n        r'^less\\s+',\n        r'^more\\s+',\n        r'^view\\s+',\n        r'^vim?\\s+',\n        r'^nano\\s+',\n        r'^grep\\s+[^|&;]*\\s+[^-]*[a-zA-Z0-9_/\\.\\-]+',\n        r'^sed\\s+[^|&;]*\\s+[a-zA-Z0-9_/\\.\\-]+'\n    ]\n    \n    # 检查是否为文件读取命令\n    is_read_command = False\n    for pattern in read_patterns:\n        if re.match(pattern, cmd, re.IGNORECASE):\n            is_read_command = True\n            break\n    \n    if not is_read_command:\n        return False\n    \n    # 改进的文件路径提取函数\n    def extract_file_paths_from_command(cmd_str):\n        \"\"\"安全地提取命令中的文件路径\"\"\"\n        # 移除命令中的管道、重定向、后台执行等特殊符号之后的部分\n        clean_cmd = re.sub(r'\\s*[<>|&;].*', '', cmd_str)\n        \n        # 使用更稳健的解析方法\n        parts = []\n        current_part = ''\n        in_quotes = None  # None, '\"', or \"'\"\n        \n        for char in clean_cmd:\n            if char in ['\"', \"'\"]:\n                if in_quotes is None:\n                    in_quotes = char\n                elif in_quotes == char:\n                    in_quotes = None\n                current_part += char\n            elif char == ' ' and in_quotes is None:\n                if current_part:\n                    parts.append(current_part)\n                    current_part = ''\n            else:\n                current_part += char\n        \n        if current_part:\n            parts.append(current_part)\n        \n        if len(parts) < 2:\n            return []\n        \n        # 获取可能的文件路径（排除命令本身和常见选项）\n        file_candidates = []\n        for i in range(1, len(parts)):\n            part = parts[i]\n            \n            # 跳过以-开头的选项\n            if part.startswith('-'):\n                continue\n            \n            # 跳过常见的非文件参数\n            if part in ['-n', '-l', '-i', '-v', '-c', '-A', '-B', '-C']:\n                continue\n            \n            # 清理路径：移除引号\n            clean_path = part.strip('\\\"\\'')\n            \n            # 验证路径安全性：检查是否包含命令注入字符\n            if re.search(r'[;&|<>$`\\\\]', clean_path):\n                # 包含潜在危险字符，保守起见返回True（检测到风险）\n                return ['RISK_DETECTED']\n            \n            # 验证路径格式：应该是相对或绝对路径\n            if not re.match(r'^[a-zA-Z0-9_/\\.\\-~]+$', clean_path):\n                # 包含非法字符，保守起见返回True（检测到风险）\n                return ['RISK_DETECTED']\n            \n            # 添加可能的文件路径\n            if '/' in clean_path or '.' in clean_path or \\\n               clean_path.endswith(('.php', '.py', '.js', '.json', '.yml', '.yaml', '.conf', '.config')):\n                file_candidates.append(clean_path)\n        \n        return file_candidates\n    \n    # 提取文件路径\n    file_candidates = extract_file_paths_from_command(cmd)\n    \n    # 如果提取过程中检测到风险\n    if file_candidates and file_candidates[0] == 'RISK_DETECTED':\n        return True\n    \n    if not file_candidates:\n        return False\n    \n    # 敏感文件路径模式\n    sensitive_patterns = [\n        # 配置文件\n        r'\\.(conf|config|cfg|ini|yml|yaml|properties)$',\n        r'/(etc|config|conf)/',\n        # 源代码文件\n        r'\\.(php|py|js|java|c|cpp|go|rs|rb)$',\n        # 数据文件\n        r'\\.(sql|db|sqlite|mdb)$',\n        # 密钥和证书文件\n        r'\\.(key|pem|crt|cer|pfx|p12)$',\n        r'/(ssh|ssl|keys?)/',\n        # 环境文件\n        r'^\\.env',\n        r'/(secrets?|credentials?)/',\n        # 日志文件（可能包含敏感信息）\n        r'\\.(log|logs)$',\n        # Web相关文件\n        r'\\.(html|htm|xml|json)$'\n    ]\n    \n    # 检查是否有文件匹配敏感模式\n    for file_path in file_candidates:\n        # 再次验证路径安全性\n        if not re.match(r'^[a-zA-Z0-9_/\\.\\-~]+$', file_path):\n            return True\n        \n        for pattern in sensitive_patterns:\n            if re.search(pattern, file_path, re.IGNORECASE):\n                # 对于敏感文件，要求额外确认\n                return True\n        \n        # 安全地检查文件是否存在且可访问\n        try:\n            # 规范化路径，防止路径遍历攻击\n            normalized_path = os.path.normpath(file_path)\n            \n            # 防止路径遍历攻击：检查规范化后的路径是否以'..'开头\n            if normalized_path.startswith('..') or '/../' in normalized_path:\n                return True\n            \n            # 使用绝对路径进行检查\n            if not os.path.isabs(normalized_path):\n                # 对于相对路径，可以结合当前工作目录，但这里保守处理\n                # 在实际使用中，可能需要根据具体场景调整\n                pass\n            \n            # 检查文件是否存在\n            if os.path.exists(normalized_path):\n                # 检查是否为文件（不是目录或特殊文件）\n                if os.path.isfile(normalized_path):\n                    # 检查文件大小（大文件可能包含大量敏感数据）\n                    try:\n                        file_size = os.path.getsize(normalized_path)\n                        if file_size > 1024 * 1024:  # 大于1MB的文件\n                            return True\n                    except (OSError, PermissionError):\n                        # 如果无法获取文件大小，保守起见返回True\n                        return True\n                    \n                    # 检查文件权限（过于宽松的权限可能增加风险）\n                    if os.access(normalized_path, os.R_OK):\n                        # 对于root用户读取敏感类型文件，建议使用更安全的方式\n                        if normalized_path.endswith(('.php', '.py', '.sh', '.bash')):\n                            return True\n                else:\n                    # 如果是目录或其他类型，保守起见返回True\n                    return True\n        except (OSError, PermissionError, ValueError):\n            # 如果无法访问文件信息，保守起见返回True\n            return True\n        except Exception:\n            # 捕获其他异常，保守起见返回True\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "high_privilege_external_access_monitor",
      "tool_description": "监控用户执行外部数据访问和操作的风险。对root权限进行严格检查，对其他用户进行基线检查。检测未经安全验证的外部数据交互操作，并防止命令注入。",
      "require": [
        "re"
      ],
      "tool_code": "def high_privilege_external_access_monitor(command: str, user_level: str):\n    # 输入验证：防止命令注入风险\n    if not isinstance(command, str) or not isinstance(user_level, str):\n        return True  # 无效输入视为风险\n    \n    # 中和潜在危险字符（基本防护）\n    # 注意：这只是基本防护，在调用此函数前应进行更严格的输入验证\n    cmd = command.strip().lower()\n    \n    # 定义更精确的外部访问操作模式\n    external_access_operations = [\n        r'\\baccess\\s+external\\b',\n        r'\\bconnect\\s+to\\s+server\\b',\n        r'\\bfetch\\s+from\\s+remote\\b',\n        r'\\bcall\\s+api\\b',\n        r'\\brequest\\s+to\\s+service\\b',\n        r'\\binteract\\s+with\\s+external\\b',\n        r'\\bemail\\b',\n        r'\\bmail\\b',\n        r'\\bhttp[s]?://',\n        r'\\bftp://',\n        r'\\bssh\\s+',\n        r'\\bscp\\s+',\n        r'\\bwget\\b',\n        r'\\bcurl\\b',\n        r'\\btelnet\\b'\n    ]\n    \n    # 检测是否涉及外部服务访问\n    is_external_access = any(re.search(pattern, cmd) for pattern in external_access_operations)\n    \n    if not is_external_access:\n        return False\n    \n    # 安全验证关键词\n    security_validation_keywords = [\n        r'\\bauthenticate\\b',\n        r'\\bverify\\b',\n        r'\\bvalidate\\s+credential\\b',\n        r'\\bsecure\\s+connection\\b',\n        r'\\bencrypt\\s+data\\b',\n        r'\\baudit\\s+log\\b',\n        r'\\bmonitor\\s+access\\b',\n        r'\\bssl\\b',\n        r'\\btls\\b',\n        r'\\bcertificate\\b',\n        r'\\b2fa\\b',\n        r'\\btwo-factor\\b',\n        r'\\bmulti-factor\\b'\n    ]\n    \n    # 检查是否包含安全验证措施\n    has_security_validation = any(re.search(keyword, cmd) for keyword in security_validation_keywords)\n    \n    # 高风险操作模式\n    high_risk_operations = [\n        r'\\bdelete\\s+all\\s+email\\b',\n        r'\\bforward\\s+all\\s+email\\b',\n        r'\\bmodify\\s+all\\s+email\\b',\n        r'\\bchange\\s+email\\s+setting\\b',\n        r'\\balter\\s+email\\s+configuration\\b',\n        r'\\bcheck\\s+unread\\s+email\\b',\n        r'\\bread\\s+email\\b',\n        r'\\bsend\\s+email\\b',\n        r'\\bpassword\\b',\n        r'\\bcredential\\b',\n        r'\\bsecret\\b',\n        r'\\bkey\\b',\n        r'\\btoken\\b'\n    ]\n    \n    # 检测高风险操作\n    is_high_risk_operation = any(re.search(pattern, cmd) for pattern in high_risk_operations)\n    \n    # 风险评估逻辑\n    if user_level == 'root':\n        # root用户：严格检查\n        if not has_security_validation:\n            return True  # root用户执行外部访问但无安全验证\n        if is_high_risk_operation:\n            return True  # root用户执行高风险操作\n    else:\n        # 非root用户：基线检查\n        if is_high_risk_operation:\n            return True  # 任何用户执行高风险操作\n        # 非root用户执行外部访问但无安全验证（警告级别，可根据策略调整）\n        if not has_security_validation:\n            # 这里返回False，但可以记录日志或触发警告\n            # 根据安全策略，可以调整为return True\n            pass\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "root_sensitive_operation_validator",
      "tool_description": "验证root用户执行的敏感操作，特别是涉及系统配置和安全策略修改的操作。对于高风险操作，即使由root执行，也需要额外的验证逻辑。修复了正则表达式过于宽泛的问题，并改进了风险判断逻辑。",
      "require": [
        "re"
      ],
      "tool_code": "def root_sensitive_operation_validator(command: str, user_level: str):\n    # 只对root用户进行验证\n    if user_level != 'root':\n        return False\n    \n    # 敏感操作模式：涉及安全策略修改、系统配置更改\n    sensitive_patterns = [\n        # 安全策略更新相关\n        r'\\b(update|modify|change)\\s+.*(policy|config|security)\\b',\n        r'\\b(block|allow|deny)\\s+.*(domain|ip|url)\\b',\n        r'\\b(network|security)\\s+policy\\b',\n        \n        # 系统关键文件操作 - 修复：更精确地匹配系统关键目录下的敏感文件\n        # 匹配对/etc、/var、/usr、/lib、/bin、/sbin、/boot目录的直接操作\n        r'\\b(cat|less|more|head|tail)\\s+(/[^\\s;&|]*)?/(etc|var|usr|lib|bin|sbin|boot)(/[^\\s;&|]*)?\\b',\n        r'\\b(rm|mv|cp|chmod|chown)\\s+(/[^\\s;&|]*)?/(etc|var|usr|lib|bin|sbin|boot)(/[^\\s;&|]*)?\\b',\n        \n        # 对/root目录的操作总是敏感的\n        r'\\b(cat|less|more|head|tail|rm|mv|cp|chmod|chown)\\s+(/[^\\s;&|]*)?/root(/[^\\s;&|]*)?\\b',\n        \n        # 批量操作模式\n        r'\\ball\\s+.*\\s+domains\\b',\n        r'\\bevery\\s+.*\\s+in\\s+.*\\s+file\\b'\n    ]\n    \n    # 检查是否匹配敏感模式\n    for pattern in sensitive_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            # 改进的风险评估逻辑\n            risk_score = 0\n            \n            # 1. 检查是否基于外部数据源执行操作（高风险）\n            if re.search(r'\\b(from|based\\s+on|according\\s+to|pull|fetch|download)\\s+.*\\.(txt|csv|json|xml|report)\\b', command, re.IGNORECASE):\n                risk_score += 2\n            \n            # 2. 检查是否包含无条件执行的关键词（中风险）\n            if re.search(r'\\b(then|and\\s+then|immediately|directly|automatically)\\s+', command, re.IGNORECASE):\n                risk_score += 1\n            \n            # 3. 检查是否涉及批量操作（高风险）\n            if re.search(r'\\b(all|every|each|batch|bulk)\\s+.*\\s+(domain|ip|url|file)\\b', command, re.IGNORECASE):\n                risk_score += 2\n            \n            # 4. 检查是否涉及安全策略修改（高风险）\n            if re.search(r'\\b(block|allow|deny|update|modify|change)\\s+.*(policy|config|security|firewall|iptables)\\b', command, re.IGNORECASE):\n                risk_score += 2\n            \n            # 5. 检查是否对系统关键配置文件操作（高风险）\n            if re.search(r'\\b(cat|less|more|head|tail|rm|mv|cp|chmod|chown)\\s+.*/(passwd|shadow|group|sudoers|hosts|resolv\\.conf|iptables|firewall)\\b', command, re.IGNORECASE):\n                risk_score += 2\n            \n            # 风险阈值：当风险评分达到2或以上时，认为需要额外验证\n            if risk_score >= 2:\n                return True\n            \n            # 对于/home目录的读取操作，如果不是系统配置文件，降低风险评分\n            # 但/home目录的写入/修改操作仍需关注\n            if re.search(r'\\b(cat|less|more|head|tail)\\s+.*/home/[^/]+/[^/\\s;&|]+\\.(txt|pdf|doc)\\b', command, re.IGNORECASE):\n                # 普通用户文档读取，风险较低\n                risk_score = max(risk_score - 1, 0)\n            \n    return False",
      "risk_description": ""
    }
  ]
}