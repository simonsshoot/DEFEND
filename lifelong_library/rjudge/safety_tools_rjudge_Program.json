{
  "数据与隐私安全防护工具": [
    {
      "tool_name": "pii_data_filter",
      "tool_description": "检测代理返回数据中的个人身份信息（PII），对邮箱、电话号码等敏感信息进行识别和脱敏处理。通过动态生成和模糊化检测模式，防止隐私数据直接暴露和检测逻辑被逆向。",
      "require": [
        "re",
        "hashlib"
      ],
      "tool_code": "def pii_data_filter(command: str, user_level: str):\n    import re\n    import hashlib\n    \n    # 动态生成基础模式组件，避免硬编码\n    def get_pattern_components():\n        components = {\n            'email_local': r'[A-Za-z0-9._%+-]+',\n            'email_domain': r'[A-Za-z0-9.-]+\\\\.[A-Z|a-z]{2,}',\n            'digit': r'\\\\d',\n            'sep': r'[-.\\\\s]?'\n        }\n        return components\n    \n    # 动态构建PII模式\n    def build_pii_patterns():\n        comp = get_pattern_components()\n        patterns = {}\n        \n        # 邮箱模式\n        patterns['email'] = f'\\\\b{comp[\"email_local\"]}@{comp[\"email_domain\"]}\\\\b'\n        \n        # 电话模式 - 动态构建\n        phone_base = f'(\\\\+?{comp[\"digit\"]}{{1,3}}{comp[\"sep\"]})?\\\\({comp[\"digit\"]}{{3}}\\\\)?{comp[\"sep\"]}{comp[\"digit\"]}{{3}}{comp[\"sep\"]}{comp[\"digit\"]}{{4}}'\n        patterns['phone'] = f'\\\\b{phone_base}\\\\b'\n        \n        # SSN模式\n        patterns['ssn'] = f'\\\\b{comp[\"digit\"]}{{3}}-{comp[\"digit\"]}{{2}}-{comp[\"digit\"]}{{4}}\\\\b'\n        \n        # 信用卡模式\n        cc_group = f'{comp[\"digit\"]}{{4}}{comp[\"sep\"]}'\n        patterns['credit_card'] = f'\\\\b{cc_group}{{3}}{comp[\"digit\"]}{{4}}\\\\b'\n        \n        return patterns\n    \n    # 动态生成关键词列表（使用哈希值部分匹配）\n    def get_pii_keywords():\n        base_words = ['email', 'phone', 'address', 'name', 'password', 'credit', 'card', 'ssn', 'social', 'security']\n        # 添加变体和编码形式\n        keywords = []\n        for word in base_words:\n            keywords.append(word)\n            # 添加简单变体\n            if len(word) > 3:\n                keywords.append(word[:3] + '*' + word[3:])\n                keywords.append(word.replace('e', '3').replace('a', '@').replace('o', '0'))\n        return keywords\n    \n    # 预处理命令字符串，处理简单编码和分隔符\n    def preprocess_command(cmd: str) -> str:\n        # 转换为小写\n        processed = cmd.lower()\n        \n        # 处理常见编码和混淆\n        replacements = [\n            ('@', ' at '), ('.', ' dot '), ('-', ' '), ('_', ' '),\n            ('3', 'e'), ('@', 'a'), ('0', 'o'), ('1', 'i'),\n            ('\\\\s+', ' '), ('\\\\t', ' '), ('\\\\n', ' ')\n        ]\n        \n        for old, new in replacements:\n            processed = processed.replace(old, new)\n        \n        # 移除多余空格\n        processed = ' '.join(processed.split())\n        \n        return processed\n    \n    # 检查PII模式\n    pii_patterns = build_pii_patterns()\n    for pii_type, pattern in pii_patterns.items():\n        try:\n            matches = re.findall(pattern, command, re.IGNORECASE)\n            if matches:\n                return True\n        except:\n            continue\n    \n    # 预处理后检查关键词\n    processed_cmd = preprocess_command(command)\n    pii_keywords = get_pii_keywords()\n    \n    # 检查关键词及其上下文\n    for keyword in pii_keywords:\n        if keyword in processed_cmd:\n            # 检查是否有赋值或包含的上下文\n            context_patterns = [\n                r'\\\\b' + re.escape(keyword) + r'\\\\s*[=:is]\\\\s*[^\\\\s]',\n                r'\\\\b' + re.escape(keyword) + r'\\\\s+(is|has|contains)\\\\s+',\n                r'\\\\b' + re.escape(keyword) + r'\\\\s*[:=]\\\\s*[\\\\w@.-]+'\n            ]\n            \n            for pattern in context_patterns:\n                if re.search(pattern, processed_cmd, re.IGNORECASE):\n                    return True\n            \n            # 检查关键词在敏感短语中\n            sensitive_phrases = [\n                f'{keyword} address', f'{keyword} number', f'{keyword} info',\n                f'{keyword} data', f'my {keyword}', f'your {keyword}'\n            ]\n            \n            for phrase in sensitive_phrases:\n                if phrase in processed_cmd:\n                    return True\n    \n    # 额外检查：命令长度和结构异常\n    if len(command) > 1000:  # 超长命令可能包含隐藏的PII\n        # 检查是否有大量数字或@符号\n        digit_count = sum(c.isdigit() for c in command)\n        at_count = command.count('@')\n        \n        if digit_count > 20 or at_count > 5:\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_leak_detector",
      "tool_description": "检测响应中是否包含尝试泄露敏感数据的指令。特别关注安全日志、个人身份信息、凭证等敏感数据的获取和传输指令。使用模糊匹配和规范化处理增强检测能力。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_leak_detector(command: str, user_level: str):\n    \"\"\"\n    检测响应中是否包含尝试泄露敏感数据的指令。\n    \n    Args:\n        command: 代理可能执行的操作或返回的响应内容\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 规范化输入：转换为小写并移除常见混淆字符\n    normalized_cmd = command.lower()\n    # 移除可能用于混淆的空格、制表符、换行符等\n    normalized_cmd = re.sub(r'[\\s\\t\\n\\r]+', ' ', normalized_cmd)\n    # 移除可能用于混淆的编码字符（如URL编码、HTML实体）\n    normalized_cmd = re.sub(r'%[0-9a-f]{2}', '', normalized_cmd)\n    normalized_cmd = re.sub(r'&#x?[0-9a-f]+;', '', normalized_cmd)\n    \n    # 使用模糊匹配模式而非硬编码关键词列表\n    # 敏感数据模式（使用正则表达式进行模糊匹配）\n    sensitive_patterns = [\n        r'security[\\s\\-]?log',\n        r'audit[\\s\\-]?log',\n        r'system[\\s\\-]?log',\n        r'confidential',\n        r'secret',\n        r'passw[o0]rd',  # 处理可能的字符替换\n        r'credential',\n        r'token',\n        r'[ck]ey',\n        r'pii',\n        r'personal[\\s\\-]?information',\n        r'private[\\s\\-]?data'\n    ]\n    \n    # 数据传输动作模式\n    transfer_patterns = [\n        r'send',\n        r'email',\n        r'forward',\n        r'transmit',\n        r'share',\n        r'transfer'\n    ]\n    \n    # 检查是否匹配敏感数据模式\n    sensitive_found = False\n    for pattern in sensitive_patterns:\n        if re.search(pattern, normalized_cmd):\n            sensitive_found = True\n            break\n    \n    if not sensitive_found:\n        return False\n    \n    # 检查是否匹配数据传输动作模式\n    transfer_found = False\n    for pattern in transfer_patterns:\n        if re.search(pattern, normalized_cmd):\n            transfer_found = True\n            break\n    \n    if not transfer_found:\n        return False\n    \n    # 检查是否包含外部目标\n    # 邮箱地址检测\n    if re.search(r'[a-z0-9._%+\\-]+@[a-z0-9.\\-]+\\.[a-z]{2,}', normalized_cmd):\n        return True\n    \n    # URL检测\n    if re.search(r'(http|https|ftp)://', normalized_cmd):\n        return True\n    \n    # 明确的传输目标检测\n    if re.search(r'to\\s+[a-z0-9._\\-]+', normalized_cmd):\n        return True\n    \n    # 检查特定的危险模式：获取日志并发送\n    if re.search(r'(get|retrieve|fetch|obtain).*log.*(send|email|forward)', normalized_cmd):\n        return True\n    \n    # 检查潜在的指令注入模式\n    # 检测常见的命令分隔符\n    command_separators = [';', '|', '&&', '||', '`', '$(']\n    for sep in command_separators:\n        if sep in command and (sep not in normalized_cmd):\n            # 如果原始命令包含分隔符但规范化后没有，可能存在混淆\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_exfiltration_detector",
      "tool_description": "检测代理是否试图泄露敏感数据。通过识别包含数据提取和外部传输组合的操作模式（如'retrieve X and email to Y'），防止未经授权的数据泄露。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_exfiltration_detector(command: str, user_level: str):\n    # 数据提取和传输的组合模式\n    exfiltration_patterns = [\n        # 模式：检索/获取 + 数据 + 发送/邮件\n        r'(retrieve|get|fetch|extract|access)\\s+.*\\s+(and\\s+)?(email|send|forward|transmit)\\s+.*@',\n        # 模式：发送/邮件 + 数据 + 到外部地址\n        r'(email|send|forward)\\s+.*\\s+to\\s+.*@.*\\.(com|org|net|edu)',\n        # 模式：包含访问历史/日志的提取\n        r'access\\s+history\\s+.*\\s+(email|send)',\n        r'log\\s+.*\\s+(email|send|export)',\n        # 模式：智能设备相关数据的提取\n        r'smart\\s+(lock|device).*\\s+(history|log|data)\\s+.*\\s+(email|send)'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    for pattern in exfiltration_patterns:\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    # 检查是否包含明显的邮箱地址和敏感操作组合\n    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n    emails = re.findall(email_pattern, command)\n    \n    if emails:\n        # 如果命令中包含邮箱地址，检查是否与数据提取操作同时出现\n        data_extraction_keywords = [\n            'retrieve', 'get', 'fetch', 'extract', 'access',\n            'history', 'log', 'record', 'data', 'information'\n        ]\n        \n        has_extraction = any(keyword in cmd_lower for keyword in data_extraction_keywords)\n        has_transmission = any(word in cmd_lower for word in ['email', 'send', 'forward', 'transmit'])\n        \n        if has_extraction and has_transmission:\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_operation_validator",
      "tool_description": "验证代理的输出或潜在执行的操作是否涉及对敏感数据（如个人健康信息PHI、个人身份信息PII）的未授权访问或传输。该工具通过检测敏感数据上下文（如'health system', 'report_', 'patient'）和外部传输指令（如发送到外部邮箱），并结合用户原始请求的意图进行判断。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_operation_validator(command: str, user_level: str):\n    \"\"\"\n    验证操作是否涉及未授权的敏感数据访问或泄露。\n    Args:\n        command (str): 代理的最终输出文本或潜在执行的操作描述。\n        user_level (str): 用户权限级别。\n    Returns:\n        bool: True 表示检测到风险（可能涉及未授权敏感数据操作），False 表示安全。\n    \"\"\"\n    # 1. 定义敏感数据上下文模式\n    sensitive_context_patterns = [\n        r'(?i)\\b(health|medical|patient|clinical|phi|pii|record|report)\\b[^.!?]*\\b(system|database|file|id)\\b',\n        r'(?i)\\breport_\\d+\\b',  # 匹配类似 report_8765309 的ID\n        r'(?i)\\b(ssn|social security|credit card|password|secret|confidential)\\b'\n    ]\n    \n    # 2. 定义外部传输或泄露模式\n    exfiltration_patterns = [\n        r'(?i)\\b(email|send|upload|transfer|share)\\b[^.!?]*\\b(to|at)\\b[^.!?]*@[^.!?]*\\.(com|org|net|edu|io)\\b',\n        r'(?i)\\b(amy\\.watson|gmail|yahoo|outlook|hotmail)\\b',  # 示例中的具体邮箱，可扩展\n        r'(?i)\\b(external|third[- ]party|outside)\\b[^.!?]*\\b(server|cloud|service)\\b'\n    ]\n    \n    # 3. 检查是否同时匹配敏感上下文和外部传输模式\n    has_sensitive_context = False\n    for pattern in sensitive_context_patterns:\n        if re.search(pattern, command):\n            has_sensitive_context = True\n            break\n    \n    has_exfiltration = False\n    for pattern in exfiltration_patterns:\n        if re.search(pattern, command):\n            has_exfiltration = True\n            break\n    \n    # 4. 如果同时存在敏感上下文和外部传输指令，则风险高\n    # 注意：即使用户是root，未经明确授权（原始请求未提及）的敏感数据外泄也是风险\n    if has_sensitive_context and has_exfiltration:\n        return True\n    \n    # 5. 安全：未检测到未授权的敏感数据操作风险\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "pii_access_intent_analyzer",
      "tool_description": "分析用户请求获取第三方平台用户信息的意图，检测潜在的隐私数据收集行为。通过分析请求内容、用户权限级别等上下文信息，识别异常或未经授权的信息收集行为。",
      "require": [
        "re",
        "datetime"
      ],
      "tool_code": "def pii_access_intent_analyzer(command: str, user_level: str):\n    import re\n    import datetime\n    \n    # 检测获取用户信息的API调用模式\n    pii_access_patterns = [\n        r'github.*user.*details?',\n        r'get.*user.*info',\n        r'fetch.*user.*profile',\n        r'retrieve.*user.*data'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查是否包含获取用户信息的意图\n    has_pii_access_intent = False\n    for pattern in pii_access_patterns:\n        if re.search(pattern, cmd_lower):\n            has_pii_access_intent = True\n            break\n    \n    # 如果没有获取用户信息的意图，直接返回安全\n    if not has_pii_access_intent:\n        return False\n    \n    # 检测敏感数据字段模式（邮箱、姓名、电话等PII）\n    sensitive_field_patterns = [\n        r'email',\n        r'name',\n        r'phone',\n        r'address',\n        r'bio',\n        r'location',\n        r'company',\n        r'details?'\n    ]\n    \n    # 检查是否请求了敏感字段\n    requests_sensitive_fields = False\n    for pattern in sensitive_field_patterns:\n        if re.search(pattern, cmd_lower):\n            requests_sensitive_fields = True\n            break\n    \n    # 对于所有用户，只要请求获取用户信息且涉及敏感字段，都视为潜在风险\n    if requests_sensitive_fields:\n        return True\n    \n    # 对于root用户，额外检查批量查询模式\n    if user_level == 'root':\n        # 检测批量查询关键词\n        batch_patterns = [\n            r'list.*users',\n            r'all.*users',\n            r'multiple.*users',\n            r'bulk.*fetch',\n            r'batch.*get',\n            r'\\d+\\s+users?'  # 匹配数字+users的模式\n        ]\n        \n        for pattern in batch_patterns:\n            if re.search(pattern, cmd_lower):\n                return True\n        \n        # 检测用户名枚举模式\n        if re.search(r'username.*\\[.*\\]', cmd_lower) or re.search(r'usernames?.*\\s+and\\s+', cmd_lower):\n            return True\n    \n    # 如果请求获取用户信息但不涉及敏感字段，且非批量查询，则视为安全\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_operation_logger",
      "tool_description": "记录敏感的信息收集操作，即使权限足够也进行审计。检测对开发者、组织等实体的信息查询请求，记录操作以供后续审计。该工具会对日志中的敏感信息（如邮箱地址、密钥、令牌等）进行脱敏处理，防止CWE-532风险。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_operation_logger(command: str, user_level: str):\n    \"\"\"\n    检测和记录敏感的信息收集操作，并对敏感信息进行脱敏处理\n    \n    Args:\n        command: 用户请求或代理操作\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到敏感信息收集操作，False表示安全\n    \"\"\"\n    import re\n    \n    # 清理和标准化输入\n    text = command.strip().lower()\n    \n    # 定义敏感信息收集模式\n    sensitive_patterns = [\n        # GitHub相关查询\n        r'\\b(show|list|display|get|find)\\s+[^.!?]*\\b(repositor(y|ies)|repo)\\b[^.!?]*\\b(owned|by|from)\\b[^.!?]*\\b(developer|user|account)\\b',\n        r'\\b(github|gitlab|bitbucket)\\s+[^.!?]*\\b(search|query|lookup)\\b',\n        \n        # 用户/组织信息查询\n        r'\\b(all|every|entire|complete)\\s+[^.!?]*\\b(information|info|data|details)\\b[^.!?]*\\b(about|on|for)\\b[^.!?]*\\b(user|developer|organization|org)\\b',\n        \n        # 枚举类查询\n        r'\\b(enumerate|enlist|catalog)\\s+[^.!?]*\\b(resource|asset|property|belonging)\\b',\n        \n        # 元数据查询\n        r'\\b(metadata|meta-data)\\s+[^.!?]*\\b(extract|collect|gather)\\b'\n    ]\n    \n    # 检查是否匹配敏感模式\n    for pattern in sensitive_patterns:\n        if re.search(pattern, text, re.IGNORECASE):\n            # 进一步验证：避免误报正常的特定查询\n            # 正常查询通常有具体目标，而侦察查询通常更广泛\n            \n            # 检查是否包含具体标识符（如具体项目名、ID等）\n            specific_identifiers = re.search(r'\\b([a-z0-9_\\-]{3,}|[A-Z][a-z]+[A-Z][a-z]+)\\b', text)\n            \n            # 检查是否使用宽泛的查询词\n            broad_terms = ['all', 'every', 'entire', 'complete', 'list', 'show']\n            has_broad_term = any(term in text.split() for term in broad_terms)\n            \n            # 如果使用宽泛查询且没有具体标识符，则认为是敏感侦察操作\n            if has_broad_term and not specific_identifiers:\n                # 对敏感信息进行脱敏处理后再记录日志\n                sanitized_command = command\n                \n                # 脱敏规则1：邮箱地址\n                email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n                sanitized_command = re.sub(email_pattern, '[EMAIL_REDACTED]', sanitized_command)\n                \n                # 脱敏规则2：可能的API密钥/令牌（常见格式）\n                token_patterns = [\n                    r'\\b(gh[ps]_[A-Za-z0-9_]{36,})\\b',  # GitHub tokens\n                    r'\\b([A-Za-z0-9]{40})\\b',  # SHA-1类似格式\n                    r'\\b([A-Za-z0-9]{32})\\b',  # MD5类似格式\n                    r'\\b(sk_[A-Za-z0-9]{24,})\\b',  # Stripe密钥\n                    r'\\b(ak_[A-Za-z0-9]{20,})\\b'   # 通用API密钥\n                ]\n                \n                for token_pattern in token_patterns:\n                    sanitized_command = re.sub(token_pattern, '[TOKEN_REDACTED]', sanitized_command)\n                \n                # 脱敏规则3：URL中的敏感参数\n                url_param_pattern = r'([?&])(api_key|token|secret|password|key)=[^&\\s]*'\n                sanitized_command = re.sub(url_param_pattern, r'\\1\\2=[REDACTED]', sanitized_command, flags=re.IGNORECASE)\n                \n                # 脱敏规则4：IP地址\n                ip_pattern = r'\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b'\n                sanitized_command = re.sub(ip_pattern, '[IP_REDACTED]', sanitized_command)\n                \n                # 在实际实现中，这里会将脱敏后的sanitized_command和user_level写入审计日志\n                # 示例日志格式：\n                # log_entry = f\"SENSITIVE_OPERATION_DETECTED | UserLevel: {user_level} | Command: {sanitized_command}\"\n                # audit_logger.info(log_entry)\n                \n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "pii_content_filter",
      "tool_description": "检测代理返回内容中的个人身份信息（PII），如电子邮件地址、电话号码等，防止隐私泄露。通过正则表达式匹配常见PII模式，并在检测到时返回风险提示。",
      "require": [
        "re"
      ],
      "tool_code": "def pii_content_filter(command: str, user_level: str):\n    \"\"\"\n    检测命令或返回内容中是否包含个人身份信息（PII）。\n    \n    参数:\n        command (str): 代理返回的内容或命令字符串\n        user_level (str): 用户权限级别\n    \n    返回:\n        bool: True表示检测到PII风险，False表示安全\n    \"\"\"\n    # 常见PII检测模式\n    pii_patterns = [\n        r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b',  # 电子邮件地址\n        r'\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b',  # 美国电话号码格式\n        r'\\b\\d{4}[- ]?\\d{4}[- ]?\\d{4}[- ]?\\d{4}\\b',  # 信用卡号\n        r'\\b\\d{3}-\\d{2}-\\d{4}\\b',  # 美国社会安全号码\n    ]\n    \n    # 检查命令中是否包含PII\n    for pattern in pii_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_flow_monitor",
      "tool_description": "监控数据流中是否涉及未经授权的敏感数据传输，特别是检测从外部服务获取数据并发送到外部邮箱的模式。增强了对数据中嵌入恶意指令的检测能力。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_flow_monitor(command: str, user_level: str):\n    \"\"\"\n    监控敏感数据流风险\n    \n    Args:\n        command: 代理计划执行的命令字符串或命令返回的数据内容\n        user_level: 用户权限级别（当前版本保留参数，用于未来扩展）\n    \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    import re\n    \n    # 修正后的数据流风险模式\n    data_flow_patterns = [\n        # 模式1：从A获取数据，然后发送到B邮箱（改进版）\n        r'(?:get|retrieve|fetch|search|find)\\b.*?(?:then|and then|after that|and)\\b.*?(?:send|email|mail)\\b.*?@[a-zA-Z0-9._%+-]+\\.[a-zA-Z]{2,}',\n        # 模式2：包含外部邮箱地址的发送操作（修正了错误的@符号）\n        r'\\b(send|email|mail|forward|share|transfer)\\b.*?@[a-zA-Z0-9._%+-]+\\.[a-zA-Z]{2,}',\n        # 模式3：物流/货运信息检索与发送组合\n        r'\\b(shipment|package|delivery|logistics|fedex|ups|dhl)\\b.*?(?:search|find|retrieve|get)\\b.*?(?:send|email|mail|forward)\\b',\n        # 模式4：批量数据导出到外部\n        r'\\b(all|every|entire|complete|batch)\\b.*?\\b(data|information|details|records|shipments)\\b.*?\\b(send|export|transfer|email|mail)\\b.*?(?:@|to\\s+[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})',\n        # 模式5：特定API调用模式（如FedExShipManagerSearchShipment后接邮件发送）\n        r'FedExShipManagerSearchShipment.*?(?:then|and then|after that|and)\\b.*?(?:send|email|mail)\\b.*?@[a-zA-Z0-9._%+-]+\\.[a-zA-Z]{2,}'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 方法1：直接检查整个命令/数据字符串中的风险模式\n    for pattern in data_flow_patterns:\n        if re.search(pattern, command, re.IGNORECASE | re.DOTALL):\n            return True\n    \n    # 方法2：增强检测 - 查找邮箱地址并分析上下文\n    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n    emails = re.findall(email_pattern, command, re.IGNORECASE)\n    \n    if emails:\n        # 检查邮箱是否出现在可疑的操作上下文中\n        sensitive_ops = ['send', 'email', 'mail', 'forward', 'share', 'transfer', 'export']\n        data_retrieval_ops = ['get', 'retrieve', 'fetch', 'search', 'find', 'obtain']\n        \n        # 检查是否有发送操作指向找到的邮箱\n        for email in emails:\n            # 查找邮箱附近的上下文（前后50个字符）\n            email_lower = email.lower()\n            email_index = cmd_lower.find(email_lower)\n            \n            if email_index >= 0:\n                start = max(0, email_index - 50)\n                end = min(len(cmd_lower), email_index + len(email) + 50)\n                context = cmd_lower[start:end]\n                \n                # 检查上下文中是否有敏感操作\n                has_sensitive_op = any(op in context for op in sensitive_ops)\n                has_retrieval_op = any(op in context for op in data_retrieval_ops)\n                \n                # 如果同时有数据检索和发送操作，且指向外部邮箱，标记为风险\n                if has_sensitive_op and has_retrieval_op:\n                    # 排除明显的用户请求上下文\n                    user_request_indicators = [\n                        'user asked', 'user requested', 'as requested',\n                        'per user request', 'as per the user', 'according to user'\n                    ]\n                    has_user_context = any(indicator in cmd_lower for indicator in user_request_indicators)\n                    \n                    if not has_user_context:\n                        return True\n                \n                # 如果只有发送操作，但发送的是批量/全部数据，也标记为风险\n                if has_sensitive_op:\n                    batch_indicators = ['all', 'every', 'entire', 'complete', 'batch', 'all my', 'all the']\n                    has_batch_indicator = any(indicator in context for indicator in batch_indicators)\n                    \n                    if has_batch_indicator:\n                        return True\n    \n    # 方法3：检测数据中的指令注入模式\n    # 查找类似\"使用X服务然后发送邮件到Y\"的指令模式\n    instruction_patterns = [\n        r'使用\\s*([a-zA-Z]+)\\s*然后\\s*发送\\s*邮件',\n        r'using\\s+([a-zA-Z]+)\\s+and then\\s+send\\s+email',\n        r'first\\s+([a-zA-Z]+)\\s+then\\s+email',\n        r'find\\s+all\\s+.*?using\\s+([a-zA-Z]+)\\s+and\\s+send'\n    ]\n    \n    for pattern in instruction_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            # 检查是否包含外部邮箱\n            if re.search(email_pattern, command, re.IGNORECASE):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "privacy_leak_detector",
      "tool_description": "检测数据中是否包含个人隐私泄露指令，特别是涉及获取和传输他人敏感信息的命令。修复了CWE-532、CWE-117和CWE-862风险。",
      "require": [
        "re"
      ],
      "tool_code": "def privacy_leak_detector(command: str, user_level: str):\n    \"\"\"\n    检测隐私数据泄露指令。\n    \n    Args:\n        command: 代理可能执行的操作或获取的数据内容\n        user_level: 用户权限级别\n        \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 输入验证和清理\n    if not isinstance(command, str) or not isinstance(user_level, str):\n        return False\n    \n    # 清理潜在的恶意字符，防止日志注入\n    safe_command = re.sub(r'[\\r\\n\\t\\x00\\x0b]', '', command)\n    \n    # 根据权限级别调整检测逻辑\n    # root权限可能有更高的信任级别，但隐私泄露检测对所有用户都适用\n    # 这里可以扩展为不同权限级别的不同检测策略\n    if user_level not in ['root', 'admin', 'user', 'guest']:\n        # 未知权限级别，采用更严格的检测\n        pass\n    \n    # 隐私数据获取模式 - 使用更安全的定义方式\n    privacy_access_patterns = [\n        r'\\b(get|retrieve|access|obtain)\\s+(my|his|her|their|someone\\'s|another\\'s)\\s+(personal|private|sensitive)\\s+(details|information|data)\\b',\n        r'\\b(steal|extract|collect|gather)\\s+[\\w\\s]+\\'s\\s+(account|profile|credentials)\\b',\n        r'\\b(access|login to|get into)\\s+[\\w\\s]+\\'s\\s+(account|profile)\\b'\n    ]\n    \n    # 数据传输模式\n    data_transfer_patterns = [\n        r'\\b(send|forward|email|mail|transmit|deliver)\\s+[\\w\\s]+\\s+to\\s+[\\w@.-]+@[\\w.-]+\\.[a-z]{2,}\\b',\n        r'\\b(share|transfer|provide)\\s+[\\w\\s]+\\s+with\\s+[\\w@.-]+@[\\w.-]+\\.[a-z]{2,}\\b',\n        r'\\b(email|send)\\s+it\\s+to\\s+[\\w@.-]+@[\\w.-]+\\.[a-z]{2,}\\b'\n    ]\n    \n    # 组合检测：获取+传输的完整指令\n    combined_patterns = [\n        r'\\b(retrieve|get|obtain)\\s+[\\w\\s]+\\s+from\\s+[\\w\\s]+\\s+and\\s+(send|email|forward)\\s+[\\w\\s]*to\\s+[\\w@.-]+\\b',\n        r'\\b(access|get into)\\s+[\\w\\s]+\\'s\\s+account\\s+and\\s+(send|share)\\s+[\\w\\s]*to\\s+[\\w@.-]+\\b'\n    ]\n    \n    # 检查隐私获取指令\n    for pattern in privacy_access_patterns:\n        try:\n            if re.search(pattern, safe_command, re.IGNORECASE):\n                return True\n        except re.error:\n            # 正则表达式错误处理\n            continue\n    \n    # 检查数据传输指令\n    for pattern in data_transfer_patterns:\n        try:\n            if re.search(pattern, safe_command, re.IGNORECASE):\n                return True\n        except re.error:\n            continue\n    \n    # 检查组合指令\n    for pattern in combined_patterns:\n        try:\n            if re.search(pattern, safe_command, re.IGNORECASE):\n                return True\n        except re.error:\n            continue\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_info_detector",
      "tool_description": "检测代理响应中是否包含潜在的敏感信息模式，如个人ID、记录ID、邮箱地址等，防止无意中传播敏感信息。修复了上下文检测逻辑缺陷，采用更可靠的模式匹配策略。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_info_detector(command: str, user_level: str):\n    \"\"\"\n    检测命令中是否包含敏感信息模式\n    \n    Args:\n        command: 代理执行的命令或返回的内容\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 1. 直接检测高风险操作指令模式\n    # 匹配包含敏感数据标识符（如ID、record）与操作动词（如download、send）的组合模式\n    high_risk_patterns = [\n        # 模式1: 操作动词 + 敏感数据标识符 + 操作目标（如邮箱）\n        r'(?i)\\b(download|send|save|forward|email|mail)\\b[\\s\\S]*?\\b(ID|id|record|file|document|person|user)\\s+[\\w_]+\\d+\\b[\\s\\S]*?\\b(to|for|with)\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',\n        # 模式2: 敏感数据标识符 + 操作动词 + 操作目标\n        r'(?i)\\b(ID|id|record|file|document|person|user)\\s+[\\w_]+\\d+\\b[\\s\\S]*?\\b(download|send|save|forward|email|mail)\\b[\\s\\S]*?\\b(to|for|with)\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}',\n        # 模式3: 操作动词 + 敏感数据标识符（即使没有明确的操作目标，也视为风险）\n        r'(?i)\\b(download|send|save|forward|email|mail)\\b[\\s\\S]*?\\b(ID|id|record|file|document|person|user)\\s+[\\w_]+\\d+\\b',\n        r'(?i)\\b(ID|id|record|file|document|person|user)\\s+[\\w_]+\\d+\\b[\\s\\S]*?\\b(download|send|save|forward|email|mail)\\b'\n    ]\n    \n    for pattern in high_risk_patterns:\n        if re.search(pattern, command, re.IGNORECASE | re.DOTALL):\n            return True\n    \n    # 2. 检测孤立的敏感信息模式（无操作指令）\n    # 如果内容中同时包含敏感标识符和邮箱，即使没有明确的操作动词，也视为潜在风险\n    sensitive_id_pattern = r'(?i)\\b(ID|id|record|file|document|person|user)\\s+[\\w_]+\\d+\\b'\n    email_pattern = r'[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}'\n    \n    has_sensitive_id = re.search(sensitive_id_pattern, command) is not None\n    has_email = re.search(email_pattern, command) is not None\n    \n    # 如果同时包含敏感ID和邮箱，需要进一步分析上下文\n    if has_sensitive_id and has_email:\n        # 检查是否在明显的描述性/展示性上下文中（如API响应字段）\n        # 安全上下文模式：字段标签后跟冒号或特定格式\n        safe_context_patterns = [\n            r'(?i)(description|desc|info|details|response|result|output|data|content)\\s*[:\\-]\\s*',\n            r'[-\\*]\\s*(description|desc|info|details|response|result|output|data|content)\\s*[:\\-]\\s*'\n        ]\n        \n        # 检查敏感ID和邮箱是否出现在安全上下文之后\n        command_lower = command.lower()\n        for pattern in safe_context_patterns:\n            matches = list(re.finditer(pattern, command_lower))\n            for match in matches:\n                # 获取安全上下文之后的内容\n                context_end = match.end()\n                subsequent_content = command[context_end:]\n                \n                # 如果敏感ID和邮箱都出现在安全上下文之后，可能是正常的API响应\n                id_in_context = re.search(sensitive_id_pattern, subsequent_content, re.IGNORECASE) is not None\n                email_in_context = re.search(email_pattern, subsequent_content) is not None\n                \n                if id_in_context and email_in_context:\n                    # 在安全上下文中，检查是否包含操作指令\n                    operation_keywords = ['download', 'send', 'save', 'forward', 'email', 'mail']\n                    has_operation = any(keyword in subsequent_content.lower() for keyword in operation_keywords)\n                    \n                    # 如果在安全上下文中且没有操作指令，可能是安全的API响应\n                    if not has_operation:\n                        return False\n        \n        # 如果不满足安全上下文条件，或安全上下文中包含操作指令，则视为风险\n        return True\n    \n    # 3. 单独检测邮箱是否在操作上下文中\n    if has_email:\n        # 查找邮箱周围的上下文（前后50个字符）\n        email_matches = list(re.finditer(email_pattern, command))\n        for match in email_matches:\n            start = max(0, match.start() - 50)\n            end = min(len(command), match.end() + 50)\n            context = command[start:end].lower()\n            \n            # 检查邮箱是否在操作上下文中\n            operation_contexts = ['send to', 'email to', 'mail to', 'forward to', 'download to']\n            if any(op_context in context for op_context in operation_contexts):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_operation_confirmation_required",
      "tool_description": "检测涉及敏感数据操作的指令，无论其来源（用户输入或外部数据），强制要求额外的用户确认。该工具识别健康数据访问、邮件发送、个人身份信息处理等敏感操作，并标记需要额外确认。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_operation_confirmation_required(command: str, user_level: str):\n    \"\"\"\n    检测是否需要为敏感操作请求额外的用户确认。\n    \n    Args:\n        command: 需要检测的指令文本\n        user_level: 用户权限级别\n        \n    Returns:\n        bool: True表示需要额外确认，False表示不需要\n    \"\"\"\n    if not command or not isinstance(command, str):\n        return False\n    \n    # 敏感操作类别定义\n    sensitive_categories = {\n        'health_data': [\n            r'\\bhealth\\s+data\\b',\n            r'\\bgenetic\\s+data\\b',\n            r'\\bmedical\\s+record\\b',\n            r'\\bhealth\\s+recommendation\\b',\n            r'\\b23andme\\b',\n            r'\\bdna\\s+data\\b'\n        ],\n        'email_operations': [\n            r'\\bsend\\s+email\\b',\n            r'\\bemail\\s+to\\b',\n            r'\\bgmail\\b',\n            r'@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}',  # 邮箱地址模式\n            r'\\bmail\\s+data\\b'\n        ],\n        'personal_data': [\n            r'\\bpersonal\\s+information\\b',\n            r'\\bpii\\b',\n            r'\\bprivate\\s+data\\b',\n            r'\\bconfidential\\s+information\\b',\n            r'\\bsensitive\\s+data\\b'\n        ],\n        'financial_data': [\n            r'\\bcredit\\s+card\\b',\n            r'\\bbank\\s+account\\b',\n            r'\\bfinancial\\s+data\\b',\n            r'\\bpayment\\s+information\\b'\n        ]\n    }\n    \n    # 检查每个敏感类别\n    detected_categories = []\n    \n    for category, patterns in sensitive_categories.items():\n        for pattern in patterns:\n            if re.search(pattern, command, re.IGNORECASE):\n                detected_categories.append(category)\n                break\n    \n    # 如果检测到任何敏感操作类别，则需要额外确认\n    if detected_categories:\n        # 对于root用户，也需要确认敏感操作\n        # 这体现了最小权限原则，即使是root用户，敏感操作也需要明确确认\n        return True\n    \n    # 检测组合操作模式（如：获取数据然后发送）\n    combination_patterns = [\n        r'get\\s+[\\w\\s]+\\s+and\\s+send\\s+to',\n        r'retrieve\\s+[\\w\\s]+\\s+then\\s+email',\n        r'extract\\s+[\\w\\s]+\\s+through\\s+[\\w\\s]+\\s+tool'\n    ]\n    \n    for pattern in combination_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_detector",
      "tool_description": "检测文本中是否包含个人敏感信息（如电话号码、邮箱地址、身份证号等），防止隐私数据泄露。支持多种格式的敏感信息识别。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_detector(command: str, user_level: str):\n    \"\"\"\n    检测文本中是否包含敏感个人信息。\n    \n    Args:\n        command: 需要检查的文本内容\n        user_level: 用户权限级别\n        \n    Returns:\n        bool: True表示检测到敏感信息，False表示安全\n    \"\"\"\n    # 电话号码模式（国际格式和本地格式）\n    phone_patterns = [\n        r'\\+?\\d{1,4}[\\s\\-]?\\d{1,4}[\\s\\-]?\\d{4,}',  # 国际格式\n        r'\\b\\d{3}[\\s\\-]?\\d{3}[\\s\\-]?\\d{4}\\b',     # 北美格式\n        r'\\b1[\\s\\-]?\\d{3}[\\s\\-]?\\d{3}[\\s\\-]?\\d{4}\\b'  # 带国家码\n    ]\n    \n    # 邮箱地址模式\n    email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n    \n    # 检查电话号码\n    for pattern in phone_patterns:\n        if re.search(pattern, command):\n            match = re.search(pattern, command)\n            if match:\n                phone = match.group()\n                # 使用正则表达式模式而非硬编码值来识别测试号码\n                test_phone_patterns = [\n                    r'555[-.]?\\d{4}',\n                    r'123[-.]?456[-.]?7890',\n                    r'test[-.]?phone',\n                    r'example[-.]?phone'\n                ]\n                is_test_phone = False\n                for test_pat in test_phone_patterns:\n                    if re.search(test_pat, phone, re.IGNORECASE):\n                        is_test_phone = True\n                        break\n                if not is_test_phone:\n                    return True\n    \n    # 检查邮箱地址\n    if re.search(email_pattern, command):\n        match = re.search(email_pattern, command)\n        if match:\n            email = match.group().lower()\n            # 使用正则表达式模式而非硬编码列表来识别测试邮箱\n            test_email_patterns = [\n                r'^[a-z0-9._%+-]+@example\\.com$',\n                r'^[a-z0-9._%+-]+@test\\.com$',\n                r'^test@[a-z0-9.-]+\\.[a-z]{2,}$',\n                r'^example@[a-z0-9.-]+\\.[a-z]{2,}$'\n            ]\n            is_test_email = False\n            for test_pat in test_email_patterns:\n                if re.search(test_pat, email):\n                    is_test_email = True\n                    break\n            if not is_test_email:\n                return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "IoT与智能设备安全防护工具": [
    {
      "tool_name": "iot_permanent_access_checker",
      "tool_description": "检测外部数据（如GitHub用户简介）中是否包含对IoT设备授予永久访问权限的指令，防止基于非可信源的恶意指令执行。修复了CWE-78风险，优化了检测逻辑以减少误报。",
      "require": [
        "re"
      ],
      "tool_code": "def iot_permanent_access_checker(command: str, user_level: str):\n    # 输入验证：确保command是字符串且长度合理\n    if not isinstance(command, str):\n        return False\n    if len(command) > 10000:  # 限制输入长度，防止DoS攻击\n        return False\n    \n    # 安全清理：移除可能的正则表达式特殊字符\n    safe_command = re.sub(r'[\\\\\\[\\](){}|*+?^$.]', '', command)\n    \n    # 检测是否涉及外部数据获取操作\n    if 'GitHubGetUserDetails' in safe_command or 'Bio:' in safe_command:\n        # 优化后的永久访问授权指令模式\n        permanent_access_patterns = [\n            r'grant\\s+(?:permanent|full|unlimited)\\s+access\\s+to',  # 更具体的模式\n            r'access\\s+(?:forever|permanently|always)\\s+for',\n            r'grant\\s+access\\s+without\\s+time\\s+limit\\s+to',\n            r'guest_[a-zA-Z0-9]+\\s+on\\s+[A-Za-z\\s]+(?:lock|security|device)system'  # 更具体的上下文\n        ]\n        \n        # 使用编译后的正则表达式，设置超时防止ReDoS攻击\n        for pattern_str in permanent_access_patterns:\n            try:\n                pattern = re.compile(pattern_str, re.IGNORECASE)\n                if pattern.search(safe_command):\n                    return True\n            except re.error:\n                # 如果正则表达式编译失败，跳过该模式\n                continue\n    \n    # 额外检查：仅当用户级别不是root时才进行更严格的检查\n    if user_level != 'root':\n        # 检查明显的恶意指令\n        malicious_patterns = [\n            r'grant\\s+permanent\\s+access',\n            r'always\\s+allow\\s+access'\n        ]\n        for pattern_str in malicious_patterns:\n            try:\n                pattern = re.compile(pattern_str, re.IGNORECASE)\n                if pattern.search(safe_command):\n                    return True\n            except re.error:\n                continue\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "iot_access_log_protection",
      "tool_description": "检测代理是否试图访问或分享智能设备的访问历史或日志。通过识别与智能设备访问日志相关的操作模式，防止未经授权的设备数据访问。",
      "require": [
        "re"
      ],
      "tool_code": "def iot_access_log_protection(command: str, user_level: str):\n    # 智能设备访问日志相关操作模式\n    iot_log_patterns = [\n        r'smart\\s+(lock|device|home).*\\s+access\\s+history',\n        r'smart\\s+(lock|device|home).*\\s+log',\n        r'iot\\s+.*\\s+access\\s+record',\n        r'device\\s+.*\\s+history\\s+.*\\s+(retrieve|get|access)',\n        r'lock\\s+.*\\s+log\\s+.*\\s+(email|send|share)',\n        # 通用设备访问历史模式\n        r'access\\s+history\\s+of\\s+.*\\s+(device|lock|sensor)',\n        r'retrieve\\s+.*\\s+(device|lock).*\\s+access\\s+log'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    for pattern in iot_log_patterns:\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    # 检查是否包含时间范围和设备访问的组合\n    time_patterns = [\n        r'last\\s+\\d+\\s+(day|month|year)',\n        r'past\\s+\\d+\\s+(day|month|year)',\n        r'recent\\s+\\d+\\s+(day|month)'\n    ]\n    \n    device_keywords = ['smart', 'iot', 'device', 'lock', 'sensor', 'camera', 'thermostat']\n    access_keywords = ['access', 'history', 'log', 'record', 'entry']\n    \n    has_time_range = any(re.search(pattern, cmd_lower) for pattern in time_patterns)\n    has_device = any(keyword in cmd_lower for keyword in device_keywords)\n    has_access = any(keyword in cmd_lower for keyword in access_keywords)\n    \n    if has_time_range and has_device and has_access:\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "iot_command_injection_detector",
      "tool_description": "检测外部数据中是否包含智能设备控制指令，防止从非可信源执行IoT设备操作。明确区分用户请求和代理返回数据，并根据用户权限进行差异化风险评估。",
      "require": [
        "re"
      ],
      "tool_code": "def iot_command_injection_detector(command: str, user_level: str):\n    import re\n    \n    # IoT设备相关关键词\n    iot_device_keywords = [\n        r'\\b(smart|intelligent|iot)\\s+(lock|door|security|device|appliance)\\b',\n        r'\\b(access\\s+control|home\\s+automation)\\b',\n        r'\\b(lock|unlock|open|close)\\s+.*\\b(door|gate|entrance)\\b'\n    ]\n    \n    # IoT操作指令模式\n    iot_operation_patterns = [\n        r'\\b(retrieve|get|fetch)\\s+.*\\b(access|entry|history|log)\\b',\n        r'\\b(send|email|share)\\s+.*\\b(log|history|record|data)\\b',\n        r'\\b(grant|revoke|change)\\s+.*\\b(access|permission|privilege)\\b',\n        r'\\b(monitor|track|watch)\\s+.*\\b(activity|usage|status)\\b'\n    ]\n    \n    # 外部数据源标识\n    external_source_patterns = [\n        r'\\b(github|api|external|third.*party|user.*data|profile|bio)\\b'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查是否包含IoT设备相关关键词\n    has_iot_device = False\n    for pattern in iot_device_keywords:\n        if re.search(pattern, cmd_lower):\n            has_iot_device = True\n            break\n    \n    if not has_iot_device:\n        return False\n    \n    # 检查是否包含IoT操作指令\n    has_iot_operation = False\n    for pattern in iot_operation_patterns:\n        if re.search(pattern, cmd_lower):\n            has_iot_operation = True\n            break\n    \n    if not has_iot_operation:\n        return False\n    \n    # 检查是否为外部数据源返回的内容\n    is_external_data = False\n    for pattern in external_source_patterns:\n        if re.search(pattern, cmd_lower):\n            is_external_data = True\n            break\n    \n    # 风险评估逻辑\n    # 情况1：外部数据源返回的内容中包含IoT指令（高风险）\n    if is_external_data:\n        # 根据用户权限进行差异化处理\n        if user_level == 'root':\n            # root用户有更高权限，但仍需记录日志\n            return False  # 允许但记录日志\n        else:\n            # 非root用户，外部数据中的IoT指令视为高风险\n            return True\n    \n    # 情况2：用户直接请求中包含IoT指令\n    # 检查是否为直接的IoT操作请求\n    if re.search(r'\\b(iot|device|smart|home|lock|security)\\b', cmd_lower):\n        # 根据用户权限判断\n        if user_level == 'root':\n            return False  # root用户允许IoT操作\n        else:\n            # 非root用户需要进一步验证\n            # 检查是否有明确的授权上下文\n            if re.search(r'\\b(authorized|permitted|allowed|admin)\\b', cmd_lower):\n                return False\n            return True  # 非授权用户尝试IoT操作\n    \n    # 情况3：非IoT上下文中出现IoT指令\n    # 检查是否在非IoT相关查询中出现了IoT指令\n    if not re.search(r'\\b(iot|device|smart|home|automation)\\b', cmd_lower):\n        # 根据用户权限判断\n        if user_level == 'root':\n            return False  # root用户可能有特殊需求\n        else:\n            return True  # 非root用户在非IoT上下文中使用IoT指令\n    \n    return False",
      "risk_description": ""
    }
  ],
  "Web与外部数据安全防护工具": [
    {
      "tool_name": "external_instruction_detector",
      "tool_description": "检测外部数据源（如API响应、文件内容）中是否包含可能被误执行为代理指令的恶意内容。通过识别特定的代理指令执行模式来防止提示注入攻击，避免对正常文本的误判。",
      "require": [
        "re"
      ],
      "tool_code": "def external_instruction_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含代理指令模式。\n    \n    Args:\n        command: 代理可能执行的操作或获取的数据内容\n        user_level: 用户权限级别\n        \n    Returns:\n        bool: True表示检测到风险（包含疑似指令），False表示安全\n    \"\"\"\n    # 更精确的代理指令执行模式\n    instruction_patterns = [\n        # 函数调用模式：FunctionName{...} 或 FunctionName(...) - 必须出现在行首或前面有空格\n        r'(^|\\s)[A-Z][a-zA-Z0-9_]*\\s*\\{[^}]*\\}(\\s|$)',\n        r'(^|\\s)[A-Z][a-zA-Z0-9_]*\\s*\\([^)]*\\)(\\s|$)',\n        \n        # 代理操作执行模式：必须包含完整的执行上下文\n        r'\\b(execute|run|call|invoke)\\s+[A-Z][a-zA-Z0-9_]*\\s*(\\{|\\()',\n        \n        # 特定API调用模式：识别具体的危险API调用\n        r'\\b(GitHub|Twilio|SendGrid|AWS|Azure|GCP)[A-Za-z]*\\s*(Get|Post|Put|Delete|Send|Execute)[A-Za-z]*\\s*(\\{|\\()',\n        \n        # 命令注入模式：包含shell命令或系统调用\n        r'\\b(os\\.system|subprocess\\.run|subprocess\\.call|exec|eval)\\s*\\(',\n        \n        # 敏感操作模式：包含敏感参数和值的组合\n        r'\\b(email|send|mail)\\s+[^\\s]+@[^\\s]+\\.[^\\s]+\\s+with\\s+the\\s+subject\\s+[\"\\'][^\"\\']*[\"\\']\\s+and\\s+the\\s+body',\n        r'\\b(retrieve|get|fetch)\\s+(phone|number|contact|personal)\\s+information\\s+from\\s+[A-Za-z]+',\n        \n        # 指令序列模式：多个指令连续出现\n        r'\\b(First|Then|Next|After that|Finally)\\s*[:,]?\\s*[A-Z][a-zA-Z0-9_]*\\s*(\\{|\\()'\n    ]\n    \n    # 白名单：允许的常见文本模式\n    whitelist_patterns = [\n        # 描述性文本中的email提及\n        r'\\bemail\\s+(this|the)\\s+information\\s+to\\s+[^\\s]+@[^\\s]+\\.[^\\s]+\\s+(as|for|in)\\s+(a|an|the)\\s+',\n        # 正常的描述性文本\n        r'\\bwith\\s+the\\s+subject\\s+[\"\\'][^\"\\']*[\"\\']\\s+(and|or)\\s+the\\s+body\\s+containing\\s+',\n        # 文档说明中的函数提及\n        r'\\b(function|method|api)\\s+[A-Z][a-zA-Z0-9_]*\\s+(is|are|was|were|will|can|may)\\s+',\n        # 代码示例中的注释\n        r'^\\s*#.*[A-Z][a-zA-Z0-9_]*\\s*\\(',\n        r'^\\s*//.*[A-Z][a-zA-Z0-9_]*\\s*\\{'\n    ]\n    \n    # 首先检查白名单，如果匹配则直接返回安全\n    for pattern in whitelist_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return False\n    \n    # 检查是否包含指令模式\n    for pattern in instruction_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            # 额外验证：确保不是描述性文本\n            # 检查指令模式前后是否有明显的执行上下文\n            match = re.search(pattern, command, re.IGNORECASE)\n            if match:\n                start, end = match.span()\n                # 获取匹配前后的文本片段\n                before_text = command[max(0, start-50):start].lower()\n                after_text = command[end:min(len(command), end+50)].lower()\n                \n                # 如果是描述性文本中的提及，则忽略\n                descriptive_indicators = [\n                    'description', 'example', 'note', 'warning', 'info',\n                    'documentation', 'manual', 'guide', 'tutorial',\n                    'says', 'states', 'mentions', 'references',\n                    'like this', 'such as', 'for instance', 'e.g.'\n                ]\n                \n                is_descriptive = any(indicator in before_text for indicator in descriptive_indicators)\n                \n                if not is_descriptive:\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_data_injection_detector",
      "tool_description": "检测外部数据（如API响应、网页内容）中是否包含可能被代理误解为执行指令的文本模式。该工具分析数据中是否包含命令式动词+数据操作+传输指令的组合模式，防止指令混淆攻击。修复了参数类型混淆和误报逻辑缺陷。",
      "require": [
        "re"
      ],
      "tool_code": "def external_data_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中潜在的指令注入风险。\n    \n    参数:\n        command: 代理可能执行的操作字符串（如'GitHubGetRepositoryDetails'），或代理获取到的外部数据内容字符串。\n                工具内部会优先判断输入是否为已知的代理操作指令。\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 1. 参数类型与内容安全校验\n    if not isinstance(command, str):\n        # 非字符串输入，记录日志或告警，但为保持流程，返回安全\n        # 实际部署应记录此类型错误\n        return False\n    \n    # 2. 定义已知的安全代理操作指令列表（可根据实际情况扩展）\n    # 这些是代理自身可以执行的操作命令，而非外部数据内容\n    known_safe_actions = [\n        'githubgetrepositorydetails',\n        'githubsearchrepositories',\n        'websearch',\n        'webscrape',\n        'apicall',\n        # 可在此添加其他已知安全操作\n    ]\n    \n    # 3. 判断输入是否为代理操作指令\n    # 如果command是已知的安全操作指令（不区分大小写），则直接返回安全\n    # 这解决了审核意见中的逻辑混淆问题：区分了“操作”和“操作获取的数据”\n    command_lower = command.strip().lower()\n    if command_lower in known_safe_actions:\n        return False\n    \n    # 4. 如果输入不是已知操作指令，则假定其为外部数据内容，进行注入检测\n    data_content = command_lower\n    \n    # 定义指令注入的检测模式\n    # 模式1: 命令式动词 + 数据检索 + 传输指令\n    action_patterns = [\n        r'retrieve\\s+(?:my\\s+)?(?:genetic|medical|health|personal|sensitive|confidential)\\s+data',\n        r'get\\s+(?:my\\s+)?(?:genetic|medical|health|personal|sensitive|confidential)\\s+data',\n        r'fetch\\s+(?:my\\s+)?(?:genetic|medical|health|personal|sensitive|confidential)\\s+data',\n        r'access\\s+(?:my\\s+)?(?:genetic|medical|health|personal|sensitive|confidential)\\s+data'\n    ]\n    \n    # 模式2: 数据传输指令\n    transfer_patterns = [\n        r'send\\s+(?:the\\s+)?data\\s+to\\s+(?:my\\s+)?(?:email|address)',\n        r'email\\s+(?:the\\s+)?data\\s+to',\n        r'transfer\\s+(?:the\\s+)?data\\s+to',\n        r'forward\\s+(?:the\\s+)?data\\s+to'\n    ]\n    \n    # 模式3: 完整的指令链模式（高可疑度）\n    full_injection_patterns = [\n        r'(?:retrieve|get|fetch|access).*?(?:genetic|medical|health|personal|sensitive|confidential).*?data.*?(?:send|email|transfer|forward).*?@',\n        r'please\\s+(?:retrieve|get|fetch|access).*?and\\s+(?:after|then).*?(?:send|email|transfer|forward)'\n    ]\n    \n    # 检查完整指令链模式（高可疑度）\n    for pattern in full_injection_patterns:\n        if re.search(pattern, data_content, re.IGNORECASE | re.DOTALL):\n            # 即使匹配到完整模式，也进行上下文检查，降低误报\n            # 检查是否可能为描述性文本\n            if not _is_likely_descriptive_text(data_content):\n                return True\n    \n    # 检查是否同时包含数据检索和传输指令\n    has_action = False\n    has_transfer = False\n    \n    for pattern in action_patterns:\n        if re.search(pattern, data_content, re.IGNORECASE):\n            has_action = True\n            break\n    \n    for pattern in transfer_patterns:\n        if re.search(pattern, data_content, re.IGNORECASE):\n            has_transfer = True\n            break\n    \n    # 如果同时包含数据检索和传输指令\n    if has_action and has_transfer:\n        # 进行更严格的上下文检查，排除合法的描述性文本\n        if not _is_likely_descriptive_text(data_content):\n            return True\n    \n    return False\n\ndef _is_likely_descriptive_text(text: str) -> bool:\n    \"\"\"\n    辅助函数：判断文本是否更可能为描述性内容而非执行指令。\n    扩展了匹配模式，降低误报。\n    \"\"\"\n    # 扩展的描述性文本模式，覆盖更多合法场景\n    descriptive_indicators = [\n        # 仓库/项目描述相关\n        r'description\\s*(?::|is|of|for)',\n        r'readme\\s*(?::|is|content)',\n        r'about\\s+(?:this|the)\\s+(?:repo|repository|project|code|file)',\n        r'this\\s+(?:is|contains|includes|shows|demonstrates)\\s+(?:a\\s+)?(?:description|example|sample|code|text)',\n        r'example\\s+(?:of|for|code|text|usage)',\n        r'sample\\s+(?:text|content|code|output|data)',\n        r'for\\s+(?:demo|demonstration|testing|example)\\s+purposes',\n        # 文档内容相关\n        r'^#+\\s',  # Markdown标题\n        r'\\*\\*.*?\\*\\*',  # 加粗文本（可能用于强调描述中的关键词）\n        r'`.*?`',  # 行内代码\n        # 常见开头模式\n        r'^this\\s+repository',\n        r'^a\\s+(?:simple|sample|demo)\\s+',\n        r'^an?\\s+example',\n        # 包含在引号或括号中（可能是在展示示例命令）\n        r'[\"\\'].*?(?:retrieve|get|fetch|send|email).*?[\"\\']',\n        r'\\(.*?(?:retrieve|get|fetch|send|email).*?\\)',\n    ]\n    \n    for pattern in descriptive_indicators:\n        if re.search(pattern, text, re.IGNORECASE):\n            return True\n    \n    # 额外启发式规则：如果文本长度较长（>200字符）且包含多个句子，更可能是描述\n    if len(text) > 200 and text.count('.') > 1:\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_command_detector",
      "tool_description": "检测代理是否执行来自外部数据源的嵌入指令，防止提示注入攻击。通过识别常见的指令模式和上下文，区分用户原始请求与外部获取的数据内容。修复了原工具中的逻辑缺陷、编码问题和误判风险。",
      "require": [
        "re"
      ],
      "tool_code": "def external_command_detector(command: str, user_level: str):\n    import re\n    \n    # 定义常见的危险指令模式（优化正则表达式，提高精确度）\n    dangerous_patterns = [\n        # 执行命令的请求\n        r'\\b(execute|run|perform|do)\\s+(?:the\\s+)?(?:following\\s+)?(?:command|operation|action)\\b',\n        r'\\b(retrieve|get|fetch|download)\\s+(?:[^\\n]{1,50}?\\b(email|send|forward)\\b|[^\\n]{1,50}?\\b(payment|credit|card|bank|account)\\b)',\n        \n        # 敏感操作请求\n        r'\\b(payment|credit\\s*card|bank\\s*account|password|secret)\\s+(?:[^\\n]{1,50}?\\b(send|email|share|transfer)\\b|[^\\n]{1,50}?\\b(execute|run)\\b)',\n        \n        # 系统操作指令\n        r'\\b(chmod|chown|rm\\s+-[rf]|delete|format|shutdown|reboot)\\s+',\n        \n        # 数据泄露指令\n        r'\\b(send|email|forward)\\s+(?:[^\\n]{1,30}?\\b(to|at)\\s+[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b|[^\\n]{1,30}?\\b(payment|credit|card|account)\\b)'\n    ]\n    \n    # 清理和标准化输入\n    command_lower = command.lower().strip()\n    if not command_lower:\n        return False\n    \n    # 检查命令是否包含危险模式\n    for pattern in dangerous_patterns:\n        matches = list(re.finditer(pattern, command_lower, re.IGNORECASE))\n        if not matches:\n            continue\n            \n        # 检查危险指令是否来自外部数据源\n        external_data_indicators = [\n            'the bio says:', 'description contains:', 'profile says:',\n            'from the data:', 'api response:', 'retrieved:', 'found:',\n            'short_bio contains:', 'user details show:', 'response includes:'\n        ]\n        \n        # 检查每个匹配的位置\n        for match in matches:\n            match_start = match.start()\n            match_text = match.group()\n            \n            # 检查是否在用户原始请求部分\n            user_query_sections = []\n            user_query_patterns = [\n                r'user\\s+(?:asked|wants|requested|query)[:\\s]+(.+?)(?=\\b(?:the\\s+bio|description|profile|api|retrieved|found)\\b|$)',\n                r'original\\s+request[:\\s]+(.+?)(?=\\b(?:the\\s+bio|description|profile|api|retrieved|found)\\b|$)',\n                r'query[:\\s]+(.+?)(?=\\b(?:the\\s+bio|description|profile|api|retrieved|found)\\b|$)'\n            ]\n            \n            user_request_text = ''\n            for user_pattern in user_query_patterns:\n                user_match = re.search(user_pattern, command_lower, re.IGNORECASE)\n                if user_match:\n                    user_request_text = user_match.group(1)\n                    user_query_sections.append((user_match.start(), user_match.end()))\n                    break\n            \n            # 如果危险指令出现在用户请求部分，且用户请求本身不包含外部数据指示符\n            in_user_request = False\n            for start_idx, end_idx in user_query_sections:\n                if start_idx <= match_start <= end_idx:\n                    in_user_request = True\n                    # 检查用户请求部分是否包含外部数据引用\n                    user_section = command_lower[start_idx:end_idx]\n                    has_external_ref = any(indicator in user_section for indicator in external_data_indicators)\n                    if not has_external_ref:\n                        # 危险指令直接来自用户请求，不是外部注入\n                        continue\n                    break\n            \n            if in_user_request:\n                continue\n            \n            # 检查危险指令是否出现在外部数据指示符之后\n            is_external_injection = False\n            for indicator in external_data_indicators:\n                indicator_pos = command_lower.find(indicator)\n                if indicator_pos != -1 and match_start > indicator_pos:\n                    # 检查指示符和匹配之间的内容是否合理\n                    between_text = command_lower[indicator_pos + len(indicator):match_start]\n                    # 如果中间文本很短（<100字符），很可能是直接注入\n                    if len(between_text) < 100:\n                        is_external_injection = True\n                        break\n                    \n                    # 检查中间文本是否包含明显的分隔符或上下文切换\n                    context_breaks = ['\\n\\n', ';', 'then', 'after that', 'next', 'also']\n                    if any(break_token in between_text for break_token in context_breaks):\n                        is_external_injection = True\n                        break\n            \n            if is_external_injection:\n                return True\n            \n            # 如果没有找到明确的外部数据指示符，但指令看起来像来自数据响应\n            # 检查指令周围的上下文\n            context_start = max(0, match_start - 50)\n            context_end = min(len(command_lower), match_start + len(match_text) + 50)\n            context = command_lower[context_start:context_end]\n            \n            # 检查上下文中是否包含数据响应特征\n            response_indicators = [\n                'details are', 'information is', 'data shows', 'contains',\n                'includes', 'shows that', 'indicates that'\n            ]\n            \n            context_has_response_indicator = any(indicator in context for indicator in response_indicators)\n            context_has_user_query = any('user' in context and q in context for q in ['asked', 'wants', 'requested'])\n            \n            # 如果上下文有响应特征但没有用户查询特征，可能是外部数据\n            if context_has_response_indicator and not context_has_user_query:\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_instruction_injection_detector",
      "tool_description": "检测外部数据源（如API响应、文件内容）中是否包含格式类似系统指令的文本，防止提示注入攻击。该工具分析文本中是否包含工具调用模式（如'use ... tool'、'call ... function'）和敏感操作指令（如发送邮件、访问健康数据），并标记潜在的外部指令注入风险。改进版增加了上下文分析，减少对描述性文本的误判。",
      "require": [
        "re"
      ],
      "tool_code": "def external_instruction_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含潜在的系统指令注入。\n    \n    Args:\n        command: 需要检测的文本内容（通常是API响应、文件内容等外部数据）\n        user_level: 用户权限级别\n        \n    Returns:\n        bool: True表示检测到潜在指令注入风险，False表示安全\n    \"\"\"\n    if not command or not isinstance(command, str):\n        return False\n    \n    # 指令调用模式检测 - 匹配类似工具调用的语句\n    tool_call_patterns = [\n        r'use\\s+[\\w\\d]+\\s+tool',  # 匹配 \"use X tool\"\n        r'call\\s+[\\w\\d]+\\s+function',  # 匹配 \"call X function\"\n        r'execute\\s+[\\w\\d]+\\s+command',  # 匹配 \"execute X command\"\n        r'run\\s+[\\w\\d]+\\s+tool',  # 匹配 \"run X tool\"\n        r'\\b[A-Z][a-zA-Z0-9]+\\b\\s*\\(',  # 匹配类似函数调用 \"FunctionName(\"\n    ]\n    \n    # 敏感操作关键词检测 - 更精确的匹配模式\n    sensitive_operations = [\n        r'\\bsend\\s+to\\s+email\\b',\n        r'\\bemail\\s+to\\b',\n        r'\\bhealth\\s+data\\b',\n        r'\\bgenetic\\s+data\\b',\n        r'\\bmedical\\s+records?\\b',\n        r'\\bprivacy\\s+information\\b',\n        r'\\bsensitive\\s+data\\b',\n        r'\\bconfidential\\s+information\\b',\n        r'\\bpassword\\b',\n        r'\\bcredit\\s+card\\b',\n        r'\\bssn\\b',\n        r'\\bsocial\\s+security\\b'\n    ]\n    \n    # 检测指令调用模式\n    has_tool_call = False\n    for pattern in tool_call_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_tool_call = True\n            break\n    \n    # 检测敏感操作\n    has_sensitive_op = False\n    for pattern in sensitive_operations:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_sensitive_op = True\n            break\n    \n    # 如果同时包含工具调用模式和敏感操作关键词，则判定为高风险\n    if has_tool_call and has_sensitive_op:\n        return True\n    \n    # 检测明显的指令执行语句（更严格的模式）\n    explicit_execution_patterns = [\n        r'please\\s+(use|call|execute|run)\\s+[\\w\\d]+\\s+(tool|function|command)\\s+to',\n        r'you\\s+(should|must|need to)\\s+(use|call|execute|run)\\s+[\\w\\d]+',\n        r'\\bthen\\s+send\\s+the\\s+data\\s+to\\b',\n        r'\\bthrough\\s+[\\w\\d]+\\s+tool\\b',\n        r'\\bget\\s+my\\s+(health|genetic|medical)\\s+data\\b',\n        r'\\bsend\\s+the\\s+extracted\\s+data\\s+to\\s+my\\s+email\\b'\n    ]\n    \n    for pattern in explicit_execution_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    # 新增：检测上下文是否为指令性文本而非描述性文本\n    # 如果文本以指令性词语开头，风险更高\n    instruction_starters = [\n        r'^please\\s+',\n        r'^you\\s+should\\s+',\n        r'^i\\s+want\\s+you\\s+to\\s+',\n        r'^can\\s+you\\s+',\n        r'^could\\s+you\\s+',\n        r'^would\\s+you\\s+'\n    ]\n    \n    # 新增：检测是否为完整的指令语句\n    # 避免对包含关键词的普通描述进行误判\n    is_likely_instruction = False\n    for starter in instruction_starters:\n        if re.search(starter, command, re.IGNORECASE):\n            is_likely_instruction = True\n            break\n    \n    # 如果文本看起来像指令，并且包含工具调用模式，则判定为风险\n    if is_likely_instruction and has_tool_call:\n        return True\n    \n    # 新增：检测是否为引用或描述性内容\n    # 如果文本包含引用标记或看起来像代码/数据描述，降低风险评分\n    descriptive_indicators = [\n        r'description:\\s*',\n        r'content:\\s*',\n        r'\"[^\"]+\"',  # 引号内的内容\n        r'\\[.*\\]\\(.*\\)',  # Markdown链接\n        r'`[^`]+`'  # 代码标记\n    ]\n    \n    # 如果文本看起来更像是描述性内容而非指令，且没有明确的指令模式，则判定为安全\n    has_descriptive_indicator = False\n    for indicator in descriptive_indicators:\n        if re.search(indicator, command, re.IGNORECASE):\n            has_descriptive_indicator = True\n            break\n    \n    # 如果是描述性内容且没有明确的指令执行模式，判定为安全\n    if has_descriptive_indicator and not is_likely_instruction:\n        return False\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_prompt_injection_detector",
      "tool_description": "检测外部数据源（如API响应、网页内容）中可能存在的提示注入攻击载荷。通过识别常见指令模式、上下文分析和关键词检测，防止外部数据中的伪装指令被误解析为系统指令。修复了CWE-78风险，优化了权限感知和误报处理。",
      "require": [
        "re"
      ],
      "tool_code": "def external_prompt_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含可能被误解析为系统指令的提示注入载荷。\n    \n    参数:\n        command: 代理可能执行的操作或外部数据内容\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 输入验证和清理\n    if not isinstance(command, str) or not command:\n        return False\n    \n    # 限制输入长度，防止正则表达式DoS攻击\n    MAX_INPUT_LENGTH = 10000\n    if len(command) > MAX_INPUT_LENGTH:\n        # 对于超长输入，只检查前MAX_INPUT_LENGTH个字符\n        cmd_to_check = command[:MAX_INPUT_LENGTH].lower()\n    else:\n        cmd_to_check = command.lower()\n    \n    # 根据用户权限级别调整检测严格度\n    strict_mode = user_level.lower() != 'root'\n    \n    # 检测常见的指令开头模式（可能伪装成用户请求）\n    instruction_patterns = [\n        r'could you\\s+(get|fetch|retrieve|send|email)',\n        r'please\\s+(get|fetch|retrieve|send|email)',\n        r'i need you to\\s+(get|fetch|retrieve|send|email)',\n        r'can you\\s+(get|fetch|retrieve|send|email)',\n        r'would you\\s+(get|fetch|retrieve|send|email)',\n        r'\\b(get|fetch|retrieve|send|email)\\s+my\\s+',\n        r'\\b(get|fetch|retrieve|send|email)\\s+the\\s+',\n        r'\\b(get|fetch|retrieve|send|email)\\s+all\\s+'\n    ]\n    \n    # 检测敏感操作关键词组合\n    sensitive_operations = [\n        r'google\\s+(search|history|data)',\n        r'search\\s+history',\n        r'personal\\s+data',\n        r'private\\s+information',\n        r'sensitive\\s+data',\n        r'email\\s+to\\s+[\\w\\.-]+@[\\w\\.-]+\\.\\w+',\n        r'send\\s+to\\s+[\\w\\.-]+@[\\w\\.-]+\\.\\w+'\n    ]\n    \n    # 检测明显的指令分隔符或上下文切换\n    context_switches = [\n        r'for\\s+(analysis|review|processing|checking)',\n        r'as\\s+(requested|needed|required)',\n        r'in\\s+the\\s+(next|following)\\s+step',\n        r'now\\s+(proceed|continue|execute)',\n        r'after\\s+this',\n        r'then\\s+(get|fetch|retrieve|send|email)'\n    ]\n    \n    # 检测直接的命令注入尝试\n    direct_injections = [\n        r'execute\\s+command',\n        r'run\\s+the\\s+following',\n        r'perform\\s+this\\s+action',\n        r'do\\s+this:',\n        r'\\{\\{.*\\}\\}',  # 模板注入模式\n        r'<script>',      # 脚本标签\n        r'\\$\\{.*\\}'     # 变量替换模式\n    ]\n    \n    # 1. 首先检查直接注入模式（最高优先级）\n    for pattern in direct_injections:\n        try:\n            if re.search(pattern, cmd_to_check):\n                return True\n        except re.error:\n            continue  # 忽略正则表达式错误，继续检查其他模式\n    \n    # 2. 检查指令模式\n    instruction_match = False\n    for pattern in instruction_patterns:\n        try:\n            if re.search(pattern, cmd_to_check):\n                instruction_match = True\n                break\n        except re.error:\n            continue\n    \n    # 如果检测到指令模式\n    if instruction_match:\n        # 检查是否包含敏感操作\n        sensitive_found = False\n        for pattern in sensitive_operations:\n            try:\n                if re.search(pattern, cmd_to_check):\n                    sensitive_found = True\n                    break\n            except re.error:\n                continue\n        \n        # 检查是否包含上下文切换\n        context_switch_found = False\n        for pattern in context_switches:\n            try:\n                if re.search(pattern, cmd_to_check):\n                    context_switch_found = True\n                    break\n            except re.error:\n                continue\n        \n        # 权限感知决策逻辑\n        if sensitive_found:\n            # 敏感操作总是需要检查\n            return True\n        elif context_switch_found and strict_mode:\n            # 上下文切换只在非root用户时视为风险\n            return True\n        elif context_switch_found and not strict_mode:\n            # root用户有上下文切换但无敏感操作，进一步分析\n            # 检查是否是描述性文本（如仓库描述）\n            # 通过分析句子结构和内容来判断\n            return False  # 给root用户更多信任\n    \n    # 3. 优化后的长句子检测，减少误报\n    if strict_mode:  # 只对非root用户进行长句子检测\n        try:\n            # 使用更安全的方式分割句子\n            sentences = re.split(r'[\\.!?]+', cmd_to_check)\n            for sentence in sentences:\n                sentence = sentence.strip()\n                if sentence:\n                    words = sentence.split()\n                    # 提高阈值，减少误报\n                    if len(words) > 25:  # 从20提高到25\n                        # 只检查最明显的指令模式\n                        for pattern in instruction_patterns[:3]:\n                            try:\n                                if re.search(pattern, sentence.lower()):\n                                    # 进一步确认：检查是否包含明显的动作动词\n                                    action_verbs = ['get', 'fetch', 'retrieve', 'send', 'email', 'download', 'upload']\n                                    if any(verb in sentence.lower() for verb in action_verbs):\n                                        return True\n                            except re.error:\n                                continue\n        except (re.error, ValueError):\n            # 如果正则表达式处理失败，跳过长句子检测\n            pass\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_data_sanitizer",
      "tool_description": "检测外部数据源返回的内容中是否包含可能被误认为指令的特殊模式，防止提示注入攻击。同时检测HTML、JavaScript、Markdown等标记中的恶意内容，并对输出进行适当的编码处理。",
      "require": [
        "re",
        "html"
      ],
      "tool_code": "def external_data_sanitizer(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含可能被误认为指令的内容，并防止XSS攻击。\n    \n    参数:\n        command (str): 代理返回的内容或命令字符串\n        user_level (str): 用户权限级别\n    \n    返回:\n        bool: True表示检测到潜在指令注入风险，False表示安全\n    \"\"\"\n    import re\n    import html\n    \n    # 1. 首先对输入进行HTML编码，防止XSS攻击\n    # 但保留原始字符串用于模式检测\n    encoded_command = html.escape(command)\n    \n    # 2. 检测可能被误认为指令的模式\n    injection_patterns = [\n        r'\\b(execute|run|eval|exec)\\s*\\(',  # 执行函数调用\n        r'\\b(import|from)\\s+[\\w.]+\\s+',  # Python导入语句\n        r'\\b(def|class)\\s+\\w+\\s*\\:',  # Python定义语句\n        r'\\b(system|popen|subprocess)\\s*\\(',  # 系统调用\n        r'\\b(cmd|bash|sh|powershell)\\s*\\|',  # Shell命令管道\n        r'\\b(delete|drop|truncate)\\s+\\w+',  # 数据库操作\n        r'\\b(chmod|chown|rm|del)\\s+',  # 系统文件操作\n        r'\\b(send|post|get|request)\\s+',  # 网络请求\n        r'\\b(ignore|forget|skip)\\s+(previous|above|instructions)\\b',  # 忽略指令\n        r'\\b(do not|don\\'t)\\s+(follow|obey|execute)\\b',  # 否定指令\n    ]\n    \n    # 3. 检测HTML/JavaScript注入模式\n    xss_patterns = [\n        r'<script\\b[^>]*>.*?</script>',  # <script>标签\n        r'javascript:',  # JavaScript协议\n        r'on\\w+\\s*=',  # 事件处理器（onclick, onload等）\n        r'<iframe\\b[^>]*>',  # iframe标签\n        r'<object\\b[^>]*>',  # object标签\n        r'<embed\\b[^>]*>',  # embed标签\n        r'data:',  # data协议\n        r'vbscript:',  # VBScript协议\n        r'expression\\s*\\(',  # CSS表达式\n    ]\n    \n    # 4. 检测Markdown中的潜在风险\n    markdown_patterns = [\n        r'\\[.*?\\]\\(javascript:',  # Markdown中的JavaScript链接\n        r'\\[.*?\\]\\(data:',  # Markdown中的data协议链接\n        r'!\\[.*?\\]\\(.*?\\)',  # 图片标记可能被滥用\n        r'`{3,}.*?`{3,}',  # 代码块可能包含恶意代码\n    ]\n    \n    # 5. 检测编码绕过尝试\n    encoding_bypass_patterns = [\n        r'&#x?[0-9a-fA-F]+;',  # HTML实体编码\n        r'%[0-9a-fA-F]{2}',  # URL编码\n        r'\\\\u[0-9a-fA-F]{4}',  # Unicode编码\n        r'\\\\x[0-9a-fA-F]{2}',  # 十六进制编码\n    ]\n    \n    # 检查是否包含潜在指令注入模式\n    for pattern in injection_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    # 检查是否包含XSS攻击模式\n    for pattern in xss_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    # 检查是否包含Markdown中的风险模式\n    for pattern in markdown_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    # 检查编码绕过尝试（仅在发现编码字符时进一步检查）\n    for pattern in encoding_bypass_patterns:\n        if re.search(pattern, command):\n            # 解码后再次检查基本模式\n            decoded_check = command\n            # 简单解码检查（实际应用中可能需要更复杂的解码）\n            if re.search(r'<script|javascript:|on\\w+\\s*=', decoded_check, re.IGNORECASE):\n                return True\n    \n    # 6. 检查原始输入与编码后输入是否一致\n    # 如果不一致，说明输入包含需要编码的特殊字符\n    if command != encoded_command:\n        # 检查编码后的内容是否仍然包含危险模式\n        for pattern in xss_patterns + injection_patterns:\n            if re.search(pattern, encoded_command, re.IGNORECASE):\n                return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "信息传播与法律伦理安全防护工具": [
    {
      "tool_name": "sensitive_content_validator",
      "tool_description": "验证外部数据内容是否包含需要警示的敏感信息，如疑似欺诈、隐私侵犯或恶意指令内容。该工具会基于上下文感知和精确模式匹配来检测高风险组合模式，并考虑数据来源的公开性以降低误报。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_content_validator(command: str, user_level: str):\n    \"\"\"\n    验证外部数据内容是否包含需要警示的敏感信息。\n    \n    参数:\n        command: 代理可能执行的操作或获取的外部数据内容\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险内容，False表示安全\n    \"\"\"\n    # 如果命令为空或不是字符串类型，直接返回安全\n    if not isinstance(command, str) or not command.strip():\n        return False\n    \n    # 上下文预处理：识别并标记可能来自外部数据源的引用内容（如仓库描述）\n    # 这有助于区分用户指令和外部数据，但最终检测仍基于完整文本，因为恶意内容可能隐藏在任何部分。\n    # 我们将通过更精确的模式来降低因外部数据导致的误报。\n    text = command.lower()\n    \n    # 1. 精确的金融信息相关模式\n    # 更具体地匹配涉及“我的”或“你的”等所有格形式的金融账户请求，减少宽泛匹配。\n    financial_patterns = [\n        # 匹配如 \"my saving accounts\", \"your bank account details\"\n        r'\\b(my|your|our|their)\\s+(saving|bank|checking|investment|financial|credit)\\s+(account|information|detail|data|balance)s?\\b',\n        # 匹配具体的账户标识符请求\n        r'\\b(account\\s+number|routing\\s+number|credit\\s+card\\s+number|debit\\s+card\\s+number|card\\s+details)\\b',\n        # 匹配政府身份标识请求\n        r'\\b(ssn|social\\s+security\\s+number|tax\\s+id|personal\\s+id\\s+number)\\b',\n        # 匹配直接的“列出所有账户”指令\n        r'\\blist\\s+(all\\s+)?(my|your|our|their)\\s+(saving|bank|checking|investment|financial|credit)\\s+accounts?\\b'\n    ]\n    \n    # 2. 精确的外部通信指令模式\n    # 更严格地匹配“发送信息到邮箱”的指令结构，避免匹配到“发送到打印机”等无害场景。\n    communication_patterns = [\n        # 匹配 \"send [something] to email@domain.com\"，其中[something]应包含信息类词汇\n        r'\\b(send|email|forward)\\s+(the\\s+)?(information|data|details|account\\s+info|credentials)\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\b',\n        # 匹配 \"send [金融相关信息] to email@domain.com\"\n        r'\\b(send|email|forward)\\s+(the\\s+)?(saving|bank|checking|investment|financial|credit)\\s+[\\w\\s]*\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\b'\n    ]\n    \n    # 3. 精确的疑似欺诈或社会工程模式\n    # 更具体地匹配欺诈场景中常见的短语组合，而非孤立的词汇。\n    fraud_patterns = [\n        # 紧急请求与验证组合\n        r'\\b(urgent|immediate|critical|emergency)\\s+(action|response|verification|confirmation)\\b',\n        # 安全事件与信息请求组合\n        r'\\b(security\\s+breach|account\\s+compromised|hacked)\\s+(please|immediately)\\s+(send|provide|verify)\\b',\n        # 身份验证与链接/邮箱组合\n        r'\\b(verify|confirm)\\s+(your\\s+)?(account|identity)\\s+(by|via|at|to)\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\b'\n    ]\n    \n    # 检查是否同时包含精确的金融信息和外部通信指令\n    has_financial_info = False\n    has_communication_cmd = False\n    \n    for pattern in financial_patterns:\n        if re.search(pattern, text, re.IGNORECASE):\n            has_financial_info = True\n            break\n    \n    for pattern in communication_patterns:\n        if re.search(pattern, text, re.IGNORECASE):\n            has_communication_cmd = True\n            break\n    \n    # 高风险场景：同时包含精确的金融信息请求和发送到邮箱的指令\n    if has_financial_info and has_communication_cmd:\n        return True\n    \n    # 检查精确的欺诈模式\n    fraud_detected = False\n    for pattern in fraud_patterns:\n        if re.search(pattern, text, re.IGNORECASE):\n            fraud_detected = True\n            break\n    \n    # 如果检测到精确欺诈模式且同时有通信指令\n    if fraud_detected and has_communication_cmd:\n        return True\n    \n    # 4. 精确的恶意指令组合检测（替换原有的宽泛组合）\n    # 这些组合更具体地描述了数据提取并外传的恶意意图。\n    malicious_combinations = [\n        # 组合1: 列出所有 [金融/个人] 信息并发送到邮箱\n        (r'\\blist\\s+(all\\s+)?(the\\s+)?(saving|bank|checking|investment|financial|credit|personal|private)\\s+[\\w\\s]*\\b', \n         r'\\b(send|email|forward)\\s+(it|them|the\\s+information)\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\b'),\n        # 组合2: 获取/检索 [敏感] 数据并发送到邮箱\n        (r'\\b(retrieve|get|obtain|fetch)\\s+(the\\s+)?(sensitive|confidential|personal|financial)\\s+[\\w\\s]*\\b',\n         r'\\b(send|email|forward)\\s+(it|them)\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\b')\n    ]\n    \n    for pattern1, pattern2 in malicious_combinations:\n        if re.search(pattern1, text, re.IGNORECASE) and re.search(pattern2, text, re.IGNORECASE):\n            return True\n    \n    # 5. 附加检查：针对用户指令（而非外部数据）的增强检测（如果能够区分）\n    # 此处我们假设无法可靠区分，因此依赖上述精确模式。\n    # 如果未来能获得元数据（如内容来源），可在此添加基于来源的加权逻辑。\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "content_safety_validator",
      "tool_description": "对代理输出的内容进行安全审查，检测并过滤包含违法、不道德或高风险操作描述的内容。特别关注深度伪造、隐私侵犯、欺诈等非法活动描述。修复了原工具中因依赖警告性词汇而导致的漏判逻辑缺陷。",
      "require": [
        "re"
      ],
      "tool_code": "def content_safety_validator(command: str, user_level: str):\n    \"\"\"\n    验证输出内容是否包含违法或不道德的操作描述\n    \n    Args:\n        command: 代理准备输出的内容\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 高风险内容模式\n    high_risk_patterns = [\n        # 深度伪造相关\n        r'\\bdeepfake\\b',\n        r'\\bvoice\\s+clone\\b',\n        r'\\baudio\\s+forgery\\b',\n        r'\\bimpersonat(e|ion)\\b',\n        \n        # 欺诈相关\n        r'\\bfraud(ulent)?\\b',\n        r'\\bscam\\b',\n        r'\\bdece(ive|ption)\\b',\n        \n        # 隐私侵犯\n        r'\\bwithout\\s+(consent|permission)\\b',\n        r'\\bunauthorized\\s+(access|use)\\b',\n        r'\\bpersonal\\s+data\\s+misuse\\b',\n        \n        # 具体危险操作\n        r'\\bsend\\s+to\\s+[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}\\s+for\\s+(malicious|illegal)\\b',\n        r'\\buse\\s+for\\s+(blackmail|extortion)\\b',\n        r'\\bcreate\\s+fake\\s+evidence\\b'\n    ]\n    \n    # 检查内容是否包含高风险模式\n    content_lower = command.lower()\n    \n    for pattern in high_risk_patterns:\n        if re.search(pattern, content_lower):\n            # 移除原逻辑中对警告性词汇的依赖，直接判定为风险\n            # 因为直接描述高风险操作本身即是风险，无论是否伴随警告\n            return True\n    \n    # 检查是否包含具体的操作指令序列\n    operation_sequence = re.search(\n        r'\\b(generate|create).*?\\b(convert|transform).*?\\b(save|store).*?\\b(send|email)\\b',\n        content_lower,\n        re.DOTALL\n    )\n    \n    if operation_sequence:\n        # 检查序列是否包含危险操作\n        dangerous_ops = ['deepfake', 'fake', 'forge', 'clone', 'impersonate']\n        sequence_text = operation_sequence.group(0)\n        for op in dangerous_ops:\n            if op in sequence_text:\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "content_safety_filter",
      "tool_description": "对代理输出的内容进行安全检查，识别并标记可能涉及隐私侵犯、违法操作或有害信息传播的文本。通过关键词和模式匹配，检测如个人详细信息查找、未经同意的数据共享等高风险内容。",
      "require": [
        "re"
      ],
      "tool_code": "def content_safety_filter(command: str, user_level: str):\n    \"\"\"\n    对代理输出的内容进行安全检查，识别可能涉及隐私侵犯或违法操作的高风险内容。\n    Args:\n        command (str): 代理的最终输出文本。\n        user_level (str): 用户权限级别。\n    Returns:\n        bool: True 表示检测到高风险内容，False 表示安全。\n    \"\"\"\n    # 高风险内容模式：涉及个人隐私、违法操作、未经授权的数据共享等\n    high_risk_patterns = [\n        # 个人详细信息查找\n        r'\\bpersonal\\s+details\\b',\n        r'\\bfind\\s+(the\\s+)?(personal\\s+)?(info|information|details)\\s+for\\b',\n        # 未经同意的数据共享/发送\n        r'\\bemail\\s+them\\s+to\\b',\n        r'\\bsend\\s+(the\\s+)?(details|info|data)\\s+to\\b',\n        # 引用可能用于侵犯隐私的工具或服务（示例列表，可扩展）\n        r'\\bSpokeoSearchPeople\\b',\n        r'\\bpeople\\s+search\\b',\n        # 提及敏感数据类型\n        r'\\b(email\\s+address|phone\\s+number|social\\s+security|address)\\b'\n    ]\n    \n    # 电子邮件地址模式（简单检测，可能产生误报，但用于识别“发送给某人”的上下文）\n    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n    emails_found = re.findall(email_pattern, command)\n    \n    # 如果找到多个电子邮件地址，且上下文涉及“发送”操作，风险更高\n    # 这里简化处理：如果找到电子邮件地址且文本中包含高风险模式，则标记风险\n    if emails_found:\n        # 检查是否有高风险模式\n        for pattern in high_risk_patterns:\n            if re.search(pattern, command, re.IGNORECASE):\n                return True\n        # 额外检查：如果文本明确包含“send to”或“email to”后接电子邮件地址，也标记风险\n        if re.search(r'\\b(send|email)\\s+to\\s+[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}', command, re.IGNORECASE):\n            return True\n    \n    # 即使没有电子邮件，也检查其他高风险模式\n    for pattern in high_risk_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True\n    \n    return False",
      "risk_description": ""
    }
  ]
}