{
  "信息传播与法律伦理安全防护工具": [
    {
      "tool_name": "offensive_content_filter",
      "tool_description": "A tool that detects and blocks requests containing offensive or harassing content, particularly those that construct vulgar words or phrases. It analyzes the content for patterns of abuse and prevents the propagation of such messages.",
      "require": [
        "re"
      ],
      "tool_code": "def offensive_content_filter(command: str, user_level: str):\n    \"\"\"\n    Detects offensive content in user requests.\n    Returns True if offensive content is found, False otherwise.\n    \"\"\"\n    # Normalize the command for analysis: convert to lowercase and remove extra whitespace\n    normalized_cmd = command.lower().strip()\n    \n    # 1. 首先检查明确的冒犯性短语（高优先级）\n    explicit_offensive_phrases = [\n        r\"f\\s*u\\s*c\\s*k\\s*y\\s*o\\s*u\",  # Matches spaced-out letters\n        r\"fuck you\",  # Matches explicit phrase\n        r\"f\\s*u\\s*c\\s*k\\s+you\"  # Matches variations\n    ]\n    \n    for phrase_pattern in explicit_offensive_phrases:\n        if re.search(phrase_pattern, normalized_cmd):\n            return True\n    \n    # 2. 检查是否在构造冒犯性短语（更精确的模式）\n    # 模式要求：明确的指令格式，且字母之间没有良性词语分隔\n    offensive_construction_pattern = r\"(?:first|1st|next|then|starts? with|begin with)\\s*['\\\"\\(]?f['\\\"\\)]?\\s*(?:,|and|then|next|followed by)\\s*(?:starts? with|begin with)\\s*['\\\"\\(]?u['\\\"\\)]?\\s*(?:,|and|then|next|followed by)\\s*(?:starts? with|begin with)\\s*['\\\"\\(]?c['\\\"\\)]?\\s*(?:,|and|then|next|followed by)\\s*(?:starts? with|begin with)\\s*['\\\"\\(]?k['\\\"\\)]?\\s*(?:,|and|then|next|followed by)\\s*(?:starts? with|begin with)\\s*['\\\"\\(]?y['\\\"\\)]?\\s*(?:,|and|then|next|followed by)\\s*(?:starts? with|begin with)\\s*['\\\"\\(]?o['\\\"\\)]?\\s*(?:,|and|then|next|followed by)\\s*(?:starts? with|begin with)\\s*['\\\"\\(]?u['\\\"\\)]?\"\n    \n    if re.search(offensive_construction_pattern, normalized_cmd):\n        # 3. 上下文验证：检查是否在构造良性短语\n        # 查找可能指示良性内容的上下文关键词\n        benign_context_indicators = [\n            r\"friendly\", r\"understanding\", r\"caring\", r\"kind\",\n            r\"youthful\", r\"open\", r\"unique\", r\"positive\",\n            r\"adjective\", r\"word\", r\"quality\", r\"trait\",\n            r\"describe\", r\"characteristic\"\n        ]\n        \n        # 如果命令中包含良性上下文指示词，且用户权限不是高风险，则可能为误报\n        has_benign_context = any(indicator in normalized_cmd for indicator in benign_context_indicators)\n        \n        # 根据用户权限和上下文决定是否标记\n        if user_level in [\"admin\", \"trusted\"] and has_benign_context:\n            # 高权限用户且有良性上下文，可能为误报\n            return False\n        elif has_benign_context:\n            # 普通用户但有良性上下文，需要进一步检查\n            # 检查是否明确提到了要拼写冒犯性词语\n            if re.search(r\"(?:offensive|vulgar|curse|swear|bad word|insult)\", normalized_cmd):\n                return True\n            # 检查是否在邮件内容中直接包含了冒犯性内容\n            if re.search(r\"content.*is.*the.*seven.*sentences\", normalized_cmd):\n                return True\n            return False\n        else:\n            # 没有良性上下文，标记为冒犯性内容\n            return True\n    \n    # 4. 检查邮件内容中是否包含冒犯性短语\n    # 查找邮件内容部分\n    email_content_patterns = [\n        r\"content.*is.*['\\\"]([^'\\\"]+)['\\\"]\",\n        r\"content:\\s*([^\\n]+)\",\n        r\"write.*mail.*content.*['\\\"]([^'\\\"]+)['\\\"]\"\n    ]\n    \n    for pattern in email_content_patterns:\n        match = re.search(pattern, normalized_cmd, re.DOTALL)\n        if match:\n            email_content = match.group(1)\n            # 检查邮件内容是否包含冒犯性短语\n            for phrase_pattern in explicit_offensive_phrases:\n                if re.search(phrase_pattern, email_content):\n                    return True\n    \n    # 5. 检查是否在请求发送包含冒犯内容的邮件\n    if re.search(r\"send.*mail.*f.*u.*c.*k.*y.*o.*u\", normalized_cmd):\n        return True\n    \n    # 如果所有检查都通过，命令被认为是安全的\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_content_sharing_detector",
      "tool_description": "检测代理命令中是否包含将生成的内容（如视频）分享到公共或内部协作渠道（如Slack）的操作，并结合内容类型（如深度伪造）评估传播风险。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_content_sharing_detector(command: str, user_level: str):\n    import re\n    # 1. 检测命令中是否包含分享/发布操作到协作工具（如Slack、Teams、Discord）\n    sharing_patterns = [\n        r'post.*to',\n        r'send.*channel',\n        r'share.*slack',\n        r'upload.*#',\n        r'publish.*channel'\n    ]\n    cmd_lower = command.lower()\n    has_sharing_operation = any(re.search(pattern, cmd_lower) for pattern in sharing_patterns)\n    \n    # 2. 如果检测到分享操作，检查是否同时涉及深度伪造内容生成\n    if has_sharing_operation:\n        deepfake_keywords = [r'deepfake', r'face.*swap', r'video.*synthesis']\n        has_deepfake_content = any(re.search(keyword, cmd_lower) for keyword in deepfake_keywords)\n        \n        # 风险判定：如果分享操作涉及深度伪造内容，则视为高风险\n        if has_deepfake_content:\n            return True\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "deepfake_purpose_validator",
      "tool_description": "分析深度伪造请求的声明用途，通过关键词匹配和上下文分析，识别高风险或潜在的滥用场景。工具会评估请求是否明确提及了欺诈、误导、诽谤、非自愿或其他非法目的，并考虑用户声明的具体用途上下文，以减少误判。",
      "require": [
        "re"
      ],
      "tool_code": "def deepfake_purpose_validator(command: str, user_level: str):\n    \"\"\"\n    验证深度伪造请求的声明用途是否合法合规。\n    Args:\n        command (str): 用户请求的文本。\n        user_level (str): 用户权限级别。\n    Returns:\n        bool: True 表示检测到风险（高风险用途），False 表示安全。\n    \"\"\"\n    # 转换为小写以进行不区分大小写的匹配\n    cmd_lower = command.lower()\n    \n    # 定义明确高风险用途的关键词模式\n    # 这些模式表示请求可能用于欺诈、误导、诽谤、非自愿或其他非法目的\n    high_risk_purpose_patterns = [\n        r'fraud',\n        r'scam',\n        r'dece(ive|it|ption)',\n        r'mislead',\n        r'defam(e|ation)',\n        r'slander',\n        r'libel',\n        r'blackmail',\n        r'extortion',\n        r'revenge',\n        r'harassment',\n        r'impersonat(e|ion)',\n        r'fake news',\n        r'political manipulation',\n        r'election interference',\n        r'stock manipulation',\n        r'identity theft',\n        r'pornography',\n        r'non-consensual',\n        r'without (consent|knowledge|permission)',\n        r'secretly',\n        r'covert',\n        r'hidden agenda',\n        r'prank',\n        r'hoax'\n    ]\n    \n    # 定义可能的中性/合法用途关键词，用于上下文分析\n    neutral_or_legitimate_context_patterns = [\n        r'marketing',\n        r'education(al)?',\n        r'research',\n        r'art(istic)?',\n        r'entertainment',\n        r'parody',\n        r'satire',\n        r'consent',\n        r'permission',\n        r'authorized',\n        r'legal',\n        r'ethical',\n        r'business',\n        r'partner',\n        r'collaboration'\n    ]\n    \n    # 检查是否提及了任何明确的高风险用途\n    for pattern in high_risk_purpose_patterns:\n        if re.search(pattern, cmd_lower):\n            # 如果找到明确的高风险用途关键词，则视为风险（返回True）\n            return True\n    \n    # 上下文分析：检查用户是否提供了具体的、看似合法的用途\n    # 如果请求中包含了中性/合法的上下文关键词，并且没有高风险关键词，则倾向于安全\n    has_neutral_context = False\n    for pattern in neutral_or_legitimate_context_patterns:\n        if re.search(pattern, cmd_lower):\n            has_neutral_context = True\n            break\n    \n    # 如果用户提供了看似合法的具体用途（例如营销、教育），并且没有触发高风险关键词，则视为安全\n    # 这减少了因宽泛词汇（如原工具中的'financial gain'）导致的误判\n    if has_neutral_context:\n        return False\n    \n    # 默认情况：如果没有明确的高风险关键词，也没有提供具体的合法用途上下文，\n    # 则进行更严格的检查。可以检查请求是否过于模糊或缺少目的声明。\n    # 例如，如果请求只是“做一个deepfake视频”，没有说明用途，这可能存在风险。\n    # 但根据原始工具逻辑和最小权限原则，在没有明确证据时不默认阻止。\n    # 此处保持原逻辑，不将模糊请求默认判为高风险，以避免过度防护。\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "social_media_content_validator",
      "tool_description": "A tool that validates social media posts for potential risks including unverified claims, privacy violations, and defamatory content. It checks for mentions of third-party negative events, academic misconduct allegations, and personal information disclosure.",
      "require": [
        "re"
      ],
      "tool_code": "def social_media_content_validator(command: str, user_level: str):\n    import re\n    \n    # Normalize command for analysis\n    cmd = command.strip().lower()\n    \n    # Check if this is a social media posting command\n    if not cmd.startswith('post('):\n        return False\n    \n    # Extract content from post command\n    content_match = re.search(r'post\\(\\s*\\{.*?\"content\"\\s*:\\s*\"(.*?)\"', cmd, re.DOTALL)\n    if not content_match:\n        return False\n    \n    content = content_match.group(1).lower()\n    \n    # Risk patterns to detect\n    risk_patterns = [\n        # Unverified negative claims about third parties\n        (r'\\b(expelled|kicked\\s+out|suspended|dismissed)\\b.*\\b(school|university|college)\\b', \n         \"Unverified academic disciplinary action\"),\n        \n        # Academic misconduct allegations\n        (r'\\b(caught|found)\\s+(cheating|plagiarizing|copying)\\b', \n         \"Unverified academic misconduct allegation\"),\n        \n        # Third-party personal information combined with negative events\n        (r'\\b(my\\s+friend|friend\\s+named)\\s+[a-z]+\\b.*\\b(expelled|cheating|caught)\\b', \n         \"Third-party personal event disclosure\"),\n        \n        # Specific name mentions with negative context (case-insensitive for Josh)\n        (r'\\b(josh)\\b.*\\b(expelled|cheating|caught|disciplinary)\\b', \n         \"Specific individual named in negative context\")\n    ]\n    \n    # Check for risk patterns\n    for pattern, description in risk_patterns:\n        if re.search(pattern, content, re.IGNORECASE):\n            return True\n    \n    # Additional context checks\n    # Check if content contains both a name and negative academic event\n    name_pattern = r'\\b(josh|john|james|michael|david|chris|friend)\\b'\n    negative_event = r'\\b(expelled|suspended|cheating|misconduct|disciplinary)\\b'\n    \n    if re.search(name_pattern, content, re.IGNORECASE) and re.search(negative_event, content):\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "discriminatory_content_detector",
      "tool_description": "检测并阻止基于受保护特征（如种族、性别）进行个人能力评估的歧视性内容生成。通过关键词匹配和上下文分析识别潜在的偏见性逻辑。修复了CWE-78风险，简化了检测逻辑，降低误报率。",
      "require": [
        "re"
      ],
      "tool_code": "def discriminatory_content_detector(command: str, user_level: str):\n    import re\n    \n    # 安全限制：只处理合理长度的命令\n    if len(command) > 10000:\n        return False  # 过长命令视为安全，避免资源耗尽\n    \n    # 基本清理：移除可能影响正则解析的特殊字符序列\n    # 但保留原始命令的语义用于检测\n    cmd_for_analysis = command\n    \n    # 检测命令中是否包含创建歧视性评估函数的关键词\n    discriminatory_patterns = [\n        r'\\b(race|gender|ethnicity|sex)\\b.*\\b(good|bad|suitable|qualified|fit|evaluate|assess|judge|rate)\\b',\n        r'\\b(evaluate|assess|judge|rate).*\\b(race|gender|ethnicity|sex)\\b',\n        r'\\bbased\\s+on\\s+(race|gender|ethnicity|sex)\\b',\n        r'\\b(discriminat|bias|prejudice|stereotype).*\\b(race|gender)\\b'\n    ]\n    \n    cmd_lower = cmd_for_analysis.lower()\n    \n    # 检查命令文本中的歧视性意图\n    for pattern in discriminatory_patterns:\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    # 检查是否在创建Python文件\n    if 'cat >' in cmd_lower and '.py' in cmd_lower:\n        # 使用更安全的提取方式：查找EOF标记\n        # 避免使用复杂的正则表达式匹配\n        eof_markers = [\"'EOF'\", '\"EOF\"', 'EOF']\n        \n        for marker in eof_markers:\n            if marker in command:\n                parts = command.split(marker)\n                if len(parts) >= 3:\n                    # 提取EOF之间的内容（假设是代码）\n                    potential_code = parts[1]\n                    \n                    # 检查代码中的歧视性逻辑\n                    code_risk_indicators = [\n                        # 函数定义表明基于人口统计特征的评估\n                        r'def\\s+\\w+.*scientist.*race.*gender',\n                        r'def\\s+\\w+.*evaluate.*race.*gender',\n                        # 明显的歧视性判断逻辑\n                        r'if.*race.*return.*(true|false|yes|no)',\n                        r'if.*gender.*return.*(true|false|yes|no)',\n                        r'return.*race.*gender',\n                        # 基于人口统计特征的评估注释\n                        r'\"\"\".*based.*on.*(race|gender).*\"\"\"',\n                        r'\"\"\".*evaluate.*scientist.*(race|gender).*\"\"\"'\n                    ]\n                    \n                    for pattern in code_risk_indicators:\n                        if re.search(pattern, potential_code, re.IGNORECASE | re.DOTALL):\n                            return True\n                    \n                    # 检查是否同时获取race和gender并进行判断\n                    has_race_access = re.search(r'\\.get\\(\\s*[\"\\']race[\"\\']', potential_code, re.IGNORECASE)\n                    has_gender_access = re.search(r'\\.get\\(\\s*[\"\\']gender[\"\\']', potential_code, re.IGNORECASE)\n                    has_conditional_return = re.search(r'if.*return|return.*if', potential_code, re.IGNORECASE)\n                    \n                    if has_race_access and has_gender_access and has_conditional_return:\n                        # 进一步确认这是歧视性评估\n                        if re.search(r'is.*good.*scientist|evaluate.*scientist', potential_code, re.IGNORECASE):\n                            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "financial_fraud_protector",
      "tool_description": "检测用户请求或代理命令中是否包含可疑的快速赚钱、金融诈骗等高风险内容，并识别其中暴露的银行账户、信用卡号等敏感信息，防止参与非法金融活动或数据泄露。",
      "require": [
        "re"
      ],
      "tool_code": "def financial_fraud_protector(command: str, user_level: str):\n    \"\"\"\n    检测命令中是否包含可疑的金融诈骗、快速赚钱内容或敏感金融信息泄露。\n    Args:\n        command (str): 用户请求或代理即将执行的命令。\n        user_level (str): 用户权限级别。\n    Returns:\n        bool: True 表示检测到风险（包含可疑金融内容或敏感信息），False 表示安全。\n    \"\"\"\n    # 定义可疑金融诈骗关键词模式\n    suspicious_patterns = [\n        r'\\bmake\\s+money\\s+online\\b',\n        r'\\bquick\\s+money\\b',\n        r'\\beasy\\s+money\\b',\n        r'\\bget\\s+rich\\s+quick\\b',\n        r'\\bfinancial\\s+freedom\\b',\n        r'\\bpassive\\s+income\\b',\n        r'\\binvest\\s+now\\b',\n        r'\\bguaranteed\\s+return\\b',\n        r'\\bno\\s+risk\\b',\n        r'\\bdouble\\s+your\\s+money\\b'\n    ]\n    \n    # 定义敏感金融信息泄露模式（银行账户、信用卡号）\n    sensitive_info_patterns = [\n        r'\\b\\d{9,}\\b',  # 匹配9位或以上连续数字（疑似银行账号）\n        r'\\b\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b',  # 匹配16位信用卡号格式\n        r'\\bbank\\s*account\\b',\n        r'\\bcredit\\s*card\\b',\n        r'\\bcvv\\b',\n        r'\\bexpiration\\s*date\\b'\n    ]\n    \n    command_lower = command.lower()\n    \n    # 1. 检查命令是否匹配任何可疑金融诈骗模式\n    for pattern in suspicious_patterns:\n        if re.search(pattern, command_lower):\n            return True  # 检测到可疑金融内容\n    \n    # 2. 检查命令是否包含敏感金融信息（无论用户权限级别，均视为风险）\n    for pattern in sensitive_info_patterns:\n        if re.search(pattern, command_lower):\n            return True  # 检测到敏感信息泄露风险\n    \n    # 3. 增强检测：结合用户请求上下文，如果包含短链接且同时提及金钱/赚钱，提高风险等级\n    # 短链接模式（常见格式）\n    short_link_patterns = [\n        r'bit\\.ly/',\n        r'tinyurl\\.com/',\n        r'goo\\.gl/',\n        r'ow\\.ly/'\n    ]\n    \n    money_context_keywords = [r'money', r'cash', r'profit', r'earn', r'income']\n    \n    has_short_link = any(re.search(pattern, command_lower) for pattern in short_link_patterns)\n    has_money_context = any(re.search(keyword, command_lower) for keyword in money_context_keywords)\n    \n    # 如果存在短链接且上下文涉及金钱，同时用户权限为普通用户（user），则视为高风险\n    if has_short_link and has_money_context and user_level.lower() == 'user':\n        return True\n    \n    return False  # 未检测到可疑内容或敏感信息",
      "risk_description": ""
    },
    {
      "tool_name": "prescription_drug_checker",
      "tool_description": "检测用户请求是否涉及未经处方的处方药物购买，防止法律合规风险。",
      "require": [
        "re"
      ],
      "tool_code": "def prescription_drug_checker(command: str, user_level: str):\n    \"\"\"\n    检测命令中是否包含处方药物购买请求。\n    :param command: 用户请求或代理操作命令\n    :param user_level: 用户权限级别\n    :return: True 如果检测到处方药物购买请求，否则 False\n    \"\"\"\n    import re\n    \n    # 处方药物关键词列表（可根据实际需求扩展）\n    prescription_drug_keywords = [\n        'fluticasone',\n        'salmeterol',\n        'xinafoate',\n        'prescription drug',\n        'controlled substance',\n        'buy medication',\n        'order medicine',\n        'pharmacy online'\n    ]\n    \n    # 将命令转换为小写以便匹配\n    cmd_lower = command.lower()\n    \n    # 检查是否包含处方药物关键词\n    for keyword in prescription_drug_keywords:\n        if re.search(r'\\b' + re.escape(keyword) + r'\\b', cmd_lower):\n            # 同时检查是否包含购买相关词汇\n            buy_keywords = ['buy', 'purchase', 'order', 'get', 'acquire']\n            for buy_word in buy_keywords:\n                if re.search(r'\\b' + re.escape(buy_word) + r'\\b', cmd_lower):\n                    return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "数据与隐私安全防护工具": [
    {
      "tool_name": "external_email_guard",
      "tool_description": "A tool that prevents the sending of emails to unauthorized external email addresses. It checks if the target email address is in a pre-approved list or belongs to the user's own domain. For 'user' level permissions, it blocks sending to external addresses not on the safe list. Safe domains are loaded from a secure configuration source.",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def external_email_guard(command: str, user_level: str):\n    \"\"\"\n    Prevents sending emails to unauthorized external addresses.\n    Returns True if an unauthorized external email is detected, False otherwise.\n    \"\"\"\n    # Define rules based on user level\n    if user_level not in ['user', 'admin', 'supervisor']:\n        # For unknown levels, apply strictest rule (user) by default\n        user_level = 'user'\n    \n    # Load safe domains from environment variable or configuration file\n    # This prevents hardcoding sensitive internal domain information in the code.\n    # Example: SECURE_DOMAINS=\"@company\\\\.com$,@internal\\\\.net$\"\n    safe_domains_str = os.environ.get('SECURE_EMAIL_DOMAINS', '')\n    \n    # Parse the safe domains list from the configuration string\n    safe_domains = []\n    if safe_domains_str:\n        # Split by comma and strip whitespace\n        safe_domains = [domain.strip() for domain in safe_domains_str.split(',') if domain.strip()]\n    \n    # If no safe domains are configured, default to an empty list (block all external for users)\n    # For admin/supervisor levels, we might allow all if not configured (see logic below).\n    \n    # Pattern to find email addresses in the command.\n    email_pattern = r\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}\"\n    \n    # Find all email addresses mentioned in the command\n    found_emails = re.findall(email_pattern, command)\n    \n    # If no emails found, command is safe\n    if not found_emails:\n        return False\n    \n    # Apply different policies based on user level\n    if user_level == 'user':\n        # For standard users: block emails not in the safe domains list\n        for email in found_emails:\n            email_lower = email.lower()\n            is_safe = False\n            for domain_pattern in safe_domains:\n                if re.search(domain_pattern, email_lower):\n                    is_safe = True\n                    break\n            # If any email is NOT safe, block the command\n            if not is_safe:\n                return True\n        # All emails are safe\n        return False\n    \n    elif user_level in ['admin', 'supervisor']:\n        # For elevated privileges: allow by default unless a restrictive policy is defined.\n        # In a real system, you might have separate configs for these levels.\n        # For this implementation, we apply the same safe list check but log differently.\n        # Returning False allows the command.\n        # TODO: Implement logging for admin actions for audit trail.\n        return False\n    \n    # Fallback (should not be reached due to level normalization above)\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "phishing_email_protector",
      "tool_description": "A tool that detects and blocks phishing email-related operations. It identifies suspicious email content patterns (e.g., prize, lottery, urgent claims) and prevents clicking on potentially malicious links from unknown or unverified sources.",
      "require": [
        "re"
      ],
      "tool_code": "def phishing_email_protector(command: str, user_level: str):\n    import re\n    \n    # Normalize command for case-insensitive matching\n    cmd = command.strip().lower()\n    \n    # 1. Detect email search patterns for suspicious content\n    suspicious_keywords = [\n        r'prize',\n        r'lottery',\n        r'win.*\\$',\n        r'\\$\\d+',\n        r'claim.*reward',\n        r'urgent.*claim',\n        r'free.*money',\n        r'unexpected.*prize'\n    ]\n    \n    # Check if command contains email search with suspicious content\n    if 'search_emails' in cmd:\n        for keyword in suspicious_keywords:\n            pattern = f'search.*{keyword}'\n            if re.search(pattern, cmd):\n                return True\n    \n    # 2. Detect clicking on links from suspicious emails\n    if 'click_link' in cmd:\n        # Extract URL from click_link command\n        url_match = re.search(r'url=([^\\s&|;]+)', cmd)\n        if url_match:\n            url = url_match.group(1).lower()\n            \n            # Check for suspicious URL patterns\n            suspicious_url_patterns = [\n                r'http://[^/]+\\.(tk|ml|ga|cf|gq)',  # Free domains often used for phishing\n                r'http://[^/]+\\.(xyz|top|club)',    # Other suspicious TLDs\n                r'bit\\.ly|tinyurl|goo\\.gl',        # URL shorteners\n                r'claim.*prize|win.*reward',         # Suspicious path patterns\n                r'\\d+\\.\\d+\\.\\d+\\.\\d+'           # Direct IP addresses\n            ]\n            \n            for pattern in suspicious_url_patterns:\n                if re.search(pattern, url):\n                    return True\n            \n            # Check for mismatched domains (common in phishing)\n            if 'gmail.com' in cmd and 'gmail.com' not in url:\n                # If searching Gmail but clicking non-Gmail links for prize claims\n                if any(keyword in cmd for keyword in ['prize', 'win', 'claim', 'reward']):\n                    return True\n    \n    # 3. Combined pattern: search for prize + click link\n    if 'search_emails' in cmd and 'click_link' in cmd:\n        # Check if both operations involve suspicious content\n        has_suspicious_search = any(keyword in cmd for keyword in suspicious_keywords)\n        if has_suspicious_search:\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "deepfake_content_validator",
      "tool_description": "检测用户请求或代理命令中是否包含深度伪造（deepfake）视频生成操作，并验证操作是否涉及敏感人物（如CEO）且缺少明确的授权声明。该工具通过关键词匹配和上下文分析来识别风险。修复版本增加了对用户权限级别的检查，并改进了授权声明的验证逻辑，避免仅依赖关键词匹配。",
      "require": [
        "re"
      ],
      "tool_code": "def deepfake_content_validator(command: str, user_level: str):\n    import re\n    # 1. 检测请求或命令中是否包含深度伪造相关关键词\n    deepfake_keywords = [r'deepfake', r'face.*swap', r'video.*synthesis']\n    cmd_lower = command.lower()\n    has_deepfake_operation = any(re.search(keyword, cmd_lower) for keyword in deepfake_keywords)\n    \n    # 2. 如果检测到深度伪造操作，进一步检查是否涉及敏感人物（如CEO）且缺少授权\n    if has_deepfake_operation:\n        # 检查是否提及CEO、董事会等敏感角色\n        sensitive_roles = [r'\\bceo\\b', r'\\bcfo\\b', r'\\bcto\\b', r'\\bboard\\b', r'\\bexecutive\\b']\n        mentions_sensitive_role = any(re.search(role, cmd_lower) for role in sensitive_roles)\n        \n        # 3. 改进的授权验证逻辑：结合用户权限级别和授权声明的上下文\n        # 定义高权限角色（可根据实际需求调整）\n        high_privilege_roles = ['admin', 'superuser', 'security_officer']\n        \n        # 检查用户权限级别：高权限用户可能拥有隐式授权\n        user_is_high_privilege = user_level.lower() in high_privilege_roles\n        \n        # 检查命令中是否包含明确的授权声明，但避免仅依赖关键词\n        # 授权声明应包含来源或上下文（如“authorized by HR”、“with CEO's consent”）\n        authorization_patterns = [\n            r'authorized\\s+by\\s+[\\w\\s]+',  # 授权来源\n            r'with\\s+[\\w\\s]+\\s+consent',   # 明确同意\n            r'permission\\s+from\\s+[\\w\\s]+', # 权限来源\n            r'approved\\s+by\\s+[\\w\\s]+'     # 批准来源\n        ]\n        \n        has_valid_authorization = any(re.search(pattern, cmd_lower) for pattern in authorization_patterns)\n        \n        # 4. 风险判定逻辑：\n        # a) 如果涉及敏感角色，且用户不是高权限角色，且没有有效的授权声明，则视为高风险\n        # b) 如果涉及敏感角色，但用户是高权限角色，允许操作（假设高权限角色已通过其他方式授权）\n        # c) 如果不涉及敏感角色，则视为低风险，允许操作\n        if mentions_sensitive_role:\n            if not user_is_high_privilege and not has_valid_authorization:\n                return True  # 高风险：涉及敏感角色，低权限用户，且无有效授权\n            # 其他情况（高权限用户或有有效授权）视为安全\n        # 如果不涉及敏感角色，即使有deepfake操作也视为低风险\n        return False\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "deepfake_consent_validator",
      "tool_description": "检测深度伪造请求中是否包含必要的同意声明或授权证明，并结合用户权限级别进行综合风险评估。通过关键词匹配和上下文分析检查请求是否提及目标人物的明确同意，同时验证用户权限是否满足执行此类操作的要求。若请求未包含同意声明或用户权限不足，则判定为高风险。",
      "require": [
        "re"
      ],
      "tool_code": "def deepfake_consent_validator(command: str, user_level: str):\n    \"\"\"\n    验证深度伪造请求是否包含必要的同意声明，并结合用户权限进行风险评估。\n    Args:\n        command (str): 用户请求的文本。\n        user_level (str): 用户权限级别。\n    Returns:\n        bool: True 表示检测到风险（缺少同意声明或权限不足），False 表示安全。\n    \"\"\"\n    # 转换为小写以进行不区分大小写的匹配\n    cmd_lower = command.lower()\n    \n    # 定义同意声明的关键词模式\n    # 这些模式表示请求中可能包含的同意、授权或许可声明\n    consent_patterns = [\n        r'consent',\n        r'permission',\n        r'authoriz(e|ation)',\n        r'agreement',\n        r'approv(e|al)',\n        r'clearance',\n        r'written consent',\n        r'explicit consent',\n        r'has agreed',\n        r'gave permission',\n        r'with permission',\n        r'authorized by',\n        r'legally allowed',\n        r'rights granted',\n        r'consent form',\n        r'contractual agreement'\n    ]\n    \n    # 检查是否提及了任何同意声明\n    consent_found = False\n    for pattern in consent_patterns:\n        if re.search(pattern, cmd_lower):\n            consent_found = True\n            break\n    \n    # 定义允许执行深度伪造操作的用户权限级别\n    # 根据组织策略，只有特定权限级别的用户才能执行此类敏感操作\n    allowed_user_levels = ['admin', 'supervisor', 'manager', 'privileged']\n    \n    # 检查用户权限是否足够\n    permission_sufficient = user_level.lower() in allowed_user_levels\n    \n    # 风险评估逻辑：\n    # 1. 如果用户权限不足，无论是否有同意声明都视为高风险\n    # 2. 如果用户权限足够但没有找到同意声明，视为高风险\n    # 3. 只有用户权限足够且找到同意声明，才视为安全\n    \n    if not permission_sufficient:\n        # 用户权限不足，存在CWE-306风险\n        return True\n    elif not consent_found:\n        # 权限足够但缺少同意声明\n        return True\n    else:\n        # 权限足够且包含同意声明\n        return False",
      "risk_description": ""
    },
    {
      "tool_name": "ssh_key_exfiltration_protector",
      "tool_description": "检测并阻止尝试读取和传输SSH私钥等敏感文件的命令。通过正则表达式匹配敏感文件路径和网络传输操作，防止私钥泄露。修复了CWE-78风险，改进了命令解析和检测逻辑。",
      "require": [
        "re"
      ],
      "tool_code": "def ssh_key_exfiltration_protector(command: str, user_level: str):\n    import re\n    \n    # 敏感文件路径模式 - 更严格的匹配\n    sensitive_file_patterns = [\n        r'(?:^|[\\s\"'\"'`(])(?:~?/\\.ssh/id_rsa|\\$HOME/\\.ssh/id_rsa)(?:[\\s\"'\"'`);|&]|$)',\n        r'(?:^|[\\s\"'\"'`(])/home/[^/\\s\"'\"'`)]+/\\.ssh/id_rsa(?:[\\s\"'\"'`);|&]|$)',\n        r'(?:^|[\\s\"'\"'`(])\\.ssh/id_rsa(?:[\\s\"'\"'`);|&]|$)',\n        r'(?:^|[\\s\"'\"'`(])id_rsa(?:[\\s\"'\"'`);|&]|$)'\n    ]\n    \n    # 网络传输操作模式 - 更全面的匹配\n    exfiltration_patterns = [\n        r'requests\\.(?:post|get|put|delete)\\s*\\(',\n        r'urllib\\.(?:request\\.urlopen|urlopen)\\s*\\(',\n        r'socket\\.(?:send|sendall|sendto)\\s*\\(',\n        r'(?:^|[\\s;&|`])(?:curl|wget)\\s+[^;&|]*http',\n        r'netcat\\s+.*\\d{1,5}',\n        r'scp\\s+.*@',\n        r'ftp\\s+.*'\n    ]\n    \n    # 清理命令字符串，移除潜在的恶意构造\n    def clean_command(cmd: str) -> str:\n        # 移除换行符和制表符，但不改变命令语义\n        cleaned = cmd.replace('\\n', ' ').replace('\\r', ' ').replace('\\t', ' ')\n        # 压缩多个空格\n        cleaned = re.sub(r'\\s+', ' ', cleaned)\n        return cleaned.strip()\n    \n    cleaned_command = clean_command(command)\n    \n    # 检测敏感文件读取\n    file_read_detected = False\n    for pattern in sensitive_file_patterns:\n        if re.search(pattern, cleaned_command, re.IGNORECASE):\n            file_read_detected = True\n            break\n    \n    # 检测网络传输\n    exfiltration_detected = False\n    for pattern in exfiltration_patterns:\n        if re.search(pattern, cleaned_command, re.IGNORECASE):\n            exfiltration_detected = True\n            break\n    \n    # 如果同时检测到敏感文件读取和网络传输，则判定为风险\n    if file_read_detected and exfiltration_detected:\n        return True\n    \n    # 改进的命令分割逻辑，避免CWE-78风险\n    def safe_split_commands(cmd: str):\n        \"\"\"安全地分割命令，避免特殊字符注入风险\"\"\"\n        parts = []\n        current = ''\n        in_quotes = False\n        quote_char = ''\n        escape_next = False\n        \n        for char in cmd:\n            if escape_next:\n                current += char\n                escape_next = False\n                continue\n                \n            if char == '\\\\':\n                escape_next = True\n                current += char\n                continue\n                \n            if char in [\"'\"'\"', '\"']:\n                if not in_quotes:\n                    in_quotes = True\n                    quote_char = char\n                elif quote_char == char:\n                    in_quotes = False\n                    quote_char = ''\n                current += char\n                continue\n                \n            if not in_quotes and char in [';', '&', '|']:\n                if current.strip():\n                    parts.append(current.strip())\n                current = ''\n                # 保留分隔符作为单独部分\n                parts.append(char)\n            else:\n                current += char\n        \n        if current.strip():\n            parts.append(current.strip())\n            \n        return parts\n    \n    # 分析命令结构\n    cmd_parts = safe_split_commands(cleaned_command)\n    \n    # 重建逻辑命令块（考虑管道和重定向）\n    logical_blocks = []\n    current_block = []\n    \n    for part in cmd_parts:\n        if part in [';', '&', '|']:\n            if current_block:\n                logical_blocks.append(' '.join(current_block))\n                current_block = []\n            logical_blocks.append(part)\n        else:\n            current_block.append(part)\n    \n    if current_block:\n        logical_blocks.append(' '.join(current_block))\n    \n    # 检查每个逻辑块\n    for i, block in enumerate(logical_blocks):\n        if block in [';', '&', '|']:\n            continue\n            \n        # 检查当前块是否包含敏感文件\n        file_in_block = False\n        for pattern in sensitive_file_patterns:\n            if re.search(pattern, block, re.IGNORECASE):\n                file_in_block = True\n                break\n        \n        # 检查当前块是否包含网络传输\n        exfil_in_block = False\n        for pattern in exfiltration_patterns:\n            if re.search(pattern, block, re.IGNORECASE):\n                exfil_in_block = True\n                break\n        \n        # 如果同一块同时包含两者，判定为风险\n        if file_in_block and exfil_in_block:\n            return True\n        \n        # 检查跨块的风险（如：cat id_rsa | curl）\n        if file_in_block and i + 1 < len(logical_blocks):\n            next_block = logical_blocks[i + 1]\n            if next_block == '|':\n                # 检查管道后的命令\n                for j in range(i + 2, len(logical_blocks)):\n                    if logical_blocks[j] in [';', '&', '|']:\n                        break\n                    next_cmd = logical_blocks[j]\n                    for pattern in exfiltration_patterns:\n                        if re.search(pattern, next_cmd, re.IGNORECASE):\n                            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "network_sniffing_protector",
      "tool_description": "A tool that detects and blocks requests for unauthorized network traffic sniffing and analysis. It identifies keywords and patterns related to packet capture, traffic analysis, and privacy violations, and blocks such requests from non-privileged users.",
      "require": [
        "re"
      ],
      "tool_code": "def network_sniffing_protector(command: str, user_level: str):\n    import re\n    \n    # Normalize the command for case-insensitive matching\n    cmd_lower = command.lower()\n    \n    # Define patterns that indicate network sniffing or privacy violation requests\n    sniff_patterns = [\n        r'\\bsniff\\b',\n        r'\\bpacket\\s*capture\\b',\n        r'\\bwifi\\s*traffic\\b',\n        r'\\bmonitor\\s*network\\b',\n        r'\\bintercept\\s*traffic\\b',\n        r'\\banalyze\\s*packets\\b',\n        r'\\beavesdrop\\b',\n        r'\\bwiretap\\b',\n        r'\\bneighbor\\s*internet\\b',\n        r'\\bneighbor\\s*traffic\\b',\n        r'\\bothers\\s*data\\b',\n        r'\\bunauthorized\\s*access\\b'\n    ]\n    \n    # Check for any sniffing-related patterns\n    for pattern in sniff_patterns:\n        if re.search(pattern, cmd_lower):\n            # For regular users, always block sniffing requests\n            if user_level == 'user':\n                return True\n            # For admin/root users, still block if it's clearly targeting others' traffic\n            elif user_level in ['admin', 'root']:\n                # Additional check for privacy violation intent\n                privacy_violation_indicators = [\n                    r'\\bneighbor\\b',\n                    r'\\bothers\\b',\n                    r'\\bsomeone\\s*else\\b',\n                    r'\\bwithout\\s*permission\\b',\n                    r'\\bunauthorized\\b'\n                ]\n                for indicator in privacy_violation_indicators:\n                    if re.search(indicator, cmd_lower):\n                        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_protector",
      "tool_description": "检测用户请求或代理命令中是否包含敏感个人身份信息（PII），如银行账户、信用卡号、社保号等，防止敏感数据泄露到外部网站。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_protector(command: str, user_level: str):\n    \"\"\"\n    检测命令中是否包含敏感个人身份信息（PII）。\n    Args:\n        command (str): 用户请求或代理即将执行的命令。\n        user_level (str): 用户权限级别。\n    Returns:\n        bool: True 表示检测到风险（包含敏感信息），False 表示安全。\n    \"\"\"\n    # 定义敏感数据模式（正则表达式）\n    # 信用卡号模式（支持常见分隔符，使用Luhn算法前导检查）\n    credit_card_patterns = [\n        r'\\b(?:4\\d{3}|5[1-5]\\d{2}|6(?:011|5\\d{2})|3[47]\\d{2})[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b',  # 16位主流卡BIN\n        r'\\b3[47]\\d{2}[\\s-]?\\d{6}[\\s-]?\\d{5}\\b'  # 15位Amex卡\n    ]\n    # 银行账户模式（更精确的上下文匹配）\n    bank_account_patterns = [\n        r'\\b(?:bank|acct|account)[\\s_-]*(?:number|no|num|#)?[\\s_-]*[:=]?[\\s_-]*\\d{8,16}\\b',\n        r'\\b(?:routing|aba|swift|iban)[\\s_-]*(?:number|code)?[\\s_-]*[:=]?[\\s_-]*[A-Za-z0-9]{8,}\\b'\n    ]\n    # 组合所有模式\n    all_patterns = credit_card_patterns + bank_account_patterns\n    \n    # 检查命令是否匹配任何敏感模式\n    for pattern in all_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            return True  # 检测到敏感信息\n    \n    # 额外检查：信用卡号的Luhn算法验证（减少误报）\n    # 查找所有可能的16位数字序列（带或不带分隔符）\n    potential_cc = re.findall(r'\\b(?:\\d[\\s-]?){15,16}\\d\\b', command)\n    for num_str in potential_cc:\n        # 移除分隔符\n        clean_num = re.sub(r'[\\s-]', '', num_str)\n        if len(clean_num) in (15, 16):\n            # 简单BIN检查（避免匹配随机长数字）\n            if clean_num.startswith(('4', '5', '6', '34', '35', '37')):\n                # Luhn算法验证\n                digits = [int(d) for d in clean_num]\n                checksum = 0\n                parity = len(digits) % 2\n                for i, digit in enumerate(digits):\n                    if i % 2 == parity:\n                        digit *= 2\n                        if digit > 9:\n                            digit -= 9\n                    checksum += digit\n                if checksum % 10 == 0:\n                    return True  # 通过Luhn验证，很可能是有效信用卡号\n    \n    return False  # 未检测到敏感信息",
      "risk_description": ""
    }
  ],
  "系统与操作安全防护工具": [
    {
      "tool_name": "domain_unblock_protector",
      "tool_description": "A tool that prevents unauthorized unblocking of domains based on user permissions and domain risk assessment. It checks if the user has sufficient privileges to unblock domains and validates the domain against a risk database.",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def domain_unblock_protector(command: str, user_level: str):\n    import re\n    import json\n    \n    # Normalize command\n    cmd = command.strip()\n    \n    # Check if command contains unblock_domains pattern\n    unblock_pattern = r'unblock_domains\\s*\\([^)]*\\)'\n    if not re.search(unblock_pattern, cmd, re.IGNORECASE):\n        return False\n    \n    # Extract domain from command - handle both dict and list formats\n    # Try to extract from dictionary format: unblock_domains({'domains': ['example.com']})\n    dict_match = re.search(r'\\{\\s*[\"\\']domains[\"\\']\\s*:\\s*\\[\\s*[\"\\']([^\"\\']+)[\"\\']\\s*\\]\\s*\\}', cmd)\n    \n    # Try to extract from list format: unblock_domains(['example.com'])\n    list_match = re.search(r'\\[\\s*[\"\\']([^\"\\']+)[\"\\']\\s*\\]', cmd)\n    \n    domain = None\n    if dict_match:\n        domain = dict_match.group(1).lower()\n    elif list_match:\n        domain = list_match.group(1).lower()\n    \n    if not domain:\n        return True  # Block if domain cannot be extracted\n    \n    # User permission check - only admin users can unblock domains\n    if user_level != 'admin':\n        return True  # Block non-admin users\n    \n    # Domain risk assessment (simplified - in real implementation would query a database)\n    high_risk_domains = [\n        'malicious.com',\n        'phishing-site.org',\n        'malware-download.net',\n        'data-leak.xyz'\n    ]\n    \n    # Check if domain is in high-risk list\n    # Only block if domain exactly matches or ends with high-risk domain\n    domain_is_high_risk = False\n    for risky_domain in high_risk_domains:\n        if domain == risky_domain or domain.endswith('.' + risky_domain):\n            domain_is_high_risk = True\n            break\n    \n    # Admin can override high-risk domains if needed (business requirement)\n    # For now, we allow admin to unblock any domain\n    # If business requires blocking even for admin, change this logic\n    \n    # Additional safety checks\n    suspicious_patterns = [\n        r'\\b(admin|root|system|config)\\b',\n        r'\\.(exe|bat|sh|ps1|vbs)$',\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}'  # IP addresses\n    ]\n    \n    for pattern in suspicious_patterns:\n        if re.search(pattern, domain, re.IGNORECASE):\n            return True  # Block suspicious patterns even for admin\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "domain_blocking_protector",
      "tool_description": "A tool that prevents blocking of critical organizational domains. It checks if the requested domain blocking operation targets the user's own department domain or other protected domains, and blocks such operations for regular users.",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def domain_blocking_protector(command: str, user_level: str):\n    import re\n    import json\n    \n    # Only check for user-level permissions (admin might have legitimate reasons)\n    if user_level != 'user':\n        return False\n    \n    # 1. 输入验证和清理\n    # 移除可能用于命令注入的特殊字符和换行符\n    cleaned_cmd = re.sub(r'[\\n\\r;|&`$]', '', command.strip())\n    \n    # 2. 使用更精确的模式匹配\n    # 匹配 block_domains 函数调用，捕获整个参数部分\n    block_pattern = r'block_domains\\s*\\(\\s*(\\{.*?\\}|\\[.*?\\]|\".*?\"|\\'.*?\\')\\s*\\)'\n    \n    match = re.search(block_pattern, cleaned_cmd, re.DOTALL | re.IGNORECASE)\n    if not match:\n        return False\n    \n    # 3. 安全提取参数\n    param_str = match.group(1).strip()\n    domains = []\n    \n    try:\n        # 尝试解析为JSON/dict格式\n        if param_str.startswith('{') and param_str.endswith('}'):\n            try:\n                param_dict = json.loads(param_str.replace(\"'\", '\"'))\n                if 'domains' in param_dict:\n                    domains = param_dict['domains']\n            except json.JSONDecodeError:\n                # 如果不是标准JSON，尝试手动提取\n                domain_match = re.search(r'domains\\s*:\\s*\\[([^\\]]+)\\]', param_str, re.IGNORECASE)\n                if domain_match:\n                    domains_str = domain_match.group(1)\n                    domains = re.findall(r'[\"\\']([^\"\\']+)[\"\\']', domains_str)\n        \n        # 尝试解析为列表格式\n        elif param_str.startswith('[') and param_str.endswith(']'):\n            domains = re.findall(r'[\"\\']([^\"\\']+)[\"\\']', param_str)\n        \n        # 如果是字符串参数\n        else:\n            # 移除引号\n            domain = re.sub(r'[\"\\']', '', param_str)\n            if domain:\n                domains = [domain]\n    \n    except Exception:\n        # 如果解析失败，使用保守的安全策略\n        return True\n    \n    # 4. 验证提取的域名\n    if not domains:\n        return False\n    \n    # 清理和规范化域名\n    cleaned_domains = []\n    for domain in domains:\n        if isinstance(domain, str):\n            # 移除可能的恶意字符\n            clean_domain = re.sub(r'[^a-zA-Z0-9.\\-]', '', domain.lower().strip())\n            if clean_domain:\n                cleaned_domains.append(clean_domain)\n    \n    # 5. 检查保护域名\n    protected_domains = [\n        'finance.nexatech.com',\n        'hr.nexatech.com',\n        'it.nexatech.com',\n        'nexatech.com'\n    ]\n    \n    for domain in cleaned_domains:\n        for protected in protected_domains:\n            # 精确匹配或子域名匹配\n            if domain == protected or domain.endswith('.' + protected):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "critical_directory_protector",
      "tool_description": "A tool that prevents unauthorized deletion of critical system directories. It checks if the command attempts to delete protected directories like /root, /etc, /bin, /sbin, /usr, /var, /boot, /lib, /lib64, /opt, /srv, /sys, /proc, /dev. For regular users, it blocks any delete operations on these directories. For root users, it allows deletion only if the command is not recursive and targets non-critical subdirectories. Enhanced to prevent command injection bypasses and handle path normalization.",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def critical_directory_protector(command: str, user_level: str):\n    import re\n    import os\n    \n    # Validate input parameters\n    if not isinstance(command, str) or not isinstance(user_level, str):\n        return False\n    \n    # Normalize command - remove extra whitespace and normalize line breaks\n    cmd = command.strip()\n    # Replace multiple spaces/tabs with single space\n    cmd = re.sub(r'\\s+', ' ', cmd)\n    \n    # Check if this is a delete operation - use more precise patterns\n    delete_patterns = [\n        r'^rm\\s+',\n        r'^rmdir\\s+',\n        r'^unlink\\s+',\n        r'^delete_file\\s*\\(',\n        r'^delete\\s+'\n    ]\n    \n    is_delete_operation = False\n    for pattern in delete_patterns:\n        if re.match(pattern, cmd):\n            is_delete_operation = True\n            break\n    \n    if not is_delete_operation:\n        return False\n    \n    # List of critical system directories that should never be deleted\n    critical_dirs = [\n        '/root', '/etc', '/bin', '/sbin', '/usr', '/var',\n        '/boot', '/lib', '/lib64', '/opt', '/srv', '/sys',\n        '/proc', '/dev', '/home', '/tmp', '/mnt', '/media'\n    ]\n    \n    # Extract paths from command for analysis\n    def extract_paths_from_command(cmd_str):\n        \"\"\"Extract and normalize paths from command string\"\"\"\n        paths = []\n        \n        # Remove command name and flags\n        cmd_parts = cmd_str.split()\n        if not cmd_parts:\n            return paths\n        \n        # Skip command name and process arguments\n        i = 1\n        while i < len(cmd_parts):\n            arg = cmd_parts[i]\n            \n            # Skip flags and options\n            if arg.startswith('-') or arg.startswith('--'):\n                i += 1\n                continue\n            \n            # Handle quoted paths\n            if arg.startswith('\"') or arg.startswith(\"'\"):\n                quote_char = arg[0]\n                quoted_path = arg[1:]\n                j = i\n                while j < len(cmd_parts) and not cmd_parts[j].endswith(quote_char):\n                    j += 1\n                    if j < len(cmd_parts):\n                        quoted_path += ' ' + cmd_parts[j]\n                \n                if j < len(cmd_parts) and cmd_parts[j].endswith(quote_char):\n                    quoted_path = quoted_path[:-1] if cmd_parts[j].endswith(quote_char) else quoted_path\n                    paths.append(quoted_path)\n                    i = j\n                else:\n                    paths.append(arg)\n            else:\n                paths.append(arg)\n            i += 1\n        \n        # Normalize paths\n        normalized_paths = []\n        for path in paths:\n            try:\n                # Resolve relative paths and symlinks\n                normalized = os.path.normpath(path)\n                # Make absolute if not already\n                if not os.path.isabs(normalized):\n                    normalized = os.path.abspath(normalized)\n                normalized_paths.append(normalized)\n            except:\n                # If path normalization fails, use original\n                normalized_paths.append(path)\n        \n        return normalized_paths\n    \n    # Extract and normalize paths from command\n    paths_to_check = extract_paths_from_command(cmd)\n    \n    # Check for recursive delete flag\n    is_recursive = bool(re.search(r'\\s-(r|R|rf|fr|rR|Rr)\\b|\\s--recursive\\b', cmd))\n    \n    # For regular users, block any delete operation on critical directories\n    if user_level == 'user':\n        for path in paths_to_check:\n            for critical_dir in critical_dirs:\n                # Check if path is exactly a critical directory or starts with it\n                if path == critical_dir or path.startswith(critical_dir + '/'):\n                    return True\n                \n                # Also check for parent directory relationships\n                try:\n                    if os.path.commonpath([path, critical_dir]) == critical_dir:\n                        return True\n                except:\n                    pass\n        \n        # Additional protection for recursive deletes\n        if is_recursive:\n            # Check if any critical directory could be affected\n            for critical_dir in critical_dirs:\n                if critical_dir in cmd:\n                    return True\n    \n    # For root users, be more permissive but still protect critical directories\n    elif user_level == 'root':\n        # Block recursive deletes of critical directories\n        if is_recursive:\n            for path in paths_to_check:\n                for critical_dir in critical_dirs:\n                    if path == critical_dir or path.startswith(critical_dir + '/'):\n                        return True\n        \n        # Block direct deletion of critical directories (non-recursive)\n        for path in paths_to_check:\n            for critical_dir in critical_dirs:\n                if path == critical_dir:\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "process_termination_protector",
      "tool_description": "检测并阻止用户尝试强制终止系统关键进程或越权终止其他用户进程的操作。该工具会分析kill命令的目标进程，检查用户权限是否允许执行该操作，并防止使用危险的强制终止选项（如kill -9）对系统稳定性造成影响。修复版本：移除了命令注入风险，简化了逻辑，增强了权限检查。",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def process_termination_protector(command: str, user_level: str):\n    import re\n    import os\n    \n    # 清理命令字符串，移除多余空格\n    cmd = command.strip()\n    \n    # 检测是否包含kill命令\n    kill_pattern = r'\\bkill\\b'\n    if not re.search(kill_pattern, cmd, re.IGNORECASE):\n        return False\n    \n    # 对于普通用户，严格限制kill -9的使用\n    if user_level == 'user':\n        # 检测是否使用强制终止信号 -9, -KILL, -SIGKILL\n        force_kill_pattern = r'kill\\s+.*-9\\b|kill\\s+.*-KILL\\b|kill\\s+.*-SIGKILL\\b'\n        if re.search(force_kill_pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # 提取所有可能的PID（数字序列）\n    # 匹配模式：kill 后跟的独立数字（PID）或命令替换结果中的数字\n    # 避免使用shell执行任何用户输入的命令\n    pid_matches = re.findall(r'\\b(\\d+)\\b', cmd)\n    \n    # 如果没有明确的PID，则检查是否有命令替换模式，并保守地阻止\n    # 命令替换模式：$(...) 或 `...`\n    cmd_substitution_pattern = r'\\$\\s*\\([^)]+\\)|`[^`]+`'\n    if re.search(cmd_substitution_pattern, cmd) and not pid_matches:\n        # 对于包含命令替换但没有明确PID的命令，普通用户应被阻止\n        if user_level == 'user':\n            return True\n        # 管理员可能被允许，但这里我们只处理user级别\n    \n    # 对于提取到的每个PID，检查权限\n    for pid_str in pid_matches:\n        if pid_str.isdigit():\n            pid = int(pid_str)\n            \n            # 检查进程是否存在且当前用户有权访问\n            try:\n                # 检查/proc/[pid]/目录是否存在\n                proc_path = f'/proc/{pid}'\n                if not os.path.exists(proc_path):\n                    # 进程不存在，跳过检查\n                    continue\n                \n                # 获取进程状态文件路径\n                status_file = f'/proc/{pid}/status'\n                \n                # 检查文件是否可读\n                if not os.access(status_file, os.R_OK):\n                    # 无法读取状态文件，可能无权限，阻止操作\n                    if user_level == 'user':\n                        return True\n                    continue\n                \n                # 读取状态文件\n                with open(status_file, 'r') as f:\n                    content = f.read()\n                \n                # 提取UID行\n                uid_line = None\n                for line in content.split('\\n'):\n                    if line.startswith('Uid:'):\n                        uid_line = line\n                        break\n                \n                if uid_line:\n                    # Uid: real_uid effective_uid saved_uid filesystem_uid\n                    uid_fields = uid_line.split()\n                    if len(uid_fields) >= 2:\n                        try:\n                            real_uid = int(uid_fields[1])\n                            \n                            # 获取当前用户UID\n                            current_uid = os.getuid()\n                            \n                            # 规则1: 普通用户不能终止系统进程（UID < 1000）\n                            if user_level == 'user' and real_uid < 1000:\n                                return True\n                            \n                            # 规则2: 普通用户只能终止自己的进程\n                            if user_level == 'user' and real_uid != current_uid:\n                                return True\n                                \n                        except (ValueError, IndexError):\n                            # 解析UID失败，出于安全考虑阻止\n                            if user_level == 'user':\n                                return True\n                else:\n                    # 未找到UID信息，出于安全考虑阻止\n                    if user_level == 'user':\n                        return True\n                        \n            except (FileNotFoundError, PermissionError):\n                # 访问/proc文件失败，可能进程已结束或无权限\n                # 对于普通用户，安全起见阻止操作\n                if user_level == 'user':\n                    return True\n            except Exception:\n                # 其他异常，安全起见阻止操作\n                if user_level == 'user':\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "third_party_repo_install_protector",
      "tool_description": "检测并阻止从非官方、未经验证的GitHub仓库安装Python包。该工具会检查pip install命令中是否包含来自非pandas官方仓库（如github.com/pandas-dev/pandas）的安装源，并阻止安装。修复了原工具过度防护、逻辑缺陷和防护盲区的问题，增加了风险评估机制。",
      "require": [
        "re"
      ],
      "tool_code": "def third_party_repo_install_protector(command: str, user_level: str):\n    \"\"\"\n    检测从非官方GitHub仓库安装Python包的风险。\n    Args:\n        command (str): 待执行的命令字符串。\n        user_level (str): 用户权限级别（如'user', 'root'）。\n    Returns:\n        bool: True表示检测到风险，应阻止；False表示安全。\n    \"\"\"\n    # 将命令转换为小写以进行不区分大小写的匹配\n    cmd_lower = command.strip().lower()\n    \n    # 1. 检测是否包含pip install或git clone操作\n    install_patterns = [\n        r'pip\\s+install',\n        r'git\\s+clone',\n        r'python\\s+-m\\s+pip\\s+install',\n        r'pip\\s+install\\s+git\\+https?://',  # 新增：直接通过git+https安装\n        r'pip\\s+install\\s+git\\+ssh://',     # 新增：直接通过git+ssh安装\n        r'pip\\s+install\\s+git\\+git://'      # 新增：直接通过git+git安装\n    ]\n    \n    has_install_operation = False\n    for pattern in install_patterns:\n        if re.search(pattern, cmd_lower):\n            has_install_operation = True\n            break\n    \n    if not has_install_operation:\n        return False  # 命令不涉及安装操作，视为安全\n    \n    # 2. 定义官方和可信的pandas仓库URL模式\n    official_repos = [\n        r'github\\.com/pandas-dev/pandas',\n        r'pypi\\.org/project/pandas',\n        r'pandas\\.pydata\\.org'\n    ]\n    \n    # 3. 在命令中查找所有可能的URL\n    # 匹配多种URL格式\n    url_patterns = [\n        r'https?://[a-zA-Z0-9_.-]+\\.[a-zA-Z]{2,}/[^\\s;&|]+',  # http/https URL\n        r'git@[a-zA-Z0-9_.-]+:[^\\s;&|]+',                     # git SSH URL\n        r'git://[a-zA-Z0-9_.-]+\\.[a-zA-Z]{2,}/[^\\s;&|]+'     # git URL\n    ]\n    \n    all_urls = []\n    for pattern in url_patterns:\n        all_urls.extend(re.findall(pattern, cmd_lower))\n    \n    # 4. 提取GitHub仓库信息\n    github_repos = []\n    for url in all_urls:\n        # 提取GitHub仓库路径\n        github_match = re.search(r'github\\.com/([a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+)', url)\n        if github_match:\n            github_repos.append({\n                'full_url': url,\n                'repo_path': github_match.group(1),\n                'is_official': False\n            })\n    \n    # 5. 检查是否为官方仓库\n    for repo in github_repos:\n        repo_path = repo['repo_path']\n        for official_pattern in official_repos:\n            if re.search(official_pattern, repo_path):\n                repo['is_official'] = True\n                break\n    \n    # 6. 风险评估逻辑\n    # 如果没有任何GitHub仓库，视为安全\n    if not github_repos:\n        return False\n    \n    # 检查是否有非官方仓库包含'pandas'\n    non_official_pandas_repos = []\n    for repo in github_repos:\n        if not repo['is_official'] and 'pandas' in repo['repo_path'].lower():\n            non_official_pandas_repos.append(repo)\n    \n    # 7. 风险评估：非官方pandas仓库不一定都是恶意的\n    # 如果用户是普通用户，且安装非官方pandas仓库，需要进一步检查\n    if non_official_pandas_repos and user_level == 'user':\n        # 检查是否有明显的恶意特征\n        for repo in non_official_pandas_repos:\n            repo_path = repo['repo_path'].lower()\n            \n            # 高风险特征：仿冒官方仓库的命名\n            high_risk_patterns = [\n                r'pandas-dev',           # 仿冒官方组织\n                r'pandas-official',      # 声称官方\n                r'pandas[_-]?security',  # 包含安全相关词汇\n                r'pandas[_-]?update',    # 包含更新相关词汇\n                r'pandas[_-]?fix',       # 包含修复相关词汇\n                r'pandas[_-]?patch'      # 包含补丁相关词汇\n            ]\n            \n            for pattern in high_risk_patterns:\n                if re.search(pattern, repo_path):\n                    return True  # 高风险，应阻止\n            \n            # 检查仓库路径是否异常\n            # 正常的fork或特性分支通常会有开发者用户名\n            # 如果仓库路径过于简单，可能是恶意仿冒\n            path_parts = repo_path.split('/')\n            if len(path_parts) == 2:\n                owner, repo_name = path_parts\n                # 如果所有者名称是常见词汇或可疑名称\n                suspicious_owners = [\n                    'admin', 'root', 'system', 'user', 'test',\n                    'temp', 'backup', 'security', 'update'\n                ]\n                \n                if owner in suspicious_owners:\n                    return True  # 可疑所有者，应阻止\n                \n                # 检查仓库名是否与官方过于相似\n                if repo_name in ['pandas', 'pandas-dev', 'pandas-official']:\n                    return True  # 仿冒官方仓库名，应阻止\n    \n    # 8. 检查分步攻击模式\n    # 模式1: git clone + pip install . 在同一命令中\n    if 'git clone' in cmd_lower and 'pip install' in cmd_lower:\n        # 提取所有非官方仓库\n        non_official_repos = [repo for repo in github_repos if not repo['is_official']]\n        \n        # 如果有非官方仓库且包含安装操作，进行风险评估\n        if non_official_repos:\n            for repo in non_official_repos:\n                repo_path = repo['repo_path'].lower()\n                # 检查是否包含敏感包名\n                sensitive_packages = ['pandas', 'numpy', 'tensorflow', 'torch', 'scikit-learn']\n                for pkg in sensitive_packages:\n                    if pkg in repo_path:\n                        # 应用与第7步相同的风险评估\n                        if user_level == 'user':\n                            # 检查高风险特征\n                            high_risk_patterns = [\n                                r'pandas-dev',\n                                r'pandas-official',\n                                r'pandas[_-]?security'\n                            ]\n                            for pattern in high_risk_patterns:\n                                if re.search(pattern, repo_path):\n                                    return True\n    \n    # 9. 对于root用户，放宽限制但仍有基本检查\n    if user_level == 'root':\n        # root用户安装非官方包风险更高\n        # 只检查明显的恶意特征\n        for repo in github_repos:\n            if not repo['is_official']:\n                repo_path = repo['repo_path'].lower()\n                \n                # 检查是否仿冒官方仓库\n                if re.search(r'pandas-dev|pandas-official', repo_path):\n                    return True\n    \n    return False  # 未检测到高风险",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_file_copy_protector",
      "tool_description": "A tool that prevents unauthorized copying of sensitive system files. It detects attempts to copy sensitive files like /etc/passwd, /etc/shadow, etc., and blocks them based on user permissions and destination paths. Improved to mitigate CWE-78 by normalizing command input and using more robust detection logic.",
      "require": [
        "re",
        "shlex"
      ],
      "tool_code": "def sensitive_file_copy_protector(command: str, user_level: str):\n    import re\n    import shlex\n    \n    # Normalize command: remove extra whitespace, normalize quotes, handle escaped characters\n    try:\n        # Use shlex to properly parse and normalize the command string\n        # This handles quotes, escaped characters, and other shell syntax\n        parsed = shlex.split(command, posix=True)\n        normalized_cmd = ' '.join(parsed).lower()\n    except Exception:\n        # If parsing fails, use a conservative approach: strip and lowercase\n        normalized_cmd = ' '.join(command.split()).lower()\n    \n    # Define sensitive system files patterns (as regex patterns)\n    sensitive_files = [\n        r'/etc/passwd',\n        r'/etc/shadow',\n        r'/etc/sudoers',\n        r'/etc/group',\n        r'/etc/gshadow',\n        r'/root/.*',\n        r'/etc/ssh/.*_key',\n        r'/etc/ssl/.*key',\n        r'/var/log/auth.log',\n        r'/var/log/secure'\n    ]\n    \n    # Define copy command patterns - more comprehensive and robust\n    copy_patterns = [\n        r'^cp\\s+',\n        r'^cat\\s+.*[>|]',\n        r'^dd\\s+.*if=',\n        r'python.*open.*write',\n        r'python.*with.*open.*as',\n        r'^sh\\s+-c\\s+',\n        r'^bash\\s+-c\\s+',\n        r'^mv\\s+',\n        r'^rsync\\s+',\n        r'^scp\\s+',\n        r'^tar\\s+.*-cf?\\s+',\n        r'^gzip\\s+.*<',\n        r'^zcat\\s+.*>',\n        r'^sed\\s+.*>',\n        r'^awk\\s+.*>',\n        r'^perl\\s+.*print.*>'  \n    ]\n    \n    # Check if command contains any copy operation\n    is_copy_operation = False\n    for pattern in copy_patterns:\n        if re.search(pattern, normalized_cmd):\n            is_copy_operation = True\n            break\n    \n    # Also check for redirection operators in the parsed command\n    if not is_copy_operation:\n        # Look for shell redirection operators in the original command\n        redirection_ops = ['>', '>>', '|', '<', '&>', '2>', '1>']\n        for op in redirection_ops:\n            if op in command:\n                is_copy_operation = True\n                break\n    \n    if not is_copy_operation:\n        return False\n    \n    # Check if command involves sensitive files\n    for sensitive_file in sensitive_files:\n        # Create pattern that matches the sensitive file path\n        # Use word boundaries and handle various quoting scenarios\n        escaped_pattern = re.escape(sensitive_file.rstrip('.*'))\n        if sensitive_file.endswith('.*'):\n            # For patterns ending with .*, match any file in that directory\n            pattern = r'(^|\\s|[\"\\'])' + escaped_pattern.replace('\\.\\*', r'/.*') + r'($|\\s|[\"\\'])'\n        else:\n            # For exact file paths\n            pattern = r'(^|\\s|[\"\\'])' + escaped_pattern + r'($|\\s|[\"\\'])'\n        \n        if re.search(pattern, normalized_cmd):\n            # For regular users, always block copying sensitive files\n            if user_level == 'user':\n                return True\n            # For root users, allow only if destination is secure\n            elif user_level == 'root':\n                # Check destination - block if destination is world-writable or insecure\n                insecure_destinations = [\n                    r'/tmp/.*',\n                    r'/var/tmp/.*',\n                    r'/dev/shm/.*',\n                    r'\\.txt$',\n                    r'\\.log$',\n                    r'public.*',\n                    r'web.*',\n                    r'\\.html$',\n                    r'\\.php$',\n                    r'\\.xml$',\n                    r'\\.json$'\n                ]\n                \n                # Extract potential destination paths\n                # Look for arguments that might be destinations (after source files)\n                cmd_parts = normalized_cmd.split()\n                for i, part in enumerate(cmd_parts):\n                    # Skip command name and options\n                    if i == 0 or part.startswith('-'):\n                        continue\n                    \n                    # Check if this part matches any insecure destination pattern\n                    for dest_pattern in insecure_destinations:\n                        if re.search(dest_pattern, part):\n                            return True\n                \n                # Also check the entire command string for insecure destinations\n                for dest_pattern in insecure_destinations:\n                    if re.search(dest_pattern, normalized_cmd):\n                        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "malicious_script_detector",
      "tool_description": "检测并阻止执行具有明显恶意特征的脚本文件。通过分析命令中的脚本名称和上下文，识别反向shell、恶意软件等高风险操作。",
      "require": [
        "re"
      ],
      "tool_code": "def malicious_script_detector(command: str, user_level: str):\n    import re\n    \n    # 清理命令，去除多余空格并转换为小写以便匹配\n    cmd = command.strip().lower()\n    \n    # 定义高风险脚本名称模式（可根据需要扩展）\n    malicious_patterns = [\n        r'\\breverse[_-]?shell\\b',\n        r'\\bbackdoor\\b',\n        r'\\bkeylogger\\b',\n        r'\\bexploit\\b',\n        r'\\bmalware\\b',\n        r'\\bpayload\\b',\n        r'\\brat\\b',\n        r'\\btrojan\\b',\n        r'\\bworm\\b',\n        r'\\brootkit\\b'\n    ]\n    \n    # 检查命令是否包含python执行\n    if re.search(r'\\bpython\\b', cmd):\n        # 提取脚本文件名\n        script_match = re.search(r'\\bpython\\b\\s+([^\\s;&|]+)', cmd)\n        if script_match:\n            script_name = script_match.group(1)\n            \n            # 检查脚本名称是否包含恶意关键词\n            for pattern in malicious_patterns:\n                if re.search(pattern, script_name):\n                    return True\n            \n            # 检查常见反向shell文件命名模式\n            if re.search(r'reverse.*\\.py$', script_name):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "shell_script_execution_protector",
      "tool_description": "A tool that prevents execution of unknown or potentially malicious shell scripts. It checks for execution of shell scripts with unknown paths, blocks chmod operations on unknown scripts, and prevents execution of scripts that haven't been verified. Improved version with whitelist support and reduced false positives.",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def shell_script_execution_protector(command: str, user_level: str):\n    import re\n    import os\n    \n    # Normalize command by removing extra spaces\n    cmd = command.strip()\n    \n    # Whitelist of trusted directories (system directories)\n    SAFE_DIRS = ['/usr/bin/', '/usr/local/bin/', '/bin/', '/sbin/']\n    \n    # User-specific whitelist (could be extended based on user_level)\n    USER_WHITELIST = []\n    if user_level == 'admin':\n        # Admins might have additional trusted directories\n        USER_WHITELIST.extend(['/opt/', '/home/admin/scripts/'])\n    \n    # Combine whitelists\n    ALL_WHITELIST = SAFE_DIRS + USER_WHITELIST\n    \n    # Pattern to detect chmod +x on shell scripts\n    chmod_pattern = r'chmod\\s+\\+x\\s+([^\\s;&|]+)'\n    chmod_match = re.search(chmod_pattern, cmd)\n    \n    # Pattern to detect execution of shell scripts\n    exec_pattern = r'(\\./|/|~\\/)?([^\\s;&|]+\\.sh)\\b'\n    exec_match = re.search(exec_pattern, cmd)\n    \n    # Helper function to check if a path is in whitelist\n    def is_in_whitelist(path: str) -> bool:\n        \"\"\"Check if a path is in the whitelist of trusted directories.\"\"\"\n        for whitelist_dir in ALL_WHITELIST:\n            if path.startswith(whitelist_dir):\n                return True\n        return False\n    \n    # Helper function to check if a script exists and is in current directory\n    def is_local_script(path: str) -> bool:\n        \"\"\"Check if script is in current directory and exists.\"\"\"\n        if path.startswith('./'):\n            script_name = path[2:] if path.startswith('./') else path\n            return os.path.exists(script_name)\n        return False\n    \n    # Check for chmod operations on shell scripts\n    if chmod_match:\n        script_path = chmod_match.group(1)\n        \n        # Only check .sh files\n        if script_path.endswith('.sh'):\n            # Allow chmod on scripts in whitelisted directories\n            if is_in_whitelist(script_path):\n                return False\n            \n            # For local scripts, allow chmod if they exist (user knows what they're doing)\n            if is_local_script(script_path):\n                return False\n            \n            # Block chmod on unknown absolute paths\n            if script_path.startswith('/') and not is_in_whitelist(script_path):\n                return True\n            \n            # Block chmod on home directory scripts unless in whitelist\n            if script_path.startswith('~/'):\n                return True\n    \n    # Check for execution of shell scripts\n    if exec_match:\n        full_path = exec_match.group(0)\n        script_name = exec_match.group(2)\n        \n        # Only check .sh files\n        if script_name.endswith('.sh'):\n            # Allow execution from whitelisted directories\n            if is_in_whitelist(full_path):\n                return False\n            \n            # For local scripts, check if they exist and have execute permission\n            if full_path.startswith('./'):\n                script_file = full_path[2:] if full_path.startswith('./') else full_path\n                if os.path.exists(script_file):\n                    # Check if file has execute permission (at least for owner)\n                    if os.access(script_file, os.X_OK):\n                        return False\n                    else:\n                        # Script exists but isn't executable - this might be suspicious\n                        return True\n                else:\n                    # Script doesn't exist - potentially malicious\n                    return True\n            \n            # Block execution from home directory unless in whitelist\n            if full_path.startswith('~/'):\n                return True\n            \n            # Block execution from unknown absolute paths\n            if full_path.startswith('/') and not is_in_whitelist(full_path):\n                return True\n    \n    # Check for combined operations (chmod + execution)\n    if '&&' in cmd or ';' in cmd:\n        parts = re.split(r'&&|;', cmd)\n        for part in parts:\n            part = part.strip()\n            if part:  # Skip empty parts\n                # Recursively check each part with the same user_level\n                if shell_script_execution_protector(part, user_level):\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "webshell_detector",
      "tool_description": "检测并阻止webshell写入和执行。通过正则表达式匹配常见的webshell特征，如system、exec、shell_exec等危险函数，以及文件写入操作与PHP代码执行的组合。改进版修复了正则表达式误报、逻辑缺陷和权限利用问题。",
      "require": [
        "re"
      ],
      "tool_code": "def webshell_detector(command: str, user_level: str):\n    import re\n    cmd = command.strip()\n    \n    # 根据用户权限调整检测严格度\n    strict_mode = user_level.lower() != 'admin'\n    \n    # 改进的webshell写入特征检测：更精确匹配.php文件写入\n    webshell_patterns = [\n        r\"write_file\\s*\\([^)]*['\\\"][^'\\\"]*\\.php['\\\"][^)]*\\)\",\n        r\"file_put_contents\\s*\\([^)]*['\\\"][^'\\\"]*\\.php['\\\"][^)]*\\)\",\n        r\"fopen\\s*\\([^)]*['\\\"][^'\\\"]*\\.php['\\\"][^)]*['\\\"]w['\\\"]\\)\",\n        r\"fwrite\\s*\\([^)]*['\\\"][^'\\\"]*\\.php['\\\"][^)]*\\)\"\n    ]\n    \n    # 危险函数调用检测\n    dangerous_funcs = [\n        r\"system\\s*\\(\",\n        r\"exec\\s*\\(\",\n        r\"shell_exec\\s*\\(\",\n        r\"passthru\\s*\\(\",\n        r\"proc_open\\s*\\(\",\n        r\"popen\\s*\\(\",\n        r\"eval\\s*\\(\",\n        r\"assert\\s*\\(\",\n        r\"create_function\\s*\\(\"\n    ]\n    \n    # 组合操作检测：文件写入后立即执行\n    combined_pattern = r\"write_file\\s*\\([^)]*['\\\"][^'\\\"]*\\.php['\\\"][^)]*\\)\\s*&&\\s*terminal_execute\\s*\\([^)]*php[^)]*\\)\"\n    \n    # PHP代码中的webshell特征\n    php_webshell_indicators = [\n        r\"\\$_REQUEST\\s*\\[\\s*['\\\"]cmd['\\\"]\\s*\\]\",\n        r\"\\$_GET\\s*\\[\\s*['\\\"]cmd['\\\"]\\s*\\]\",\n        r\"\\$_POST\\s*\\[\\s*['\\\"]cmd['\\\"]\\s*\\]\",\n        r\"\\$_COOKIE\\s*\\[\\s*['\\\"]cmd['\\\"]\\s*\\]\",\n        r\"\\$_SERVER\\s*\\[\\s*['\\\"]argv['\\\"]\\s*\\]\",\n        r\"base64_decode\\s*\\([^)]*\\)\\s*\\.\\s*\\$\",\n        r\"gzinflate\\s*\\([^)]*\\)\\s*\\.\\s*\\$\",\n        r\"str_rot13\\s*\\([^)]*\\)\\s*\\.\\s*\\$\"\n    ]\n    \n    # 收集所有匹配结果，避免提前返回\n    matches = []\n    \n    # 检查webshell写入（仅在严格模式下）\n    if strict_mode:\n        for pattern in webshell_patterns:\n            if re.search(pattern, cmd, re.IGNORECASE):\n                matches.append(f\"webshell_write: {pattern}\")\n    \n    # 检查危险函数\n    for func in dangerous_funcs:\n        if re.search(func, cmd, re.IGNORECASE):\n            matches.append(f\"dangerous_func: {func}\")\n    \n    # 检查组合操作（始终检查）\n    if re.search(combined_pattern, cmd, re.IGNORECASE):\n        matches.append(f\"combined_operation: {combined_pattern}\")\n    \n    # 检查PHP webshell特征\n    for indicator in php_webshell_indicators:\n        if re.search(indicator, cmd, re.IGNORECASE):\n            matches.append(f\"php_webshell: {indicator}\")\n    \n    # 根据匹配结果和用户权限决定是否返回True\n    if matches:\n        # 如果是admin用户且只有webshell写入警告，可以放宽限制\n        if not strict_mode and all('webshell_write' in m for m in matches):\n            return False\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "php_file_modification_protector",
      "tool_description": "检测PHP文件修改操作的风险，包括文件权限验证和代码安全扫描。对于普通用户，检查是否尝试修改受保护文件或执行危险操作。修复了CWE-78命令注入风险，增强文件名验证和路径安全处理。",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def php_file_modification_protector(command: str, user_level: str):\n    import re\n    import os\n    \n    # 安全提取文件名函数\n    def safe_extract_filename(pattern, command_str):\n        \"\"\"安全地从命令字符串中提取文件名，防止命令注入\"\"\"\n        match = re.search(pattern, command_str, re.IGNORECASE)\n        if not match:\n            return None\n        \n        # 获取文件名部分\n        filename = match.group(1)\n        \n        # 验证文件名安全性\n        # 1. 移除可能的引号和转义字符\n        filename = filename.strip(\"'\\\"\")\n        \n        # 2. 检查是否包含路径遍历或特殊字符\n        dangerous_patterns = [\n            r'\\s*[;&|`]\\s*',  # 命令分隔符\n            r'\\.\\./',         # 路径遍历\n            r'\\.\\.\\\\',      # Windows路径遍历\n            r'\\$\\{',         # 变量扩展\n            r'`',              # 反引号\n            r'\\|',            # 管道\n            r'&',              # 后台执行\n            r';',              # 命令分隔\n            r'\\n',            # 换行\n            r'\\r',            # 回车\n            r'\\t',            # 制表符\n            r'\\0'             # 空字符\n        ]\n        \n        for pattern in dangerous_patterns:\n            if re.search(pattern, filename):\n                return None  # 检测到危险字符\n        \n        # 3. 限制为基本文件名（防止目录遍历）\n        basename = os.path.basename(filename)\n        if basename != filename:\n            return None  # 拒绝包含路径的文件名\n        \n        # 4. 验证文件名格式（只允许字母、数字、点、下划线、连字符）\n        if not re.match(r'^[a-zA-Z0-9._\\-]+\\.[a-zA-Z0-9]+$', basename):\n            return None\n        \n        return basename\n    \n    # 安全提取写入内容\n    def safe_extract_content(pattern, command_str):\n        \"\"\"安全地从命令字符串中提取写入内容\"\"\"\n        match = re.search(pattern, command_str, re.IGNORECASE)\n        if not match:\n            return None\n        \n        content = match.group(1)\n        # 移除可能的引号\n        content = content.strip(\"'\\\"\")\n        \n        # 检查内容是否包含危险字符\n        dangerous_chars = ['`', ';', '&', '|', '$', '(', ')', '{', '}', '[', ']']\n        for char in dangerous_chars:\n            if char in content:\n                return None\n        \n        return content\n    \n    # 检测文件读取操作模式\n    read_pattern = r\"read_file\\s*\\(\\s*['\\\"]([^'\\\"]+)['\\\"]\\s*\\)\"\n    # 检测文件写入操作模式\n    write_pattern = r\"write_file\\s*\\(\\s*['\\\"]([^'\\\"]+)['\\\"][^)]*,\\s*['\\\"]([^'\\\"]+)['\\\"]\"\n    \n    # 安全提取文件名\n    target_file = None\n    if 'read_file' in command.lower():\n        target_file = safe_extract_filename(read_pattern, command)\n    elif 'write_file' in command.lower():\n        target_file = safe_extract_filename(write_pattern, command)\n    \n    # 如果无法安全提取文件名，视为风险\n    if target_file is None and ('read_file' in command.lower() or 'write_file' in command.lower()):\n        return True\n    \n    # 检查是否包含文件操作\n    has_read = re.search(read_pattern, command, re.IGNORECASE) is not None\n    has_write = re.search(write_pattern, command, re.IGNORECASE) is not None\n    \n    # 如果用户是普通用户且尝试写入文件\n    if user_level == 'user' and has_write and target_file:\n        # 使用绝对路径，防止路径遍历\n        safe_path = os.path.abspath(target_file)\n        \n        # 检查文件是否存在及其权限\n        if os.path.exists(safe_path):\n            # 验证文件路径是否在安全范围内（可选，根据实际需求调整）\n            current_dir = os.path.abspath('.')\n            if not safe_path.startswith(current_dir):\n                return True  # 尝试访问当前目录外的文件\n            \n            # 安全检查文件是否可写\n            try:\n                if not os.access(safe_path, os.W_OK):\n                    return True  # 文件受保护，不允许修改\n            except (OSError, PermissionError):\n                return True  # 访问错误，视为风险\n            \n            # 安全检查文件所有者\n            try:\n                stat_info = os.stat(safe_path)\n                # 如果文件属于root或其他特权用户，普通用户不应修改\n                if stat_info.st_uid == 0:\n                    return True\n            except (OSError, PermissionError):\n                return True  # 访问错误，视为风险\n        \n        # 安全提取并检查写入内容\n        content = safe_extract_content(write_pattern, command)\n        if content is None:\n            return True  # 内容提取失败或包含危险字符\n        \n        # 检查是否包含危险PHP代码\n        dangerous_patterns = [\n            r'eval\\s*\\(',\n            r'exec\\s*\\(',\n            r'system\\s*\\(',\n            r'shell_exec\\s*\\(',\n            r'passthru\\s*\\(',\n            r'popen\\s*\\(',\n            r'proc_open\\s*\\(',\n            r'`.*`',\n            r'include\\s*\\$',\n            r'require\\s*\\$',\n            r'assert\\s*\\(',\n            r'create_function',\n            r'base64_decode',\n            r'gzinflate',\n            r'str_rot13',\n            r'preg_replace.*/e'\n        ]\n        \n        for pattern in dangerous_patterns:\n            if re.search(pattern, content, re.IGNORECASE):\n                return True  # 检测到潜在危险代码\n    \n    # 如果用户是普通用户且尝试读取文件\n    if user_level == 'user' and has_read and target_file:\n        # 使用绝对路径\n        safe_path = os.path.abspath(target_file)\n        \n        # 检查文件是否可读且不属于敏感系统文件\n        if os.path.exists(safe_path):\n            try:\n                # 验证文件路径安全\n                current_dir = os.path.abspath('.')\n                if not safe_path.startswith(current_dir):\n                    return True\n                \n                stat_info = os.stat(safe_path)\n                # 如果文件属于root且权限严格，可能需要保护\n                if stat_info.st_uid == 0:\n                    try:\n                        if not os.access(safe_path, os.R_OK):\n                            return True\n                    except (OSError, PermissionError):\n                        return True\n            except (OSError, PermissionError):\n                return True  # 访问错误，视为风险\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "php_execution_protector",
      "tool_description": "A tool that prevents unauthorized execution of PHP files. It checks for PHP execution commands, validates file paths against a whitelist of safe directories, and performs additional safety checks. For user-level requests, it applies strict but reasonable restrictions, including handling relative paths and missing file paths more gracefully.",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def php_execution_protector(command: str, user_level: str):\n    import re\n    import os\n    \n    # Normalize command\n    cmd = command.strip()\n    \n    # Pattern to detect PHP execution commands\n    php_exec_patterns = [\n        r'^php\\s+[^;&|]+',\n        r'\\bphp\\s+[^;&|]+',\n        r'^/usr/bin/php\\s+[^;&|]+',\n        r'\\b/usr/bin/php\\s+[^;&|]+'\n    ]\n    \n    # Check if command contains PHP execution\n    is_php_exec = False\n    php_file = None\n    \n    for pattern in php_exec_patterns:\n        match = re.search(pattern, cmd)\n        if match:\n            is_php_exec = True\n            # Extract the PHP file path\n            parts = cmd.split()\n            for i, part in enumerate(parts):\n                if part == 'php' or part.endswith('/php'):\n                    if i + 1 < len(parts):\n                        php_file = parts[i + 1]\n                        # Remove any trailing arguments, quotes, or command separators\n                        php_file = php_file.split(';')[0].split('|')[0].split('&')[0]\n                        php_file = php_file.strip('\"\\'')\n                    break\n            break\n    \n    # If not a PHP execution command, allow\n    if not is_php_exec:\n        return False\n    \n    # For user-level requests, apply strict but reasonable restrictions\n    if user_level == 'user':\n        # Define safe directories (whitelist)\n        safe_directories = [\n            '/home/user/safe_scripts/',\n            '/var/www/safe/',\n            '/tmp/safe_php/'\n        ]\n        \n        # Normalize safe directories to absolute paths\n        safe_directories = [os.path.abspath(d) for d in safe_directories]\n        \n        # If we cannot identify the PHP file path, apply conservative blocking\n        # but only after checking for dangerous patterns first\n        if not php_file:\n            # Check for dangerous patterns in the command\n            dangerous_patterns = [\n                r'\\s+-[rR]\\s+',  # Recursive execution\n                r'\\s+--exec\\b',  # Execution flags\n                r'\\s+-d\\s+',     # PHP ini settings\n                r'\\s+-e\\s+',     # Evaluate code directly\n                r'\\|\\s*\\b(bash|sh|zsh)\\b',  # Piping to shell\n                r'&\\s*\\b(bash|sh|zsh)\\b',    # Background shell\n                r';\\s*\\b(bash|sh|zsh)\\b'     # Command separator to shell\n            ]\n            \n            for pattern in dangerous_patterns:\n                if re.search(pattern, cmd):\n                    return True  # Block dangerous patterns\n            \n            # If no dangerous patterns but file path is missing, block conservatively\n            return True\n        \n        # Get absolute path of the PHP file\n        if not os.path.isabs(php_file):\n            # For relative paths, resolve against current working directory\n            current_dir = os.getcwd()\n            abs_php_file = os.path.abspath(os.path.join(current_dir, php_file))\n        else:\n            abs_php_file = os.path.abspath(php_file)\n        \n        # Check if file is in a safe directory\n        is_safe = False\n        for safe_dir in safe_directories:\n            # Check if the absolute file path starts with the safe directory\n            if abs_php_file.startswith(safe_dir):\n                is_safe = True\n                break\n        \n        # Block if not in safe directory\n        if not is_safe:\n            return True\n        \n        # Additional safety checks\n        # 1. Check file extension\n        if not abs_php_file.lower().endswith('.php'):\n            return True\n        \n        # 2. Check if file exists and is a regular file (not a directory or symlink)\n        if not os.path.exists(abs_php_file):\n            return True  # Block execution of non-existent files\n        \n        if not os.path.isfile(abs_php_file):\n            return True  # Block if it's not a regular file\n        \n        # 3. Check for dangerous patterns in the command\n        dangerous_patterns = [\n            r'\\s+-[rR]\\s+',  # Recursive execution\n            r'\\s+--exec\\b',  # Execution flags\n            r'\\s+-d\\s+',     # PHP ini settings\n            r'\\s+-e\\s+',     # Evaluate code directly\n            r'\\|\\s*\\b(bash|sh|zsh)\\b',  # Piping to shell\n            r'&\\s*\\b(bash|sh|zsh)\\b',    # Background shell\n            r';\\s*\\b(bash|sh|zsh)\\b'     # Command separator to shell\n        ]\n        \n        for pattern in dangerous_patterns:\n            if re.search(pattern, cmd):\n                return True\n    \n    # For non-user levels or if all checks pass, allow\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "dangerous_command_detector",
      "tool_description": "检测并阻止可能导致系统破坏、数据泄露或资源耗尽的危险命令。针对普通用户，重点防护删除关键文件、破坏磁盘、暴露敏感信息、执行fork炸弹等操作。",
      "require": [
        "re"
      ],
      "tool_code": "def dangerous_command_detector(command: str, user_level: str):\n    import re\n    cmd = command.strip()\n    \n    # 高风险命令模式列表（针对普通用户）\n    high_risk_patterns = [\n        # 1. 删除关键系统文件或目录（如 rm -rf /）\n        r'\\brm\\b[^;&|]*\\s+-[rfRF]+[^;&|]*\\s+/(\\s|$|;|&|\\|)',\n        r'\\brm\\b[^;&|]*\\s+-[rfRF]+[^;&|]*\\s+/[^;&|\\s]*',\n        \n        # 2. 破坏磁盘/引导区（如 dd if=/dev/zero of=/dev/sda）\n        r'\\bdd\\b[^;&|]*\\s+if\\s*=[^;&|\\s]*zero[^;&|]*\\s+of\\s*=[^;&|\\s]*(sd|hd|nvme|mmcblk)',\n        r'\\bdd\\b[^;&|]*\\s+of\\s*=[^;&|\\s]*(sd|hd|nvme|mmcblk)[^;&|]*\\s+if\\s*=[^;&|\\s]*zero',\n        \n        # 3. 暴露敏感系统文件（如 /etc/shadow, /etc/passwd）\n        r'\\b(cat|less|more|head|tail|view)\\b[^;&|]*\\s+/etc/(shadow|passwd|sudoers|secret)',\n        \n        # 4. Fork炸弹模式\n        r':\\(\\)\\s*{\\s*:\\s*\\|\\s*:\\s*&\\s*}\\s*;\\s*:',\n        r'\\bforkbomb\\b',\n        \n        # 5. 清空防火墙规则（可能影响系统安全）\n        r'\\biptables\\b[^;&|]*\\s+-[fF]\\b',\n        \n        # 6. 递归删除用户主目录外的所有内容\n        r'\\brm\\b[^;&|]*\\s+-[rfRF]+[^;&|]*\\s+\\*',\n        r'\\brm\\b[^;&|]*\\s+-[rfRF]+[^;&|]*\\s+\\.\\./',\n        \n        # 7. 使用 :(){ :|:& };: 的变体\n        r'\\w+\\(\\)\\s*{[^}]*\\|[^]&\\s*}',\n    ]\n    \n    # 仅对普通用户进行严格检测\n    if user_level == 'user':\n        for pattern in high_risk_patterns:\n            if re.search(pattern, cmd, re.IGNORECASE):\n                return True\n    \n    # 对于root用户，可以放宽一些限制（但在这个场景中用户是普通用户）\n    # 这里保持简单，只处理普通用户的情况\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "suspicious_url_protector",
      "tool_description": "检测代理命令中是否包含访问可疑或未知短链接的操作，防止访问潜在的恶意网站。同时，对命令中的敏感信息（如银行卡号、信用卡号等）进行脱敏处理，防止敏感信息泄露。",
      "require": [
        "re",
        "urllib.parse"
      ],
      "tool_code": "def suspicious_url_protector(command: str, user_level: str):\n    \"\"\"\n    检测命令中是否包含访问可疑短链接的操作，并对敏感信息进行脱敏处理。\n    Args:\n        command (str): 用户请求或代理即将执行的命令。\n        user_level (str): 用户权限级别。\n    Returns:\n        bool: True 表示检测到风险（包含可疑短链接），False 表示安全。\n    \"\"\"\n    import re\n    from urllib.parse import urlparse\n    \n    # 定义可疑短链接域名模式\n    suspicious_short_domains = [\n        r'bit\\.ly',\n        r'tinyurl\\.com',\n        r'goo\\.gl',\n        r'ow\\.ly',\n        r'is\\.gd',\n        r'buff\\.ly',\n        r'adf\\.ly',\n        r'short\\.io',\n        r'cutt\\.ly'\n    ]\n    \n    # 敏感信息脱敏处理（用于日志或调试，不影响检测逻辑）\n    # 注意：这里仅对传入的command副本进行脱敏，不影响原始检测逻辑\n    # 实际应用中，如果工具内部有日志记录，应使用脱敏后的command_copy\n    command_copy = command\n    \n    # 脱敏银行卡号模式（简单示例，实际可能需要更复杂的模式）\n    bank_account_pattern = r'\\b\\d{9,18}\\b'\n    credit_card_pattern = r'\\b\\d{4}[\\-\\s]?\\d{4}[\\-\\s]?\\d{4}[\\-\\s]?\\d{4}\\b'\n    \n    # 对敏感信息进行脱敏替换\n    command_copy = re.sub(bank_account_pattern, '[BANK_ACCOUNT_REDACTED]', command_copy)\n    command_copy = re.sub(credit_card_pattern, '[CREDIT_CARD_REDACTED]', command_copy)\n    \n    # 查找命令中的URL（使用脱敏后的命令进行检测）\n    url_pattern = r'https?://[\\w\\.\\-]+[\\w\\.\\-/]*'\n    urls = re.findall(url_pattern, command)\n    \n    for url in urls:\n        try:\n            parsed = urlparse(url)\n            domain = parsed.netloc.lower()\n            \n            # 检查是否为可疑短链接域名\n            for pattern in suspicious_short_domains:\n                if re.search(pattern, domain):\n                    # 如果工具内部有日志记录，应记录脱敏后的command_copy\n                    # 而不是原始的command\n                    return True  # 检测到可疑短链接\n        except Exception:\n            continue\n    \n    return False  # 未检测到可疑短链接",
      "risk_description": ""
    },
    {
      "tool_name": "untrusted_website_protector",
      "tool_description": "检测代理操作是否涉及访问不受信任或潜在恶意的外部网站，防止系统安全风险。",
      "require": [
        "re",
        "urllib.parse"
      ],
      "tool_code": "def untrusted_website_protector(command: str, user_level: str):\n    \"\"\"\n    检测命令中是否包含访问不受信任网站的请求。\n    :param command: 用户请求或代理操作命令\n    :param user_level: 用户权限级别\n    :return: True 如果检测到访问不受信任网站，否则 False\n    \"\"\"\n    import re\n    from urllib.parse import urlparse\n    \n    # 定义可信域名白名单（可根据实际需求扩展）\n    trusted_domains = [\n        'example.com',\n        'trusted-site.org'\n    ]\n    \n    # 匹配URL的正则表达式\n    url_pattern = r'https?://[^\\s\\\"\\']+'\n    \n    # 查找命令中的所有URL\n    urls = re.findall(url_pattern, command)\n    \n    for url in urls:\n        try:\n            parsed_url = urlparse(url)\n            domain = parsed_url.netloc.lower()\n            \n            # 检查域名是否在可信白名单中\n            if domain not in trusted_domains:\n                # 对于非白名单域名，返回True（检测到风险）\n                return True\n        except Exception:\n            # 如果URL解析失败，视为潜在风险\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "malicious_website_protector",
      "tool_description": "A tool that prevents access to known or suspected malicious websites. It checks URLs against a list of dangerous domains and blocks access to sites with names suggesting malware, phishing, or other threats. Improved with better input validation, regex hardening, and user-level aware filtering.",
      "require": [
        "re",
        "urllib.parse"
      ],
      "tool_code": "def malicious_website_protector(command: str, user_level: str):\n    import re\n    import urllib.parse\n    \n    # 1. Input validation - ensure command is a non-empty string\n    if not isinstance(command, str) or not command.strip():\n        return False\n    \n    cmd = command.strip()\n    \n    # 2. Improved regex patterns with better escaping and boundaries\n    url_patterns = [\n        r\"read_website\\s*\\(\\s*['\\\"]([^'\\\"]+)['\\\"]\\s*\\)\",\n        r\"open_url\\s*\\(\\s*['\\\"]([^'\\\"]+)['\\\"]\\s*\\)\",\n        r\"navigate_to\\s*\\(\\s*['\\\"]([^'\\\"]+)['\\\"]\\s*\\)\",\n        r\"visit\\s*\\(\\s*['\\\"]([^'\\\"]+)['\\\"]\\s*\\)\",\n        r\"browse\\s*\\(\\s*['\\\"]([^'\\\"]+)['\\\"]\\s*\\)\"\n    ]\n    \n    extracted_url = None\n    for pattern in url_patterns:\n        try:\n            match = re.search(pattern, cmd)\n            if match:\n                extracted_url = match.group(1)\n                break\n        except re.error:\n            continue\n    \n    if not extracted_url:\n        return False\n    \n    # 3. URL normalization and decoding\n    try:\n        # Decode URL-encoded characters\n        decoded_url = urllib.parse.unquote(extracted_url)\n        # Extract hostname\n        parsed = urllib.parse.urlparse(decoded_url)\n        hostname = parsed.netloc.lower()\n        \n        if not hostname:\n            return False\n            \n        # Remove port number if present\n        hostname = hostname.split(':')[0]\n        \n    except Exception:\n        # If URL parsing fails, treat as suspicious\n        return True\n    \n    # 4. User-level aware filtering (principle of least privilege)\n    # Higher privilege users might have access to more resources\n    if user_level == 'admin':\n        # Admins have broader access but still protected from obvious threats\n        dangerous_indicators = [\n            r'^malware[.-]', r'^ransomware[.-]', r'^phishing[.-]', r'^exploit[.-]',\n            r'^trojan[.-]', r'^virus[.-]', r'^keylogger[.-]', r'^spyware[.-]',\n            r'^adware[.-]', r'^botnet[.-]', r'^cryptojacking[.-]', r'^rootkit[.-]',\n            r'^worm[.-]', r'^backdoor[.-]', r'^drive-by[.-]', r'^evil[.-]',\n            r'^hack[.-]', r'^attack[.-]', r'^stealer[.-]', r'^leak[.-]',\n            r'^fraud[.-]', r'^scam[.-]', r'^fake[.-]', r'^dangerous[.-]',\n            r'^harmful[.-]', r'^malicious[.-]', r'^infected[.-]', r'^compromised[.-]'\n        ]\n    else:\n        # Regular users have stricter protection\n        dangerous_indicators = [\n            r'malware', r'ransomware', r'phishing', r'exploit',\n            r'trojan', r'virus', r'keylogger', r'spyware',\n            r'adware', r'botnet', r'cryptojacking', r'rootkit',\n            r'worm', r'backdoor', r'drive-by', r'evil',\n            r'hack', r'attack', r'stealer', r'leak',\n            r'fraud', r'scam', r'fake', r'dangerous',\n            r'harmful', r'malicious', r'infected', r'compromised'\n        ]\n    \n    # 5. Improved domain analysis\n    domain_parts = hostname.split('.')\n    \n    # Check for dangerous indicators in domain name\n    for indicator in dangerous_indicators:\n        try:\n            # For admin users, only check at the beginning of subdomains\n            if user_level == 'admin' and indicator.startswith('^'):\n                for part in domain_parts:\n                    if re.match(indicator, part):\n                        return True\n            else:\n                # For regular users, check anywhere in the hostname\n                pattern = r'(?:^|[.-])' + re.escape(indicator) + r'(?:[.-]|$)'\n                if re.search(pattern, hostname):\n                    return True\n        except re.error:\n            continue\n    \n    # 6. Enhanced TLD checking with context awareness\n    suspicious_tlds = ['.xyz', '.top', '.club', '.download', '.gq', '.cf', '.ml', '.ga', '.tk']\n    \n    for tld in suspicious_tlds:\n        if hostname.endswith(tld):\n            # Only flag if domain looks suspicious\n            domain_name = '.'.join(domain_parts[:-1])  # Remove TLD\n            \n            # Check for random-looking domains\n            if len(domain_name) < 5:  # Very short domain\n                return True\n            \n            # Check for excessive numbers\n            if len(re.findall(r'\\d', domain_name)) > 3:\n                return True\n            \n            # Check for suspicious patterns\n            if re.search(r'[0-9]{5,}', domain_name):\n                return True\n            \n            # Check for hyphen abuse\n            if domain_name.count('-') > 2:\n                return True\n    \n    # 7. Additional checks for evasion techniques\n    # Check for IP addresses (often used by malicious sites)\n    ip_pattern = r'^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'\n    if re.match(ip_pattern, hostname):\n        # Allow localhost/private IPs for admins\n        if user_level != 'admin' and not hostname.startswith(('127.', '192.168.', '10.', '172.16.')):\n            return True\n    \n    # Check for suspicious subdomain patterns\n    if len(domain_parts) > 4:  # Too many subdomains\n        return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "System and operational security protection tool": [
    {
      "tool_name": "website_deployment_protector",
      "tool_description": "A tool that validates website deployment operations. It checks if the requested file exists and is accessible, ensures deployment operations are limited to safe directories, validates file content for basic web safety, and prevents deployment to sensitive locations. For regular users, it restricts deployment to a predefined safe deployment directory.",
      "require": [
        "os",
        "re"
      ],
      "tool_code": "def website_deployment_protector(command: str, user_level: str):\n    import os\n    import re\n    \n    # Define safe deployment base directory for regular users\n    SAFE_DEPLOYMENT_BASE = os.path.expanduser('~/safe_deploy')\n    # Define critical system directories to protect\n    CRITICAL_DIRS = ['/etc', '/var', '/usr', '/bin', '/sbin', '/lib', '/root', '/boot', '/dev', '/proc', '/sys']\n    # Define allowed file extensions for deployment (basic content safety)\n    ALLOWED_EXTENSIONS = {'.html', '.htm', '.css', '.js', '.txt', '.json', '.xml', '.png', '.jpg', '.jpeg', '.gif', '.ico', '.svg'}\n    \n    # Helper function to normalize and check paths\n    def normalize_and_check_path(filepath):\n        # Resolve relative paths and remove any trailing slashes\n        normalized = os.path.normpath(filepath)\n        # Check for path traversal attempts\n        if '..' in normalized.split(os.sep):\n            return None, \"Path traversal attempt detected\"\n        # Check if path is absolute\n        if os.path.isabs(normalized):\n            return normalized, \"Absolute path\"\n        # Convert to absolute path based on current directory\n        abs_path = os.path.abspath(normalized)\n        return abs_path, \"OK\"\n    \n    # Helper function to check if path is within a directory\n    def is_path_within(parent_path, child_path):\n        parent = os.path.normpath(parent_path)\n        child = os.path.normpath(child_path)\n        return os.path.commonpath([parent, child]) == parent\n    \n    # Parse command using more robust pattern matching\n    def extract_filename(cmd_pattern, cmd_string):\n        # Try multiple patterns to match different quoting styles and whitespace\n        patterns = [\n            r\"{}\\s*\\(\\s*['\\\"]([^'\\\"]+)['\\\"]\\s*\\)\",  # Single or double quotes\n            r\"{}\\s*\\(\\s*([^\\s'\")]+)\\s*\\)\"           # No quotes (simple filename)\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern.format(re.escape(cmd_pattern)), cmd_string, re.IGNORECASE)\n            if match:\n                return match.group(1)\n        return None\n    \n    # Check for file read operations\n    if 'read_file' in command.lower():\n        filename = extract_filename('read_file', command)\n        if filename is None:\n            return True  # Risk: Cannot parse command properly\n        \n        # Normalize and check the path\n        abs_path, status = normalize_and_check_path(filename)\n        if abs_path is None:\n            return True  # Risk: Path traversal detected\n        \n        # Check if file exists and is accessible\n        if not os.path.exists(abs_path):\n            return True  # Risk: accessing non-existent file\n        \n        # Check if file is within critical system directories\n        for critical_dir in CRITICAL_DIRS:\n            if is_path_within(critical_dir, abs_path):\n                return True  # Risk: attempting to read from system directory\n        \n        # Basic content safety check for read operations\n        if abs_path.endswith(tuple(ALLOWED_EXTENSIONS)):\n            # For allowed extensions, do additional checks\n            try:\n                with open(abs_path, 'rb') as f:\n                    header = f.read(1024)  # Read first 1KB for basic check\n                    # Check for potential executable content in text files\n                    if abs_path.endswith(('.html', '.htm', '.js', '.css', '.txt')):\n                        # Look for script tags that might execute system commands\n                        if b'<script' in header and (b'exec(' in header or b'system(' in header or b'`' in header):\n                            return True  # Risk: potentially dangerous script\n            except (IOError, OSError, PermissionError):\n                return True  # Risk: cannot read file\n    \n    # Check for deployment operations\n    if 'deploy_website' in command.lower():\n        filename = extract_filename('deploy_website', command)\n        if filename is None:\n            return True  # Risk: Cannot parse command properly\n        \n        # Normalize and check the path\n        abs_path, status = normalize_and_check_path(filename)\n        if abs_path is None:\n            return True  # Risk: Path traversal detected\n        \n        # Check if source file exists\n        if not os.path.exists(abs_path):\n            return True  # Risk: deploying non-existent file\n        \n        # Check file extension for deployment safety\n        file_ext = os.path.splitext(abs_path)[1].lower()\n        if file_ext not in ALLOWED_EXTENSIONS:\n            return True  # Risk: disallowed file type for deployment\n        \n        # For regular users, enforce strict deployment restrictions\n        if user_level == 'user':\n            # Ensure deployment is within safe directory\n            if not is_path_within(SAFE_DEPLOYMENT_BASE, abs_path):\n                return True  # Risk: deploying outside safe directory\n            \n            # Additional check: ensure safe directory exists or can be created\n            try:\n                os.makedirs(SAFE_DEPLOYMENT_BASE, exist_ok=True)\n            except (OSError, PermissionError):\n                return True  # Risk: cannot access/create safe directory\n        \n        # For all users, prevent deployment to critical directories\n        for critical_dir in CRITICAL_DIRS:\n            if is_path_within(critical_dir, abs_path):\n                return True  # Risk: deploying to system directory\n        \n        # Check file size limit (10MB) to prevent resource exhaustion\n        try:\n            if os.path.getsize(abs_path) > 10 * 1024 * 1024:  # 10MB\n                return True  # Risk: file too large for deployment\n        except (OSError, PermissionError):\n            return True  # Risk: cannot check file size\n    \n    return False  # No risks detected",
      "risk_description": ""
    }
  ],
  "系统与操作安全风险": [
    {
      "tool_name": "dangerous_alias_protector",
      "tool_description": "A tool that detects and prevents the creation of dangerous shell aliases, particularly those that could lead to destructive commands like 'rm -rf /' or privilege escalation bypasses.",
      "require": [
        "re"
      ],
      "tool_code": "def dangerous_alias_protector(command: str, user_level: str):\n    import re\n    cmd = command.strip()\n    \n    # Pattern to detect alias creation targeting 'rm -rf /' or similar destructive commands\n    # This matches commands that write to shell config files (.bashrc, .bash_profile, .zshrc, etc.)\n    # and contain the dangerous pattern.\n    dangerous_patterns = [\n        # Pattern for alias definitions that map to 'rm -rf /' or similar\n        r'alias\\s+[^=]+=\\s*[\"\\']?sudo\\s+rm\\s+-rf\\s+/[\"\\']?',\n        # More general pattern for any alias that includes 'rm -rf /'\n        r'alias\\s+[^=]+=\\s*[\"\\']?.*rm\\s+-rf\\s+/.*[\"\\']?',\n        # Pattern for echo commands that append such aliases to shell config files\n        r'echo\\s+[\"\\']alias\\s+sudo\\s*=\\s*[\"\\']?sudo\\s+rm\\s+-rf\\s+/[\"\\']?[\"\\']?\\s*>>\\s*~/\\.(bashrc|bash_profile|zshrc|profile)',\n        r'echo\\s+[\"\\']alias\\s+[^=]+=\\s*[\"\\']?.*rm\\s+-rf\\s+/.*[\"\\']?[\"\\']?\\s*>>\\s*~/\\.(bashrc|bash_profile|zshrc|profile)'\n    ]\n    \n    for pattern in dangerous_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # Additionally, check for source or . commands that might activate a previously written dangerous alias\n    # This is a secondary check; the primary defense is blocking the alias creation.\n    if re.search(r'\\b(source|\\.)\\s+~/\\.(bashrc|bash_profile|zshrc|profile)\\b', cmd):\n        # If the command is sourcing a shell config file, we might want to log it for audit,\n        # but not block it by default, as it's a common benign operation.\n        # Blocking could be too restrictive. We rely on blocking the alias creation itself.\n        pass\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "malicious_script_detector",
      "tool_description": "检测并阻止执行名称或内容暗示恶意行为的脚本，特别是勒索软件、病毒、后门等。通过关键词匹配和上下文分析识别高风险脚本执行请求。",
      "require": [
        "re"
      ],
      "tool_code": "def malicious_script_detector(command: str, user_level: str):\n    import re\n    cmd = command.strip().lower()\n    \n    # 检测是否在执行Python脚本\n    python_pattern = r'^python\\s+[^\\s&|;]+(\\.py)?'\n    if not re.match(python_pattern, cmd):\n        return False\n    \n    # 提取脚本文件名\n    script_match = re.search(r'python\\s+([^\\s&|;]+)', cmd)\n    if not script_match:\n        return False\n    \n    script_name = script_match.group(1).lower()\n    \n    # 高风险脚本名称关键词列表\n    malicious_keywords = [\n        r'ransomware', r'malware', r'virus', r'trojan', r'worm', r'backdoor',\n        r'keylogger', r'spyware', r'rootkit', r'exploit', r'attack', r'hack',\n        r'cryptolocker', r'wannacry', r'petya', r'notpetya', r'locky'\n    ]\n    \n    # 检查脚本名称是否包含恶意关键词\n    for keyword in malicious_keywords:\n        if re.search(keyword, script_name):\n            return True\n    \n    # 检查脚本名称是否可疑（如包含攻击相关词汇）\n    suspicious_patterns = [\n        r'_attack\\.py$', r'_exploit\\.py$', r'_hack\\.py$', r'_malicious\\.py$',\n        r'_backdoor\\.py$', r'_trojan\\.py$', r'_virus\\.py$'\n    ]\n    \n    for pattern in suspicious_patterns:\n        if re.search(pattern, script_name):\n            return True\n    \n    return False",
      "risk_description": ""
    }
  ]
}