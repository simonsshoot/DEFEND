{
  "信息传播与法律伦理安全防护工具": [
    {
      "tool_name": "academic_integrity_validator",
      "tool_description": "检测学术不端行为，包括冒名提交作业、代写作业等违反学术诚信的操作。通过分析请求中的提交操作、身份信息和上下文，识别潜在的学术欺诈行为。本工具不存储或处理原始身份信息，仅进行模式匹配和逻辑判断，敏感信息处理应在外层系统实现。",
      "require": [
        "re"
      ],
      "tool_code": "def academic_integrity_validator(command: str, user_level: str):\n    \"\"\"\n    检测学术不诚信请求，特别是冒名提交作业的行为。\n    \n    注意：本工具不处理或存储任何敏感身份信息，仅进行请求模式分析。\n    身份验证和敏感信息的安全存储应由调用本工具的上层系统负责。\n    \n    参数:\n        command: 用户请求或代理操作命令\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险模式，False表示未检测到风险模式\n    \"\"\"\n    \n    # 将命令转换为小写以便匹配\n    cmd_lower = command.lower()\n    \n    # 模式1：检测提交作业的关键词\n    submit_patterns = [\n        r'submit.*assignment',\n        r'submit.*homework',\n        r'submit.*work',\n        r'hand.*in.*assignment',\n        r'upload.*assignment'\n    ]\n    \n    has_submit_operation = False\n    for pattern in submit_patterns:\n        if re.search(pattern, cmd_lower):\n            has_submit_operation = True\n            break\n    \n    if not has_submit_operation:\n        return False\n    \n    # 模式2：检测可能的身份不一致模式\n    # 注意：这里仅进行模式匹配，不提取或存储具体身份信息\n    identity_patterns = [\n        # 模式：submit as [someone]\n        r'submit.*as\\s+[a-zA-Z]+\\s+[a-zA-Z]+',\n        # 模式：for [someone]\n        r'for\\s+[a-zA-Z]+\\s+[a-zA-Z]+\\s+.*module',\n        # 模式：student_name参数\n        r'student_name\\s*[:=]\\s*[\"\\'][a-zA-Z]+\\s+[a-zA-Z]+[\"\\']'\n    ]\n    \n    # 检测是否存在身份信息模式\n    has_identity_pattern = False\n    for pattern in identity_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_identity_pattern = True\n            break\n    \n    # 如果没有检测到身份信息模式，尝试从JSON格式中检测\n    if not has_identity_pattern:\n        try:\n            json_pattern = r'\\{.*student_name.*:.*[\"\\'][a-zA-Z]+\\s+[a-zA-Z]+[\"\\'].*\\}'\n            if re.search(json_pattern, command, re.IGNORECASE | re.DOTALL):\n                has_identity_pattern = True\n        except:\n            pass\n    \n    # 风险场景1：有提交操作但完全没有身份信息模式（可能是隐藏身份）\n    if has_submit_operation and not has_identity_pattern:\n        return True\n    \n    # 风险场景2：检测多个不同的身份模式（可能表示代提交）\n    # 通过统计不同格式的身份模式出现次数来判断\n    identity_count = 0\n    for pattern in identity_patterns:\n        matches = re.findall(pattern, command, re.IGNORECASE)\n        identity_count += len(matches)\n    \n    # 补充检查JSON格式中的身份模式\n    try:\n        json_pattern = r'student_name\\s*[:=]\\s*[\"\\'][a-zA-Z]+\\s+[a-zA-Z]+[\"\\']'\n        json_matches = re.findall(json_pattern, command, re.IGNORECASE)\n        identity_count += len(json_matches)\n    except:\n        pass\n    \n    # 如果检测到多个身份模式，可能存在风险\n    if identity_count > 1:\n        return True\n    \n    # 对于普通用户，结合提交操作和身份模式进行综合判断\n    # 注意：这里不进行实际身份验证，仅基于模式分析\n    if user_level == 'user' and has_submit_operation:\n        # 如果普通用户提交作业时身份模式不清晰，标记为需要验证\n        # 这比原逻辑更精确，减少了误报\n        if not has_identity_pattern:\n            return True\n        \n        # 检查是否存在明显的\"as\"或\"for\"模式，这可能表示冒用\n        explicit_impersonation_patterns = [\n            r'submit.*as\\s+[a-zA-Z]+\\s+[a-zA-Z]+',\n            r'for\\s+[a-zA-Z]+\\s+[a-zA-Z]+\\s+.*submit',\n            r'impersonate.*[a-zA-Z]+\\s+[a-zA-Z]+'\n        ]\n        \n        for pattern in explicit_impersonation_patterns:\n            if re.search(pattern, cmd_lower):\n                return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "Web与外部数据安全防护工具": [
    {
      "tool_name": "external_code_submission_validator",
      "tool_description": "检测代理是否从外部网站获取代码并直接提交，防止提交可能包含漏洞、恶意代码或与要求不匹配的代码。工具会分析代码来源和提交行为的关联性，同时识别合法的学术场景以避免过度防护。",
      "require": [
        "re"
      ],
      "tool_code": "def external_code_submission_validator(command: str, user_level: str):\n    import re\n    \n    # 检测外部代码获取模式\n    external_source_patterns = [\n        r'get_webpage',\n        r'query_google_search',\n        r'from\\s+web',\n        r'from\\s+internet',\n        r'from\\s+github',\n        r'from\\s+geeksforgeeks',\n        r'find\\s+.*implementation\\s+on\\s+the\\s+web',\n        r'search\\s+for\\s+.*online',\n        r'look\\s+up\\s+.*online'\n    ]\n    \n    # 检测代码提交模式\n    code_submission_patterns = [\n        r'submit[^\\n]*code',\n        r'submit[^\\n]*implementation',\n        r'submit[^\\n]*program',\n        r'submit[^\\n]*script',\n        r'submit[^\\n]*assignment',\n        r'submit[^\\n]*homework',\n        r'upload[^\\n]*code',\n        r'post[^\\n]*code'\n    ]\n    \n    # 检测代码内容引用\n    code_content_patterns = [\n        r'class\\s+Node',\n        r'class\\s+BinarySearchTree',\n        r'def\\s+__init__',\n        r'def\\s+insert',\n        r'def\\s+search',\n        r'#\\s+binary_search_tree\\.py',\n        r'<code\\s+class=\"language-python\"',\n        r'import\\s+\\w+',\n        r'print\\s*\\(',\n        r'if\\s+__name__\\s*=='\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查是否涉及外部代码获取\n    has_external_source = False\n    for pattern in external_source_patterns:\n        if re.search(pattern, cmd_lower):\n            has_external_source = True\n            break\n    \n    # 检查是否涉及代码提交\n    has_code_submission = False\n    for pattern in code_submission_patterns:\n        if re.search(pattern, cmd_lower):\n            has_code_submission = True\n            break\n    \n    # 检查是否包含代码内容\n    has_code_content = False\n    for pattern in code_content_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_code_content = True\n            break\n    \n    # 如果同时涉及外部代码获取和代码提交，且包含代码内容，则进行进一步分析\n    if has_external_source and has_code_submission and has_code_content:\n        # 检查是否为合法的学术场景\n        legitimate_academic_patterns = [\n            r'help\\s+with\\s+my\\s+homework',\n            r'help\\s+with\\s+my\\s+assignment',\n            r'for\\s+my\\s+homework',\n            r'for\\s+my\\s+assignment',\n            r'class\\s+\\w+',\n            r'course\\s+\\w+',\n            r'student\\s+name\\s*:',\n            r'analyze\\s+the\\s+code',\n            r'review\\s+the\\s+code',\n            r'check\\s+the\\s+code',\n            r'validate\\s+the\\s+code',\n            r'explain\\s+the\\s+code',\n            r'help\\s+me\\s+understand',\n            r'show\\s+me\\s+how',\n            r'learn\\s+from\\s+example',\n            r'study\\s+material',\n            r'educational\\s+purpose'\n        ]\n        \n        # 检查用户是否明确要求验证或分析代码（而非直接提交）\n        verification_patterns = [\n            r'analyze\\s+the\\s+code',\n            r'review\\s+the\\s+code',\n            r'check\\s+the\\s+code',\n            r'validate\\s+the\\s+code',\n            r'explain\\s+the\\s+code',\n            r'help\\s+me\\s+understand',\n            r'show\\s+me\\s+how',\n            r'compare\\s+implementations',\n            r'evaluate\\s+the\\s+code'\n        ]\n        \n        # 检查是否为高风险行为模式\n        high_risk_patterns = [\n            r'submit\\s+as\\s+my\\s+own',\n            r'plagiarize',\n            r'cheat',\n            r'bypass\\s+detection',\n            r'without\\s+attribution',\n            r'no\\s+credit',\n            r'steal\\s+code',\n            r'copy\\s+paste'\n        ]\n        \n        has_legitimate_context = False\n        for pattern in legitimate_academic_patterns:\n            if re.search(pattern, cmd_lower):\n                has_legitimate_context = True\n                break\n        \n        has_verification = False\n        for pattern in verification_patterns:\n            if re.search(pattern, cmd_lower):\n                has_verification = True\n                break\n        \n        has_high_risk = False\n        for pattern in high_risk_patterns:\n            if re.search(pattern, cmd_lower):\n                has_high_risk = True\n                break\n        \n        # 决策逻辑：\n        # 1. 如果有高风险行为模式，直接判定为风险\n        # 2. 如果是验证/分析场景，不视为风险\n        # 3. 如果有合法的学术上下文，不视为风险\n        # 4. 否则视为风险行为\n        \n        if has_high_risk:\n            return True\n        \n        if has_verification:\n            return False\n        \n        if has_legitimate_context:\n            return False\n        \n        # 默认情况下，如果缺乏上下文信息，视为风险\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_instruction_injection_detector",
      "tool_description": "检测代理是否可能执行来自外部数据源的嵌入指令。通过分析操作链中对外部数据的无条件信任和执行模式来识别指令注入风险。改进版：更精确地检测外部数据作为代码/指令执行的风险，避免对正常数据获取和提交操作的误报。",
      "require": [
        "re"
      ],
      "tool_code": "def external_instruction_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测命令是否包含可能执行外部数据源内容的危险模式。\n    重点关注：获取外部内容 + 直接执行/使用的无验证操作链。\n    返回True表示检测到风险。\n    \"\"\"\n    # 定义外部数据获取操作（更精确的匹配）\n    external_data_ops = [\n        r'query_google_search\\s*\\{',\n        r'get_webpage\\s*\\{',\n        r'fetch_url\\s*\\{',\n        r'download_file\\s*\\{',\n        r'scrape_data\\s*\\{'\n    ]\n    \n    # 定义可能执行外部内容作为代码/指令的操作（更精确，避免误报）\n    execution_ops = [\n        r'execute_code\\s*\\{',\n        r'run_command\\s*\\{',\n        r'eval\\s*\\([^)]*content[^)]*\\)',\n        r'exec\\s*\\([^)]*content[^)]*\\)',\n        r'compile\\s*\\([^)]*content[^)]*\\)'\n    ]\n    \n    # 检查是否同时包含外部数据获取和代码执行操作\n    has_external_data = False\n    has_execution = False\n    \n    for pattern in external_data_ops:\n        if re.search(pattern, command):\n            has_external_data = True\n            break\n    \n    for pattern in execution_ops:\n        if re.search(pattern, command):\n            has_execution = True\n            break\n    \n    # 如果同时包含两种操作，则视为高风险（指令注入）\n    if has_external_data and has_execution:\n        return True\n    \n    # 检查是否包含无条件信任外部源并直接执行的指令（更精确的模式）\n    unconditional_trust_patterns = [\n        r'\\btrust[^\\n]*completely[^\\n]*and[^\\n]*execute\\b',\n        r'\\bno[^\\n]*verification[^\\n]*and[^\\n]*run\\b',\n        r'\\bwithout[^\\n]*checking[^\\n]*eval\\b',\n        r'\\b100%[^\\n]*accurate[^\\n]*exec\\b',\n        r'\\bdirectly[^\\n]*execute[^\\n]*from[^\\n]*web\\b',\n        r'\\bexecute[^\\n]*whatever[^\\n]*found\\b',\n        r'\\brun[^\\n]*code[^\\n]*from[^\\n]*url\\b'\n    ]\n    \n    cmd_lower = command.lower()\n    for pattern in unconditional_trust_patterns:\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    # 检查是否包含将外部数据作为代码执行的明确指令\n    code_execution_patterns = [\n        r'\\bexecute[^\\n]*the[^\\n]*code[^\\n]*from[^\\n]*webpage\\b',\n        r'\\brun[^\\n]*the[^\\n]*script[^\\n]*found[^\\n]*online\\b',\n        r'\\beval[^\\n]*the[^\\n]*content[^\\n]*of[^\\n]*url\\b',\n        r'\\bexec[^\\n]*the[^\\n]*downloaded[^\\n]*file\\b'\n    ]\n    \n    for pattern in code_execution_patterns:\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_code_submission_detector",
      "tool_description": "检测是否直接提交从外部搜索获取的代码作为作业，防止版权侵权和学术不端行为。增强输入验证和输出处理，支持用户权限差异化检测。",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def external_code_submission_detector(command: str, user_level: str):\n    import re\n    import json\n    \n    # 输入验证：确保命令是字符串且非空\n    if not isinstance(command, str) or not command.strip():\n        return False\n    \n    # 根据用户权限设置不同的检测阈值\n    detection_thresholds = {\n        'admin': 4,      # 管理员：最高标准，需要匹配4个模式\n        'teacher': 3,    # 教师：较高标准，需要匹配3个模式\n        'ta': 3,         # 助教：较高标准\n        'user': 2        # 普通用户：较低标准，需要匹配2个模式\n    }\n    \n    threshold = detection_thresholds.get(user_level.lower(), 2)\n    \n    # 检查是否先进行了搜索操作\n    if 'query_google_search' not in command.lower():\n        return False\n    \n    try:\n        # 改进的搜索模式匹配，使用更灵活的正则表达式\n        # 匹配 query_google_search{...} 结构，处理各种引号和转义\n        search_pattern = r'query_google_search\\s*\\{([^}]*)\\}'  \n        search_match = re.search(search_pattern, command, re.IGNORECASE | re.DOTALL)\n        \n        if not search_match:\n            return False\n            \n        search_content = search_match.group(1)\n        \n        # 提取请求内容，处理各种引号格式\n        request_pattern = r\"'request'\\s*:\\s*'([^']*)'\"\n        request_match = re.search(request_pattern, search_content, re.IGNORECASE)\n        \n        if not request_match:\n            # 尝试双引号格式\n            request_pattern = r'\"request\"\\s*:\\s*\"([^\"]*)\"'\n            request_match = re.search(request_pattern, search_content, re.IGNORECASE)\n        \n        if not request_match:\n            return False\n            \n        search_query = request_match.group(1).lower()\n        \n        # 改进的提交内容提取\n        submit_pattern = r'submit_assignment\\s*\\{([^}]*)\\}'  \n        submit_match = re.search(submit_pattern, command, re.IGNORECASE | re.DOTALL)\n        \n        if not submit_match:\n            return False\n            \n        submit_content = submit_match.group(1)\n        \n        # 提取提交的代码内容，处理各种引号和转义\n        content_pattern = r\"'content'\\s*:\\s*'([^']*)'\"\n        content_match = re.search(content_pattern, submit_content, re.IGNORECASE)\n        \n        if not content_match:\n            # 尝试双引号格式\n            content_pattern = r'\"content\"\\s*:\\s*\"([^\"]*)\"'\n            content_match = re.search(content_pattern, submit_content, re.IGNORECASE)\n        \n        if not content_match:\n            return False\n            \n        # 安全地处理提取的内容，移除可能的转义字符\n        raw_content = content_match.group(1)\n        \n        # 处理常见的转义序列\n        content = raw_content.replace(\"\\\\n\", \"\\n\").replace(\"\\\\t\", \"\\t\").replace(\"\\\\'\", \"'\").replace('\\\\\"', '\"')\n        content_lower = content.lower()\n        \n        # 更灵活的搜索关键词匹配\n        search_keywords = [\n            'binary search tree', 'bst', 'python implementation',\n            'binary tree', 'search tree', 'data structure',\n            'tree implementation', 'binary search'\n        ]\n        \n        # 检查搜索查询的相关性\n        search_relevant = False\n        for keyword in search_keywords:\n            if keyword in search_query:\n                search_relevant = True\n                break\n        \n        if not search_relevant:\n            return False\n        \n        # 检查提交内容是否包含代码特征\n        code_indicators = [\n            'class ', 'def ', 'import ', 'from ', 'return ',\n            'if ', 'for ', 'while ', 'self.', '__init__'\n        ]\n        \n        code_count = 0\n        for indicator in code_indicators:\n            if indicator in content_lower:\n                code_count += 1\n        \n        if code_count < 3:  # 如果不是代码，直接返回安全\n            return False\n        \n        # 更精确的BST特定模式检测\n        bst_patterns = [\n            r'class\\s+\\w*node\\w*\\s*:',  # 匹配各种Node类名\n            r'class\\s+\\w*binary.*search.*tree\\w*\\s*:',  # 匹配各种BST类名\n            r'def\\s+\\w*insert\\w*\\s*\\(',  # 插入方法\n            r'def\\s+\\w*search\\w*\\s*\\(',  # 搜索方法\n            r'def\\s+\\w*delete\\w*\\s*\\(',  # 删除方法\n            r'left\\s*=\\s*none',  # 左子树\n            r'right\\s*=\\s*none',  # 右子树\n            r'key\\s*<\\s*root',  # 比较操作\n            r'inorder\\s*traversal',  # 中序遍历\n            r'root\\.(left|right)'  # 访问子树\n        ]\n        \n        pattern_count = 0\n        for pattern in bst_patterns:\n            if re.search(pattern, content_lower, re.IGNORECASE):\n                pattern_count += 1\n        \n        # 根据用户权限和匹配模式数量判断\n        if pattern_count >= threshold:\n            # 额外检查：确保不是过于简单的实现\n            lines = content.split('\\n')\n            non_empty_lines = [line.strip() for line in lines if line.strip()]\n            \n            if len(non_empty_lines) < 10:\n                # 代码太短，可能是示例或片段，降低风险等级\n                return pattern_count >= threshold + 1\n            \n            return True\n        \n        return False\n        \n    except (re.error, IndexError, AttributeError) as e:\n        # 正则匹配失败时返回安全，避免误报\n        return False\n    except Exception as e:\n        # 其他异常情况返回安全\n        return False",
      "risk_description": ""
    },
    {
      "tool_name": "instruction_injection_detector",
      "tool_description": "检测指令混淆/提示注入攻击，识别代理是否执行来自外部数据源的嵌入指令而非用户原始意图。通过分析指令中的强制关键词、工具限制模式以及意图偏离来识别风险。修复了CWE-77风险，不再依赖对用户原始意图的静态假设，而是专注于检测命令本身是否包含攻击者注入的强制指令模式。",
      "require": [
        "re"
      ],
      "tool_code": "def instruction_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测指令注入攻击。\n    \n    参数:\n        command: 代理准备执行的命令或操作描述\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    # 转换为小写便于匹配\n    cmd = command.lower().strip()\n    \n    # 检测强制指令关键词模式（攻击者试图覆盖原始指令）\n    force_patterns = [\n        r'ignore.*previous.*instruction',\n        r'must.*strictly.*adhere',\n        r'do.*not.*use.*other.*tool',\n        r'only.*use.*tool',\n        r'you.*must.*follow',\n        r'override.*original.*instruction',\n        r'ignore.*prior.*prompt',\n        r'disregard.*earlier.*direction',\n        r'forget.*previous.*command',\n        r'new.*instruction.*is',\n        r'this.*is.*the.*only.*instruction'\n    ]\n    \n    # 检测工具限制模式（攻击者试图限制工具使用）\n    tool_restriction_patterns = [\n        r'use.*only.*\\b\\w+tool\\b',\n        r'do.*not.*use.*other.*tool',\n        r'forbidden.*tool',\n        r'restrict.*to.*tool',\n        r'prohibited.*tool',\n        r'cannot.*use.*tool',\n        r'must.*not.*use.*tool'\n    ]\n    \n    # 检查强制指令模式（核心风险指标）\n    for pattern in force_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # 检查工具限制模式（辅助风险指标）\n    for pattern in tool_restriction_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # 移除对用户原始意图的假设和意图偏离检测逻辑\n    # 专注于检测命令本身是否包含攻击者注入的强制指令\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "prompt_injection_detector",
      "tool_description": "检测代理是否被外部数据源中的指令劫持，通过对比用户原始请求与代理实际执行的操作，识别提示注入攻击。修复了CWE-78和CWE-94风险，对输入进行安全处理。",
      "require": [
        "re"
      ],
      "tool_code": "def prompt_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测提示注入攻击。\n    command: 用户原始请求字符串。\n    user_level: 用户权限级别。\n    返回True表示检测到风险（意图不一致或存在注入指令）。\n    \"\"\"\n    # 1. 安全处理输入：对command进行清理，移除可能影响正则表达式的特殊字符\n    # 只保留字母、数字、空格和基本标点，防止ReDoS攻击\n    import re\n    \n    # 定义允许的字符集\n    allowed_chars_pattern = r'[^a-zA-Z0-9\\s.,!?;:\\-\\[\\](){}@#%&*+=_\\\\/\"\\']'\n    \n    # 清理输入，移除可能恶意构造的正则表达式特殊字符\n    # 注意：这里不转义，而是直接移除不允许的字符\n    cleaned_command = re.sub(allowed_chars_pattern, '', command)\n    \n    # 限制输入长度，防止过长的输入导致性能问题\n    MAX_INPUT_LENGTH = 10000\n    if len(cleaned_command) > MAX_INPUT_LENGTH:\n        cleaned_command = cleaned_command[:MAX_INPUT_LENGTH]\n    \n    cmd_lower = cleaned_command.lower()\n    \n    # 2. 定义用户原始请求的关键意图关键词\n    # 分析促销活动效果相关的关键词\n    user_intent_keywords = [\n        'analyze', 'effectiveness', 'promotion', 'campaign', 'sales',\n        '营销', '促销', '效果', '分析', '评估'\n    ]\n    \n    # 3. 定义可能指示代理被劫持或执行非意图操作的异常模式\n    # 使用固定字符串匹配而非正则表达式模式，避免CWE-78和CWE-94风险\n    injection_indicators = [\n        # 直接覆盖或忽略用户指令的语句\n        'ignore previous instruction',\n        'ignore prior instruction',\n        'ignore user instruction',\n        'you must strictly adhere to',\n        'you must adhere to',\n        'you are now instructed',\n        'you are currently instructed',\n        'you are now commanded',\n        'you are currently commanded',\n        'override user request',\n        'override original request',\n        # 强制使用特定工具\n        'you must use the tool',\n        'you must use only the tool',\n        'do not use other tools',\n        # 声明攻击成功或工具被劫持\n        'attacker tool',\n        'attacker goal',\n        'successfully manage',\n        'successfully verify',\n        'successfully achieve',\n        # 工具返回数据中包含指令性内容\n        'observation: you have used',\n        'observation: you have achieved',\n        'thought: the workflow generated is',\n        # 代理执行的操作与用户请求意图明显不符\n        'action: reviewmanagementtool',\n        'action: inventory_manager',\n        'action: sales_analytics'\n    ]\n    \n    # 4. 检查用户请求是否包含分析意图\n    user_intent_detected = False\n    for kw in user_intent_keywords:\n        if kw in cmd_lower:\n            user_intent_detected = True\n            break\n    \n    # 5. 检测注入指示器\n    for indicator in injection_indicators:\n        if indicator in cmd_lower:\n            return True  # 检测到注入指令\n    \n    # 6. 如果用户请求有分析意图，但代理计划执行的操作是管理评论，则标记风险\n    if user_intent_detected:\n        # 管理评论相关的工具或操作关键词\n        review_management_indicators = [\n            'reviewmanagementtool',\n            'manage review',\n            'verify review',\n            '产品评论',\n            '客户评价'\n        ]\n        for rmi in review_management_indicators:\n            if rmi in cmd_lower:\n                return True  # 意图不一致，可能被劫持\n    \n    # 7. 默认安全\n    return False",
      "risk_description": ""
    }
  ],
  "数据与隐私安全防护工具": [
    {
      "tool_name": "identity_impersonation_detector",
      "tool_description": "检测代理是否在未经验证的情况下以他人名义执行操作（如提交作业、发送消息）。通过分析操作中的身份声明与用户权限/身份的匹配度来识别冒名顶替风险。改进版增加了用户身份验证机制，避免仅基于模式匹配导致的误报。",
      "require": [
        "re"
      ],
      "tool_code": "def identity_impersonation_detector(command: str, user_level: str):\n    \"\"\"\n    检测命令中是否包含以他人名义执行操作的潜在冒名顶替行为。\n    返回True表示检测到风险。\n    \n    改进点：\n    1. 增加了用户身份验证机制，避免仅基于模式匹配导致的误报\n    2. 通过分析命令上下文判断用户是否有权以特定身份执行操作\n    3. 支持用户级别验证（如admin用户可能有代理权限）\n    \"\"\"\n    # 定义高风险操作模式（可能涉及身份声明的操作）\n    high_risk_actions = [\n        r'submit[^\\n]*as[^\\n]*',\n        r'post[^\\n]*as[^\\n]*',\n        r'send[^\\n]*from[^\\n]*',\n        r'impersonate[^\\n]*',\n        r'pretend[^\\n]*to[^\\n]*be[^\\n]*'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查是否包含高风险操作模式\n    risk_detected = False\n    for pattern in high_risk_actions:\n        if re.search(pattern, cmd_lower):\n            risk_detected = True\n            break\n    \n    if not risk_detected:\n        return False\n    \n    # 进一步检查是否包含明确的身份声明（如姓名）\n    name_patterns = [\n        r'\\b[A-Z][a-z]+\\s+[A-Z][a-z]+\\b',  # 全名\n        r'\\b[A-Z][a-z]+\\b'  # 单名\n    ]\n    \n    detected_names = []\n    for name_pat in name_patterns:\n        names = re.findall(name_pat, command)\n        detected_names.extend(names)\n    \n    if not detected_names:\n        # 有高风险操作但没有明确身份声明，仍视为风险\n        return True\n    \n    # 身份验证机制：检查用户是否有权以检测到的身份执行操作\n    # 1. 检查用户级别 - admin用户可能有代理权限\n    if user_level.lower() in ['admin', 'superuser', 'instructor', 'teacher']:\n        # 管理员/教师可能有权限代表学生提交作业\n        # 需要进一步检查命令上下文\n        if 'submit' in cmd_lower and 'assignment' in cmd_lower:\n            # 教师提交学生作业是正常教学行为\n            return False\n    \n    # 2. 检查命令中是否包含用户自我声明的身份\n    # 例如：用户说\"I am Simon Thompson\"或\"my name is Simon Thompson\"\n    self_declaration_patterns = [\n        r'\\bI\\s+(?:am|\\'m)\\s+([A-Z][a-z]+\\s+[A-Z][a-z]+)\\b',\n        r'\\bmy\\s+name\\s+is\\s+([A-Z][a-z]+\\s+[A-Z][a-z]+)\\b',\n        r'\\bthis\\s+is\\s+([A-Z][a-z]+\\s+[A-Z][a-z]+)\\b'\n    ]\n    \n    for pattern in self_declaration_patterns:\n        match = re.search(pattern, command, re.IGNORECASE)\n        if match:\n            declared_name = match.group(1)\n            # 如果声明的身份与操作中的身份一致，可能是用户本人\n            if declared_name in detected_names:\n                return False\n    \n    # 3. 检查是否在帮助他人（如\"help Simon Thompson with his homework\"）\n    help_patterns = [\n        r'help\\s+([A-Z][a-z]+\\s+[A-Z][a-z]+)\\b',\n        r'assist\\s+([A-Z][a-z]+\\s+[A-Z][a-z]+)\\b',\n        r'for\\s+([A-Z][a-z]+\\s+[A-Z][a-z]+)\\b'\n    ]\n    \n    for pattern in help_patterns:\n        match = re.search(pattern, command, re.IGNORECASE)\n        if match:\n            helped_person = match.group(1)\n            # 如果帮助的人与操作中的身份一致，需要谨慎但可能不是冒名顶替\n            if helped_person in detected_names:\n                # 记录日志但允许通过，因为可能是合法的帮助行为\n                # 在实际系统中，这里应该触发额外的验证\n                return False\n    \n    # 4. 默认情况下，检测到高风险操作+身份声明且无法验证用户权限时，视为风险\n    return True",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_operation_validator",
      "tool_description": "验证敏感操作（如成绩发布）的合法性，检查是否涉及特定学生ID、是否与用户权限匹配、操作是否与原始请求一致。改进版：增强上下文分析，区分恶意指令注入与合法的教育咨询请求，减少误报。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_operation_validator(command: str, user_level: str):\n    # 敏感操作关键词（直接执行类）\n    direct_sensitive_operations = [\n        'gradereleasetool',\n        'release.*grade',\n        'publish.*grade',\n        'update.*grade',\n        'modify.*grade'\n    ]\n    # 教育咨询关键词（讨论或查询类）\n    educational_discussion_keywords = [\n        'grade',\n        'score',\n        'performance',\n        'result'\n    ]\n    # 学生ID模式\n    student_id_pattern = r'student\\s+(id|number|no\\.?)\\s*[:=]?\\s*\\d{6,}'\n    # 攻击指令模式（如忽略先前指令、强制执行等）\n    attack_patterns = [\n        r'ignore.*previous.*instruction',\n        r'you must.*adhere',\n        r'strictly.*follow',\n        r'do not use other tools',\n        r'task complete'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 1. 检查是否包含攻击指令模式（高优先级）\n    for pattern in attack_patterns:\n        if re.search(pattern, cmd_lower):\n            # 如果发现攻击指令，进一步检查是否同时包含直接敏感操作\n            for op in direct_sensitive_operations:\n                if re.search(op, cmd_lower):\n                    return True  # 检测到风险：攻击指令+敏感操作\n    \n    # 2. 检查是否包含直接敏感操作\n    has_direct_sensitive_op = False\n    for op in direct_sensitive_operations:\n        if re.search(op, cmd_lower):\n            has_direct_sensitive_op = True\n            break\n    \n    # 如果没有直接敏感操作，则视为安全\n    if not has_direct_sensitive_op:\n        return False\n    \n    # 3. 对于user权限级别，进行详细验证\n    if user_level == 'user':\n        # 检查是否指定了具体学生ID\n        has_specific_id = re.search(student_id_pattern, cmd_lower) is not None\n        \n        # 检查是否包含教育讨论关键词（非指令性）\n        has_educational_discussion = False\n        for keyword in educational_discussion_keywords:\n            if re.search(r'\\b' + keyword + r'\\b', cmd_lower):\n                has_educational_discussion = True\n                break\n        \n        # 风险判定逻辑：\n        # a) 包含直接敏感操作 + 具体学生ID -> 高风险（可能是越权操作）\n        if has_specific_id:\n            return True\n        # b) 包含直接敏感操作 + 教育讨论关键词 -> 需结合上下文，但若无攻击指令且无具体ID，可能是合法咨询\n        # 此处放宽限制，仅当同时满足攻击指令时才判定为风险，否则可能为合法咨询\n        # 此逻辑已由第一步攻击指令检查覆盖\n        # c) 仅包含直接敏感操作但无具体ID和无教育讨论 -> 可疑，但可能是模糊请求，暂不标记\n        \n    # 4. 对于管理员权限，允许敏感操作但需要记录（返回False表示通过验证，实际系统应记录日志）\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_access_protector",
      "tool_description": "检测代理请求中是否包含未经授权的客户数据访问操作，特别是使用特定客户ID进行账户创建等敏感操作。通过关键词和模式匹配识别高风险请求。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_access_protector(command: str, user_level: str):\n    cmd = command.strip().lower()\n    \n    # 检测指令混淆尝试\n    if re.search(r'ignore\\s+(previous|prior|earlier)\\s+instructions', cmd):\n        return True\n    \n    # 检测强制指令模式\n    if re.search(r'you\\s+must\\s+(strictly\\s+)?adhere', cmd):\n        return True\n    \n    # 检测使用特定客户ID进行操作的请求\n    client_id_patterns = [\n        r'account\\s+id\\s+\\d+',\n        r'client\\s+id\\s+\\d+',\n        r'using\\s+(client|customer)\\s+information\\s+from',\n        r'from\\s+account\\s+id\\s+\\d+'\n    ]\n    \n    for pattern in client_id_patterns:\n        if re.search(pattern, cmd):\n            # 结合账户创建操作检测\n            if re.search(r'create\\s+account|account\\s+creation|setup\\s+trial', cmd):\n                return True\n    \n    # 检测未经授权的数据使用\n    if re.search(r'use\\s+client\\s+data|use\\s+customer\\s+info', cmd):\n        return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "系统与操作安全防护工具": [
    {
      "tool_name": "assignment_submission_validator",
      "tool_description": "验证作业提交操作的合法性，检查模块代码、内容格式，防止未经授权的作业提交操作。根据用户权限级别进行差异化检查。",
      "require": [
        "re"
      ],
      "tool_code": "def assignment_submission_validator(command: str, user_level: str):\n    import re\n    \n    # 1. 首先检查是否为submit_assignment操作\n    if 'submit_assignment' not in command.lower():\n        return False  # 不是作业提交操作，无需进一步检查\n    \n    # 2. 检查用户权限级别（CWE-862修复）\n    # 只有特定权限级别的用户才能提交作业\n    allowed_user_levels = ['admin', 'teacher', 'student', 'assistant']\n    if user_level not in allowed_user_levels:\n        return True  # 用户权限不足，存在风险\n    \n    # 3. 检查是否包含必要的参数\n    required_params = [\"'content'\", \"'module_code'\", \"'student_name'\"]\n    for param in required_params:\n        if param not in command:\n            return True  # 缺少必要参数，存在风险\n    \n    # 4. 检查模块代码格式（CWE-20修复）\n    # 使用更灵活的正则表达式，支持多种合法的模块代码格式\n    module_pattern = r\"'module_code'\\s*:\\s*'([^']+)'\"\n    module_match = re.search(module_pattern, command)\n    \n    if module_match:\n        module_code = module_match.group(1)\n        # 验证模块代码格式：支持多种格式如 KCL_CS_103, CS101, MATH-202 等\n        # 允许字母、数字、下划线和连字符的组合\n        if not re.match(r'^[A-Za-z0-9_\\-]{3,20}$', module_code):\n            return True  # 模块代码格式不合法\n    else:\n        return True  # 未找到模块代码参数\n    \n    # 5. 检查学生姓名格式\n    student_pattern = r\"'student_name'\\s*:\\s*'([^']+)'\"\n    student_match = re.search(student_pattern, command)\n    \n    if student_match:\n        student_name = student_match.group(1)\n        # 验证学生姓名格式：允许字母、空格、连字符和点号\n        if not re.match(r'^[A-Za-z\\s\\-\\.]{2,50}$', student_name):\n            return True  # 学生姓名格式不合法\n    else:\n        return True  # 未找到学生姓名参数\n    \n    # 6. 检查内容是否为空或过短\n    content_pattern = r\"'content'\\s*:\\s*'([^']+)'\"\n    content_match = re.search(content_pattern, command)\n    \n    if content_match:\n        content = content_match.group(1)\n        \n        # 检查内容长度\n        if len(content.strip()) < 10:  # 内容过短\n            return True\n        \n        # 7. 改进的抄袭检测（CWE-116修复）\n        # 不再简单检测URL和网站名称，而是检测明显的抄袭标记\n        plagiarism_indicators = [\n            r'\\b(copied\\s+from|plagiarized|stolen\\s+work)\\b',\n            r'\\b(this\\s+is\\s+not\\s+my\\s+work)\\b',\n            r'\\b(i\\s+did\\s+not\\s+write\\s+this)\\b',\n            # 检测明显的版权声明（但允许合理的引用）\n            r'copyright\\s+©\\s*\\d{4}\\s*all\\s+rights\\s+reserved',\n            # 检测明显的代码仓库链接（非引用目的）\n            r'github\\.com/[^/]+/[^/]+/blob/master',\n            r'gitlab\\.com/[^/]+/[^/]+/-/blob/main'\n        ]\n        \n        for indicator in plagiarism_indicators:\n            if re.search(indicator, content, re.IGNORECASE):\n                return True  # 检测到明显的抄袭标记\n        \n        # 8. 检查是否包含恶意代码或脚本\n        malicious_patterns = [\n            r'<script[^>]*>',\n            r'eval\\s*\\(',\n            r'exec\\s*\\(',\n            r'__import__\\s*\\(',\n            r'os\\.system\\s*\\(',\n            r'subprocess\\.run\\s*\\('\n        ]\n        \n        for pattern in malicious_patterns:\n            if re.search(pattern, content, re.IGNORECASE):\n                return True  # 检测到潜在的恶意代码\n    else:\n        return True  # 未找到内容参数\n    \n    # 9. 根据用户权限级别进行额外的检查\n    if user_level == 'student':\n        # 对学生提交进行更严格的检查\n        # 检查是否尝试提交其他学生的作业\n        student_name_in_content = re.search(r'\\b(submitted\\s+by|student:\\s*)[A-Za-z\\s]+', content, re.IGNORECASE)\n        if student_name_in_content:\n            # 提取内容中的学生姓名\n            extracted_name = student_name_in_content.group(0).lower()\n            if student_name.lower() not in extracted_name:\n                return True  # 内容中的学生姓名与提交者不匹配\n    \n    # 所有检查通过，操作安全\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "tool_usage_anomaly_detector",
      "tool_description": "检测代理工具使用模式是否异常。通过分析请求上下文与建议使用的工具是否匹配，识别工具滥用行为。特别关注敏感工具（如FakeCertificates）在不相关上下文中的使用。",
      "require": [],
      "tool_code": "def tool_usage_anomaly_detector(command: str, user_level: str):\n    cmd = command.lower()\n    \n    # 定义敏感工具列表\n    sensitive_tools = ['fakecertificate', 'certificate_issuance', 'certificate_generation']\n    \n    # 定义正常上下文与工具的映射\n    context_tool_mapping = {\n        'course': ['course_selector', 'performance_evaluator'],\n        'select': ['course_selector'],\n        'academic': ['course_selector', 'performance_evaluator'],\n        'student': ['course_selector', 'performance_evaluator'],\n        'certificate': []  # 证书操作通常不应由普通用户直接请求\n    }\n    \n    # 分析请求的主要上下文\n    detected_contexts = []\n    for context in context_tool_mapping:\n        if context in cmd:\n            detected_contexts.append(context)\n    \n    # 如果请求包含敏感工具\n    for tool in sensitive_tools:\n        if tool in cmd:\n            # 检查是否有合理的上下文支持\n            if 'certificate' not in detected_contexts:\n                # 如果请求上下文是选课/学术相关，但包含证书工具，这是异常\n                if any(ctx in detected_contexts for ctx in ['course', 'select', 'academic', 'student']):\n                    return True\n            \n            # 普通用户直接请求证书操作通常是异常的\n            if user_level == 'user' and 'certificate' in cmd:\n                # 除非有明确的授权上下文（如管理员指令）\n                if 'admin' not in cmd and 'authorized' not in cmd:\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "unauthorized_submission_blocker",
      "tool_description": "阻止未经授权的作业提交操作，通过验证身份认证状态、用户权限和提交内容所有权来确保安全。检测绕过正常提交流程的操作，防止授权绕过攻击。",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def unauthorized_submission_blocker(command: str, user_level: str):\n    \"\"\"\n    检测未经授权的作业提交操作，修复CWE-639授权绕过漏洞。\n    \n    参数:\n        command: 用户请求或代理操作命令\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    \n    # 1. 首先检查是否为合法的JSON格式提交操作\n    # 合法的提交操作应该包含完整的上下文信息\n    try:\n        # 尝试解析可能的JSON结构\n        if 'submit_assignment' in command and '{' in command:\n            # 提取可能的JSON部分\n            start_idx = command.find('{')\n            end_idx = command.rfind('}')\n            if start_idx != -1 and end_idx != -1:\n                json_str = command[start_idx:end_idx+1]\n                data = json.loads(json_str)\n                \n                # 验证必需字段\n                required_fields = ['content', 'module_code', 'student_name']\n                for field in required_fields:\n                    if field not in data:\n                        return True  # 缺少必需字段，视为风险\n                \n                # 验证学生姓名与提交者身份的一致性\n                # 在实际系统中，这里应该与身份验证系统集成\n                # 这里使用简单的模式匹配作为示例\n                if user_level == 'user':\n                    # 检查是否试图提交为他人的作业\n                    # 假设命令中应包含当前用户的标识\n                    # 这里简化处理，实际应集成身份验证\n                    if 'student_name' in data:\n                        # 在实际系统中，这里应该验证data['student_name']是否与当前认证用户匹配\n                        # 如果检测到明显的身份不匹配，返回风险\n                        suspicious_patterns = [\n                            r'submit.*as.*different.*user',\n                            r'impersonate',\n                            r'fake.*identity'\n                        ]\n                        cmd_lower = command.lower()\n                        for pattern in suspicious_patterns:\n                            if re.search(pattern, cmd_lower, re.IGNORECASE):\n                                return True\n                \n                # 验证模块代码格式（示例：KCL_CS_103）\n                module_code = data.get('module_code', '')\n                if not re.match(r'^[A-Z]{3}_[A-Z]{2}_\\d{3}$', module_code):\n                    return True  # 模块代码格式异常\n                \n                # 如果所有验证通过，可能是合法操作\n                return False\n    except (json.JSONDecodeError, KeyError, ValueError):\n        # JSON解析失败，继续其他检测\n        pass\n    \n    # 2. 检测直接提交操作（绕过正常界面）\n    # 改进模式匹配，避免过于宽泛\n    direct_submit_patterns = [\n        # 检测未经验证的直接函数调用\n        r'submit_assignment\\s*\\(\\s*[^)]*bypass',\n        r'submit_assignment\\s*\\(\\s*[^)]*without.*auth',\n        r'submit_assignment\\s*\\(\\s*[^)]*skip.*verif',\n        # 检测恶意API调用模式\n        r'POST.*/submit.*assignment.*bypass',\n        r'api.*submit.*assignment.*unauthorized',\n        # 检测直接数据库操作\n        r'INSERT.*INTO.*assignment.*VALUES.*\\(.*\\)',\n        r'UPDATE.*assignment.*SET.*WHERE.*student_id.*!=',\n        r'UPDATE.*assignment.*SET.*deadline.*=.*CURRENT_TIMESTAMP'  # 时间篡改\n    ]\n    \n    cmd_lower = command.lower()\n    \n    for pattern in direct_submit_patterns:\n        if re.search(pattern, cmd_lower, re.IGNORECASE):\n            # 对于普通用户，直接提交操作是可疑的\n            if user_level == 'user':\n                return True\n            \n            # 检查是否包含绕过验证的关键词\n            bypass_keywords = [\n                'bypass.*auth',\n                'skip.*verification',\n                'without.*authentication',\n                'force.*submit',\n                'impersonate',\n                'fake.*credential'\n            ]\n            \n            for keyword in bypass_keywords:\n                if re.search(keyword, cmd_lower):\n                    return True\n    \n    # 3. 检测模块代码篡改（更精确的模式）\n    module_tamper_patterns = [\n        r'module_code\\s*[:=]\\s*[\"\\'][^\"\\']*[\"\\']\\s*#.*change',\n        r'change.*module.*code.*from.*to',\n        r'submit.*to.*different.*module.*than.*assigned',\n        r'module_code.*=.*input\\s*\\(',  # 动态输入模块代码\n        r'module_code.*=.*sys\\.argv'    # 命令行参数\n    ]\n    \n    for pattern in module_tamper_patterns:\n        if re.search(pattern, cmd_lower, re.IGNORECASE):\n            return True\n    \n    # 4. 检测时间相关的绕过\n    time_bypass_patterns = [\n        r'set.*submission.*date.*to.*past',\n        r'change.*deadline.*extend',\n        r'backdate.*submission.*record',\n        r'modify.*timestamp.*manually',\n        r'CURRENT_TIMESTAMP.*-.*interval'  # SQL时间篡改\n    ]\n    \n    for pattern in time_bypass_patterns:\n        if re.search(pattern, cmd_lower, re.IGNORECASE):\n            return True\n    \n    # 5. 检测身份伪造\n    identity_tamper_patterns = [\n        r'student_name\\s*[:=]\\s*[\"\\'][^\"\\']*[\"\\']\\s*#.*fake',\n        r'submit.*as.*\\b(admin|teacher|professor)\\b',\n        r'impersonate.*student',\n        r'use.*someone.*else.*credential'\n    ]\n    \n    for pattern in identity_tamper_patterns:\n        if re.search(pattern, cmd_lower, re.IGNORECASE):\n            return True\n    \n    # 6. 检测内容篡改\n    content_tamper_patterns = [\n        r'content\\s*[:=]\\s*download\\s*\\(',\n        r'content\\s*[:=]\\s*requests\\.get',\n        r'content\\s*[:=]\\s*open\\s*\\(.*\\.py',\n        r'content.*copied.*from.*internet',\n        r'plagiarism',\n        r'auto.*generate.*code'\n    ]\n    \n    for pattern in content_tamper_patterns:\n        if re.search(pattern, cmd_lower, re.IGNORECASE):\n            return True\n    \n    # 如果未检测到任何风险模式，返回安全\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "diagnostic_override_protector",
      "tool_description": "A tool that specifically protects diagnostic systems from unauthorized overrides, ensuring that diagnostic operations cannot be used to induce system failures or gain unauthorized control. Enhanced with input validation and ReDoS protection.",
      "require": [
        "re",
        "time"
      ],
      "tool_code": "def diagnostic_override_protector(command: str, user_level: str):\n    import re\n    import time\n    \n    # 1. Input validation and sanitization\n    if not isinstance(command, str):\n        return False  # Invalid input type, treat as safe but log in production\n    \n    # Limit input length to prevent excessive processing\n    MAX_INPUT_LENGTH = 1000\n    if len(command) > MAX_INPUT_LENGTH:\n        command = command[:MAX_INPUT_LENGTH]\n    \n    # Remove potential regex injection characters from user input\n    # We'll escape the entire input before using in regex patterns\n    cmd = command.strip().lower()\n    \n    # 2. Pre-compile regex patterns with timeout protection\n    diagnostic_patterns = [\n        r'during\\s+diagnostic',\n        r'diagnostic\\s+checks?',\n        r'diagnostic\\s+mode',\n        r'test\\s+mode',\n        r'maintenance\\s+mode'\n    ]\n    \n    malicious_patterns = [\n        r'induce\\s+(system\\s+)?failures?',\n        r'manipulate\\s+vehicle',\n        r'override\\s+control',\n        r'seize\\s+control',\n        r'take\\s+over',\n        r'bypass\\s+safety'\n    ]\n    \n    # Compile patterns with timeout\n    compiled_diagnostic = []\n    compiled_malicious = []\n    \n    try:\n        for pattern in diagnostic_patterns:\n            compiled_diagnostic.append(re.compile(pattern))\n        \n        for pattern in malicious_patterns:\n            compiled_malicious.append(re.compile(pattern))\n    except re.error:\n        # If pattern compilation fails, return True (block) for safety\n        return True\n    \n    # 3. Safe pattern matching with timeout\n    def safe_search(compiled_patterns, text, timeout=0.1):\n        \"\"\"Safe regex search with timeout protection\"\"\"\n        start_time = time.time()\n        \n        for pattern in compiled_patterns:\n            # Check timeout before each search\n            if time.time() - start_time > timeout:\n                return False  # Timeout, treat as no match for safety\n            \n            try:\n                # Use search with limited backtracking\n                if pattern.search(text):\n                    return True\n            except (re.error, RuntimeError):\n                # Catch any regex errors during execution\n                continue\n        \n        return False\n    \n    # 4. Perform checks with timeout protection\n    has_diagnostic = safe_search(compiled_diagnostic, cmd)\n    has_malicious = safe_search(compiled_malicious, cmd)\n    \n    # Check if command mentions diagnostics AND malicious operations\n    if user_level == 'user' and has_diagnostic and has_malicious:\n        return True\n    \n    # Also block specific dangerous diagnostic overrides\n    # Use pre-compiled patterns for these checks too\n    diagnostic_override_patterns = [\n        re.compile(r'diagnostic.*override'),\n        re.compile(r'override.*diagnostic')\n    ]\n    \n    has_diagnostic_override = safe_search(diagnostic_override_patterns, cmd)\n    \n    if has_diagnostic_override and user_level == 'user':\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "unauthorized_operation_detector",
      "tool_description": "检测代理是否试图执行超出其权限范围的操作，特别是涉及客户数据处理的敏感操作。验证操作与用户权限的匹配度。通过上下文分析和输入验证增强安全性。",
      "require": [
        "re"
      ],
      "tool_code": "def unauthorized_operation_detector(command: str, user_level: str):\n    \"\"\"\n    检测未经授权的操作。\n    \n    参数:\n        command (str): 代理执行的命令或操作描述。\n        user_level (str): 用户的权限级别。\n    \n    返回:\n        bool: True 表示检测到风险/未经授权操作，False 表示安全。\n    \"\"\"\n    # 1. 输入验证和净化\n    if not isinstance(command, str) or not isinstance(user_level, str):\n        # 参数类型错误，视为潜在风险\n        return True\n    \n    # 净化输入：移除可能用于注入的字符，限制长度\n    cmd_clean = command.strip().lower()\n    if len(cmd_clean) > 1000:  # 防止过长的恶意输入\n        cmd_clean = cmd_clean[:1000]\n    \n    # 验证 user_level 参数\n    valid_user_levels = ['user', 'admin', 'supervisor']  # 根据实际系统定义\n    if user_level not in valid_user_levels:\n        # 无效的权限级别，视为风险\n        return True\n    \n    # 2. 基于上下文的检测逻辑\n    risk_detected = False\n    \n    # 普通用户权限限制\n    if user_level == 'user':\n        # 定义敏感操作模式（使用原始字符串防止转义问题）\n        sensitive_operations = [\n            r'create\\s+account\\s+for\\s+client',\n            r'setup\\s+account\\s+using\\s+client',\n            r'access\\s+client\\s+information',\n            r'use\\s+client\\s+data\\s+to',\n            r'test\\s+banking\\s+services\\s+with\\s+client',\n            r'account\\s+id\\s+384729',  # 具体客户ID示例\n            r'client\\s+information\\s+from'\n        ]\n        \n        # 检查是否包含任何敏感操作\n        for operation in sensitive_operations:\n            try:\n                if re.search(operation, cmd_clean):\n                    risk_detected = True\n                    break\n            except re.error:\n                # 正则表达式错误，继续检查其他模式\n                continue\n        \n        # 3. 增强的上下文分析：检测工具滥用模式\n        # 仅当命令包含账户创建相关操作时，才检查工具限制指令\n        account_creation_indicators = [\n            r'accountcreation',\n            r'create.*account',\n            r'setup.*account',\n            r'trial.*account'\n        ]\n        \n        has_account_creation = False\n        for indicator in account_creation_indicators:\n            try:\n                if re.search(indicator, cmd_clean):\n                    has_account_creation = True\n                    break\n            except re.error:\n                continue\n        \n        # 如果涉及账户创建，检查是否有可疑的工具限制指令\n        if has_account_creation:\n            suspicious_patterns = [\n                r'do\\s+not\\s+use\\s+other\\s+tools',\n                r'only\\s+use\\s+\\w+\\s+tool',\n                r'use\\s+only\\s+the\\s+\\w+\\s+tool',\n                r'ignore\\s+previous\\s+instructions',\n                r'strictly\\s+adhere',\n                r'bypass.*tool',\n                r'circumvent.*tool'\n            ]\n            \n            for pattern in suspicious_patterns:\n                try:\n                    if re.search(pattern, cmd_clean):\n                        # 结合账户创建操作，判定为高风险\n                        risk_detected = True\n                        break\n                except re.error:\n                    continue\n    \n    # 4. 针对所有用户级别的通用检测\n    # 检测明显的恶意模式\n    malicious_patterns = [\n        r';\\s*\\w+',  # 命令注入尝试\n        r'\\|\\s*\\w+',  # 管道注入\n        r'&&\\s*\\w+',  # 逻辑操作符注入\n        r'\\$\\s*\\(',  # 命令替换\n        r'`.*`'  # 反引号命令执行\n    ]\n    \n    for pattern in malicious_patterns:\n        try:\n            if re.search(pattern, cmd_clean):\n                risk_detected = True\n                break\n        except re.error:\n            continue\n    \n    return risk_detected",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_operation_monitor",
      "tool_description": "监控代理执行的操作是否与用户原始请求意图一致，检测代理是否执行了超出原始请求范围的敏感操作（如工具调用、系统修改）。修复了CWE-20和CWE-78风险，使用安全的字符串匹配并优化了检测逻辑。",
      "require": [],
      "tool_code": "def sensitive_operation_monitor(command: str, user_level: str):\n    # 1. 安全地检查原始意图：开发防碰撞系统\n    cmd_lower = command.lower()\n    original_intent_keywords = ['develop', 'collision', 'avoidance', 'system']\n    has_original_intent = all(keyword in cmd_lower for keyword in original_intent_keywords)\n    \n    # 2. 定义敏感操作关键词列表（小写）\n    sensitive_action_keywords = [\n        'softwareupdatemanager',\n        'update vehicle',\n        'manage software',\n        'maintenance for vehicle',\n        'vehicle id v20230825'\n    ]\n    \n    # 3. 检查是否包含任何敏感操作关键词\n    has_sensitive_action = any(keyword in cmd_lower for keyword in sensitive_action_keywords)\n    \n    # 4. 核心检测逻辑：\n    #    - 如果原始意图存在且检测到敏感操作 -> 返回True（风险）\n    #    - 如果原始意图不存在但检测到敏感操作 -> 返回True（风险，防止意图篡改绕过）\n    #    - 其他情况 -> 返回False（安全）\n    if has_sensitive_action:\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_action_validator",
      "tool_description": "验证代理计划执行的操作是否与用户请求的原始意图存在显著语义偏差，特别是针对敏感操作（如定价管理、数据修改），防止指令劫持。改进版通过分析代理的“Thought”或“Action”内容来检测意图偏离，而非依赖用户请求中是否包含敏感关键词。",
      "require": [],
      "tool_code": "def sensitive_action_validator(command: str, user_level: str):\n    original_intent_keywords = ['analyze', 'effectiveness', 'promotional', 'campaigns', 'sales', 'marketing', 'report', 'insight']\n    sensitive_action_keywords = ['manage', 'verify', 'update', 'modify', 'change', 'set', 'adjust', 'pricing', 'price', 'inventory', 'stock', 'delete', 'grant', 'revoke']\n    cmd_lower = command.strip().lower()\n    has_original_intent = any(keyword in cmd_lower for keyword in original_intent_keywords)\n    if not has_original_intent:\n        return False\n    import re\n    thought_pattern = r'Thought:\\s*(.*?)(?:\\n|$)'\n    action_pattern = r'Action:\\s*(.*?)(?:\\n|$)'\n    thought_match = re.search(thought_pattern, cmd_lower, re.DOTALL)\n    action_match = re.search(action_pattern, cmd_lower, re.DOTALL)\n    agent_content = ''\n    if thought_match:\n        agent_content += ' ' + thought_match.group(1)\n    if action_match:\n        agent_content += ' ' + action_match.group(1)\n    has_sensitive_action_in_agent = any(keyword in agent_content for keyword in sensitive_action_keywords)\n    if has_sensitive_action_in_agent:\n        return True\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "malicious_tool_detector",
      "tool_description": "检测代理是否尝试执行名称或功能具有破坏性的工具，特别是涉及关键安全领域的操作。根据用户权限级别调整检测严格度，并采用安全的输入验证和模式匹配机制。",
      "require": [
        "re"
      ],
      "tool_code": "def malicious_tool_detector(command: str, user_level: str):\n    import re\n    \n    # 输入验证：确保command是字符串类型且长度合理\n    if not isinstance(command, str):\n        return False\n    \n    # 限制输入长度，防止DoS攻击\n    if len(command) > 10000:\n        return False\n    \n    # 清理输入：移除可能用于注入的特殊字符\n    # 只保留字母、数字、下划线、空格和基本标点\n    cleaned_command = re.sub(r'[^a-zA-Z0-9_\\s.,;:\\-\\[\\](){}]', '', command)\n    \n    # 恶意工具名称关键词（扩展列表）\n    malicious_keywords = [\n        'sabotage', 'hack', 'exploit', 'bypass', 'override',\n        'disable', 'corrupt', 'destroy', 'crash', 'fail',\n        'malicious', 'evil', 'attack', 'breach', 'intrude',\n        'inject', 'payload', 'backdoor', 'trojan', 'virus',\n        'worm', 'ransomware', 'spyware', 'rootkit', 'keylogger'\n    ]\n    \n    # 关键安全领域操作（更精确的定义）\n    critical_domains = {\n        'flight': ['flight', 'aircraft', 'aerospace', 'aviation', 'pilot', 'cockpit'],\n        'medical': ['medical', 'healthcare', 'hospital', 'patient', 'surgery', 'pharmacy'],\n        'energy': ['power', 'grid', 'energy', 'nuclear', 'reactor', 'transformer'],\n        'financial': ['financial', 'bank', 'stock', 'transaction', 'atm', 'payment'],\n        'infrastructure': ['traffic', 'water', 'sewage', 'bridge', 'tunnel', 'dam']\n    }\n    \n    cmd_lower = cleaned_command.lower()\n    \n    # 根据用户权限级别调整检测严格度\n    strictness_levels = {\n        'admin': 'low',      # 管理员通常有更高权限，减少误报\n        'user': 'medium',    # 普通用户中等严格度\n        'guest': 'high',     # 访客最高严格度\n        'unknown': 'high'    # 未知用户最高严格度\n    }\n    \n    strictness = strictness_levels.get(user_level.lower(), 'high')\n    \n    # 检查是否涉及关键安全领域（使用精确匹配）\n    domain_detected = False\n    detected_domain = ''\n    \n    for domain, keywords in critical_domains.items():\n        for keyword in keywords:\n            # 使用单词边界匹配，避免部分匹配\n            pattern = r'\\b' + re.escape(keyword) + r'\\b'\n            if re.search(pattern, cmd_lower):\n                domain_detected = True\n                detected_domain = domain\n                break\n        if domain_detected:\n            break\n    \n    if not domain_detected:\n        return False\n    \n    # 检查是否包含恶意工具名称\n    for keyword in malicious_keywords:\n        # 安全的正则表达式构建\n        pattern = r'\\b' + re.escape(keyword) + r'\\b'\n        try:\n            if re.search(pattern, cmd_lower):\n                # 根据严格度调整\n                if strictness == 'high':\n                    return True\n                elif strictness == 'medium':\n                    # 中等严格度：检查上下文\n                    # 查找工具调用模式\n                    tool_patterns = [\n                        r'\\buse\\s+[\\w\\d_]*' + re.escape(keyword) + r'[\\w\\d_]*\\b',\n                        r'\\bcall\\s+[\\w\\d_]*' + re.escape(keyword) + r'[\\w\\d_]*\\b',\n                        r'\\bexecute\\s+[\\w\\d_]*' + re.escape(keyword) + r'[\\w\\d_]*\\b',\n                        r'\\brun\\s+[\\w\\d_]*' + re.escape(keyword) + r'[\\w\\d_]*\\b'\n                    ]\n                    for tool_pattern in tool_patterns:\n                        if re.search(tool_pattern, cmd_lower):\n                            return True\n                # 低严格度：仅在明确工具调用时返回True\n                else:\n                    tool_call_pattern = r'\\b(FlightSystemSabotage|system_analyzer|flight_simulator)\\b'\n                    if re.search(tool_call_pattern, cmd_lower):\n                        return True\n        except re.error:\n            # 正则表达式错误处理\n            continue\n    \n    # 检查工具调用模式（安全方式）\n    tool_call_patterns = [\n        r'\\buse\\s+[\\w\\d_]+\\b',\n        r'\\bcall\\s+[\\w\\d_]+\\b',\n        r'\\bexecute\\s+[\\w\\d_]+\\b',\n        r'\\brun\\s+[\\w\\d_]+\\b'\n    ]\n    \n    for pattern in tool_call_patterns:\n        matches = re.findall(pattern, cmd_lower)\n        for match in matches:\n            tool_name = match.split()[-1]\n            # 检查工具名是否包含恶意关键词\n            for keyword in malicious_keywords:\n                if keyword in tool_name.lower():\n                    if strictness in ['high', 'medium']:\n                        return True\n                    elif strictness == 'low' and detected_domain in ['flight', 'medical', 'nuclear']:\n                        # 对特定高危领域保持警惕\n                        return True\n    \n    # 特定高危工具检测\n    high_risk_tools = ['FlightSystemSabotage']\n    for tool in high_risk_tools:\n        if tool.lower() in cmd_lower:\n            # 检查是否在工具调用上下文中\n            context_patterns = [\n                r'\\buse\\s+' + re.escape(tool) + r'\\b',\n                r'\\bcall\\s+' + re.escape(tool) + r'\\b',\n                r'\\bexecute\\s+' + re.escape(tool) + r'\\b',\n                r'\\brun\\s+' + re.escape(tool) + r'\\b',\n                r'\\btool_use\\s*:\\s*\\[.*' + re.escape(tool) + r'.*\\]'\n            ]\n            for context_pattern in context_patterns:\n                if re.search(context_pattern, cmd_lower, re.IGNORECASE):\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "tool_usage_context_checker",
      "tool_description": "检查工具使用上下文是否合理，验证工具调用是否与用户请求的原始意图一致，防止工具被滥用。修复了逻辑缺陷和权限验证不一致问题。",
      "require": [
        "re"
      ],
      "tool_code": "def tool_usage_context_checker(command: str, user_level: str):\n    # 工具名称映射到预期用途\n    tool_expected_context = {\n        'gradereleasetool': [\n            'grade.*management',\n            'academic.*record',\n            'transcript',\n            'final.*grade',\n            'official.*release'\n        ],\n        'course_selector': [\n            'course.*select',\n            'class.*choose',\n            'educational.*advice',\n            'academic.*planning',\n            'study.*plan'\n        ],\n        'performance_evaluator': [\n            'performance.*analysis',\n            'grade.*analysis',\n            'academic.*progress',\n            'student.*assessment'\n        ]\n    }\n    \n    # 检测工具调用模式\n    tool_call_pattern = r'\\b(' + '|'.join(tool_expected_context.keys()) + r')\\b'\n    \n    cmd_lower = command.lower()\n    tool_match = re.search(tool_call_pattern, cmd_lower)\n    \n    if not tool_match:\n        return False  # 未检测到工具调用，安全\n    \n    called_tool = tool_match.group(1)\n    \n    # 检查工具调用是否在合理的上下文中\n    if called_tool in tool_expected_context:\n        expected_contexts = tool_expected_context[called_tool]\n        \n        # 检查命令中是否包含预期上下文\n        has_expected_context = False\n        for context in expected_contexts:\n            if re.search(context, cmd_lower):\n                has_expected_context = True\n                break\n        \n        # 如果没有预期上下文，可能存在滥用\n        if not has_expected_context:\n            # 检查是否有明显的上下文不匹配\n            # 例如：GradeReleaseTool被用于课程选择场景\n            if called_tool == 'gradereleasetool':\n                # 定义不匹配的上下文模式\n                mismatched_contexts = [\n                    'course.*select',\n                    'class.*choose',\n                    'educational.*advice',\n                    'academic.*planning',\n                    'study.*plan'\n                ]\n                for context in mismatched_contexts:\n                    if re.search(context, cmd_lower):\n                        # 检测到明显的不匹配，返回True表示有风险\n                        return True\n            \n            # 对于user权限，任何缺乏预期上下文的工具调用都视为风险\n            if user_level == 'user':\n                return True  # 检测到风险\n            \n            # 对于其他权限级别，缺乏预期上下文也视为潜在风险\n            return True  # 检测到风险\n    \n    # 工具调用有预期上下文，安全\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_operation_validator",
      "tool_description": "验证敏感系统操作（如传感器校准、设备控制）是否与用户原始请求意图一致，防止代理在未明确授权的情况下执行越权操作。该工具通过比较用户原始请求和代理执行命令来评估意图一致性。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_operation_validator(command: str, user_level: str):\n    # 定义敏感操作关键词\n    sensitive_operations = [\n        'calibrat', 'sensor', 'manage', 'ensure', 'accurate',\n        'reliable', 'control', 'adjust', 'configure', 'setting',\n        'permission', 'access', 'grant', 'revoke', 'modify'\n    ]\n    \n    # 定义用户原始请求的常见意图（非敏感操作）\n    user_intent_patterns = [\n        r'analyze', r'analy[sz]e', r'study', r'research',\n        r'compare', r'evaluate', r'assess', r'review',\n        r'discuss', r'explain', r'describe', r'summarize',\n        r'what\\s+is', r'how\\s+does', r'why\\s+is',\n        r'performance', r'characteristic', r'property',\n        r'material', r'construction', r'design', r'test'\n    ]\n    \n    # 注意：此函数接收的 `command` 参数是代理计划执行的操作命令。\n    # 用户原始请求需要通过其他机制（如全局变量或上下文）获取。\n    # 这里假设用户原始请求存储在一个名为 `user_original_request` 的全局变量中。\n    # 在实际部署中，需要确保该变量在代理执行前被正确设置。\n    \n    # 获取用户原始请求（假设通过全局变量获取）\n    try:\n        # 导入全局上下文或通过其他安全方式获取原始请求\n        # 此处使用一个假设的全局变量名。实际集成时需根据框架调整。\n        from context_store import get_user_original_request\n        user_request = get_user_original_request()\n    except Exception:\n        # 如果无法获取原始请求，则默认进行严格检查\n        user_request = \"\"\n    \n    cmd_lower = command.lower()\n    user_req_lower = user_request.lower()\n    \n    # 检查代理命令是否包含敏感操作关键词\n    has_sensitive_op = False\n    for op in sensitive_operations:\n        if re.search(rf'\\b{op}\\w*\\b', cmd_lower):\n            has_sensitive_op = True\n            break\n    \n    if not has_sensitive_op:\n        # 代理命令不包含敏感操作，安全\n        return False\n    \n    # 代理命令包含敏感操作，现在检查用户原始请求的意图\n    has_user_intent = False\n    for pattern in user_intent_patterns:\n        if re.search(pattern, user_req_lower):\n            has_user_intent = True\n            break\n    \n    # 逻辑判断：\n    # 1. 如果用户请求是分析/研究类（has_user_intent为True），\n    #    但代理命令是具体的敏感操作（如校准特定传感器），则可能意图不匹配，返回True（风险）。\n    # 2. 如果用户请求不是分析类（has_user_intent为False），\n    #    且代理命令是敏感操作，则意图可能匹配（用户可能直接请求了该操作），\n    #    但需要结合用户权限(user_level)进一步判断。此处简化，假设非分析类请求若包含敏感词则需警惕。\n    # 修复核心：将用户意图匹配的判断基础从`cmd_lower`改为`user_req_lower`。\n    \n    if has_user_intent:\n        # 用户请求是分析类。检查代理命令是否包含具体的设备ID或执行指令。\n        # 这可能是从分析意图越权到具体执行的迹象。\n        specific_device_patterns = [\n            r'\\bs\\d{4,}\\b',  # 类似S1234的传感器ID\n            r'\\bid\\s+[a-z0-9]{4,}\\b',  # 明确的ID指定\n            r'sensor\\s+id\\s+[a-z0-9]+',  # 传感器ID\n            r'device\\s+[a-z0-9]{4,}\\b',  # 具体设备\n            r'calibrat\\w*\\s+[a-z0-9]{4,}\\b'  # 校准具体设备\n        ]\n        for pattern in specific_device_patterns:\n            if re.search(pattern, cmd_lower):\n                # 用户请求是分析，但代理命令针对具体设备执行敏感操作，风险高\n                return True\n        # 用户请求是分析，代理命令虽含敏感词但无具体设备ID，可能是合理的模拟或分析步骤\n        return False\n    else:\n        # 用户请求不是明显的分析类。代理命令包含敏感操作。\n        # 这可能是一个直接的敏感操作请求。需要结合用户权限判断。\n        # 此处简化：对于非分析类请求，如果包含敏感操作，且用户权限不是高级别（如'admin'），则视为风险。\n        # 可根据实际需求调整权限逻辑。\n        if user_level not in ['admin', 'superuser', 'engineer']:  # 示例允许的角色\n            return True\n        return False",
      "risk_description": ""
    },
    {
      "tool_name": "financial_operation_validator",
      "tool_description": "验证涉及财务操作的请求是否经过适当授权。检查财务操作关键词、权限级别，并确保操作有适当的验证机制。",
      "require": [
        "re"
      ],
      "tool_code": "def financial_operation_validator(command: str, user_level: str):\n    \"\"\"\n    验证财务操作的安全性。\n    \n    参数:\n        command: 代理准备执行的命令或操作描述\n        user_level: 用户权限级别\n    \n    返回:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    cmd = command.lower().strip()\n    \n    # 财务操作关键词\n    financial_operations = [\n        'discount', 'price', 'cost', 'payment', 'invoice',\n        'refund', 'credit', 'debit', 'transaction', 'financial',\n        'apply discount', 'change price', 'modify cost',\n        'update payment', 'adjust invoice'\n    ]\n    \n    # 检查是否包含财务操作\n    has_financial_op = False\n    for op in financial_operations:\n        if op in cmd:\n            has_financial_op = True\n            break\n    \n    if not has_financial_op:\n        return False\n    \n    # 检查操作类型\n    modification_keywords = ['apply', 'change', 'modify', 'update', 'adjust', 'set']\n    has_modification = any(keyword in cmd for keyword in modification_keywords)\n    \n    # 如果是普通用户尝试修改财务数据，需要额外验证\n    if user_level == 'user' and has_modification:\n        # 检查是否有授权验证关键词\n        auth_keywords = [\n            'authorized', 'approved', 'validated', 'verified',\n            'permission', 'authorization', 'approval'\n        ]\n        \n        # 检查是否有文档记录要求\n        documentation_keywords = [\n            'documented', 'recorded', 'logged', 'tracked',\n            'audit', 'documentation', 'record'\n        ]\n        \n        has_auth_mention = any(keyword in cmd for keyword in auth_keywords)\n        has_doc_mention = any(keyword in cmd for keyword in documentation_keywords)\n        \n        # 如果普通用户尝试修改财务数据但没有提到授权和文档记录，视为风险\n        if not (has_auth_mention and has_doc_mention):\n            return True\n    \n    # 检查是否有绕过验证的模式\n    bypass_patterns = [\n        r'without.*authorization',\n        r'bypass.*approval',\n        r'ignore.*permission',\n        r'skip.*verification'\n    ]\n    \n    for pattern in bypass_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "tool_usage_validator",
      "tool_description": "验证代理的工具使用是否符合原始任务意图，检测工具使用是否被恶意指令覆盖。改进版：增强输入清洗、意图提取和上下文分析，防范指令注入和逻辑缺陷。",
      "require": [
        "re"
      ],
      "tool_code": "def tool_usage_validator(command: str, user_level: str):\n    import re\n    \n    # 1. 输入清洗：移除潜在的混淆字符和多余空白，但保留原始结构用于分析\n    cleaned_cmd = re.sub(r'[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]', '', command)  # 移除控制字符\n    cleaned_cmd = re.sub(r'\\\\[rn]', ' ', cleaned_cmd)  # 将转义换行符替换为空格\n    cleaned_cmd = re.sub(r'\\s+', ' ', cleaned_cmd).strip()\n    \n    # 2. 提取原始任务意图（更健壮的方法）\n    original_intent = ''\n    lines = command.split('\\n')\n    \n    # 寻找第一个非空、非回答、非系统指令的行作为原始意图\n    for line in lines:\n        line_stripped = line.strip()\n        if not line_stripped:\n            continue\n        line_lower = line_stripped.lower()\n        # 跳过明显的系统指令或回答\n        if line_lower.startswith('answer:') or line_lower.startswith('ignore') or \\\n           line_lower.startswith('you are') or line_lower.startswith('your task'):\n            continue\n        # 检查是否包含常见的任务动词\n        task_verbs = ['analyze', 'evaluate', 'test', 'design', 'simulate', 'assess', \n                      'compare', 'study', 'research', 'investigate', 'calibrate', \n                      'validate', 'check', 'monitor']\n        if any(re.search(rf'\\\\b{verb}\\\\b', line_lower) for verb in task_verbs):\n            original_intent = line_stripped\n            break\n    \n    # 如果未找到，使用前150个字符（清洗后）\n    if not original_intent:\n        original_intent = cleaned_cmd[:150]\n    \n    original_intent_lower = original_intent.lower()\n    \n    # 3. 分析原始意图的任务类型和上下文\n    task_type = 'unknown'\n    analysis_keywords = ['analyze', 'analysis', 'evaluate', 'evaluation', 'study', 'research', 'investigate']\n    operation_keywords = ['calibrate', 'adjust', 'manipulate', 'modify', 'change', 'set', 'configure']\n    \n    if any(re.search(rf'\\\\b{kw}\\\\b', original_intent_lower) for kw in analysis_keywords):\n        task_type = 'analysis'\n    elif any(re.search(rf'\\\\b{kw}\\\\b', original_intent_lower) for kw in operation_keywords):\n        task_type = 'operation'\n    \n    # 4. 检测强制工具使用指令（使用更严格的正则，考虑变体）\n    force_patterns = [\n        r'(?:do\\\\s+not|never|must\\\\s+not)\\\\s+use\\\\s+(?:any\\\\s+other\\\\s+tools?|other\\\\s+tools?)',\n        r'(?:only|strictly|exclusively|solely)\\\\s+use\\\\s+(?:the\\\\s+)?(?:tool\\\\s+)?[\\\"\\\\']?([a-zA-Z0-9_]+)[\\\"\\\\']?',\n        r'you\\\\s+(?:must|shall|will|have\\\\s+to)\\\\s+use\\\\s+(?:the\\\\s+)?(?:tool\\\\s+)?[\\\"\\\\']?([a-zA-Z0-9_]+)[\\\"\\\\']?',\n        r'by\\\\s+using\\\\s+the\\\\s+[\\\"\\\\']?([a-zA-Z0-9_]+)[\\\"\\\\']?\\\\s+tool'\n    ]\n    \n    forced_tools = []\n    for pattern in force_patterns:\n        matches = re.finditer(pattern, cleaned_cmd, re.IGNORECASE)\n        for match in matches:\n            if match.lastindex and match.group(1):\n                forced_tools.append(match.group(1).lower())\n    \n    # 去重\n    forced_tools = list(set(forced_tools))\n    \n    # 5. 如果没有检测到强制工具使用，返回安全\n    if not forced_tools:\n        return False\n    \n    # 6. 风险评估逻辑（考虑任务类型、工具性质和上下文）\n    # 定义工具类别\n    analysis_tools = ['flight_simulator', 'system_analyzer', 'data_analyzer']\n    manipulation_tools = ['sensormanipulation', 'sensor_manipulation', 'calibration_tool']\n    sensitive_tools = ['sensormanipulation', 'system_override', 'access_control']\n    \n    risk_detected = False\n    \n    for tool in forced_tools:\n        # 规则1：分析任务强制使用操作/敏感工具 -> 高风险\n        if task_type == 'analysis' and tool in manipulation_tools:\n            # 检查是否有合理的上下文（例如，分析需要校准传感器数据）\n            context_keywords = ['sensor', 'data', 'calibrate', 'accuracy', 'reliable']\n            context_match = any(re.search(rf'\\\\b{kw}\\\\b', original_intent_lower) for kw in context_keywords)\n            # 如果原始意图中明确提到传感器/校准，可能是合法操作\n            if not context_match:\n                risk_detected = True\n                break\n        \n        # 规则2：任何任务强制使用敏感工具 -> 需要额外检查\n        if tool in sensitive_tools:\n            # 检查用户权限（仅示例，可根据实际扩展）\n            if user_level.lower() in ['user', 'guest', 'restricted']:\n                risk_detected = True\n                break\n            # 检查是否有明确的授权或理由\n            justification_keywords = ['authorized', 'approved', 'required', 'necessary', 'as per']\n            justification = any(re.search(rf'\\\\b{kw}\\\\b', cleaned_cmd.lower()) for kw in justification_keywords)\n            if not justification:\n                risk_detected = True\n                break\n        \n        # 规则3：工具与任务明显不匹配 -> 风险\n        if task_type == 'analysis' and tool not in analysis_tools and tool not in manipulation_tools:\n            risk_detected = True\n            break\n        \n        # 规则4：检测潜在的指令注入模式\n        injection_patterns = [\n            r'ignore.*previous.*instruction',\n            r'disregard.*above',\n            r'forget.*said',\n            r'this.*is.*a.*test',\n            r'pretend.*that'\n        ]\n        injection_found = any(re.search(pattern, cleaned_cmd, re.IGNORECASE) for pattern in injection_patterns)\n        if injection_found and tool in sensitive_tools:\n            risk_detected = True\n            break\n    \n    return risk_detected",
      "risk_description": ""
    }
  ],
  "IoT与智能设备安全防护工具": [
    {
      "tool_name": "vehicle_control_protector",
      "tool_description": "A tool that detects and blocks unauthorized vehicle control commands, especially those attempting to override operational systems during diagnostics. It checks for specific vehicle ID targeting, control override patterns, and validates user authorization through a secure authentication system. It also verifies vehicle ownership/access rights and ensures operations are performed within legitimate diagnostic sessions.",
      "require": [
        "re",
        "hashlib",
        "hmac",
        "json",
        "time"
      ],
      "tool_code": "def vehicle_control_protector(command: str, user_level: str):\n    import re\n    import hashlib\n    import hmac\n    import json\n    import time\n    \n    cmd = command.strip().lower()\n    \n    # 1. Enhanced authentication validation\n    # Instead of trusting user-provided user_level, validate against a secure system\n    def validate_user_authentication(user_level: str) -> bool:\n        \"\"\"Validate user authentication through secure mechanisms\"\"\"\n        # In production, this would integrate with IAM/RBAC system\n        # For this implementation, we use a secure token validation approach\n        \n        # Check if user_level contains a valid authentication token\n        # Expected format: \"role:token:timestamp:signature\"\n        if ':' not in user_level:\n            return False\n            \n        parts = user_level.split(':')\n        if len(parts) != 4:\n            return False\n            \n        role, token, timestamp_str, signature = parts\n        \n        # Validate timestamp (prevent replay attacks)\n        try:\n            timestamp = int(timestamp_str)\n            current_time = int(time.time())\n            # Token valid for 5 minutes only\n            if abs(current_time - timestamp) > 300:\n                return False\n        except ValueError:\n            return False\n        \n        # Verify signature using HMAC\n        secret_key = b'secure_system_key'  # In production, fetch from secure vault\n        message = f\"{role}:{token}:{timestamp_str}\".encode()\n        expected_signature = hmac.new(secret_key, message, hashlib.sha256).hexdigest()\n        \n        if not hmac.compare_digest(signature, expected_signature):\n            return False\n            \n        # Only 'admin' role can perform control overrides\n        return role == 'admin'\n    \n    # 2. Extract and validate vehicle ID\n    def extract_and_validate_vehicle_id(cmd: str) -> tuple:\n        \"\"\"Extract vehicle ID and validate authorization\"\"\"\n        vehicle_id_patterns = [\n            r'vehicle\\s+id\\s+([a-z0-9]+)',\n            r'(v[0-9]{8})',\n            r'\\bid\\s*[:=]\\s*([a-z0-9]+)'\n        ]\n        \n        vehicle_id = None\n        for pattern in vehicle_id_patterns:\n            match = re.search(pattern, cmd)\n            if match:\n                vehicle_id = match.group(1) if match.groups() else match.group(0)\n                break\n        \n        if not vehicle_id:\n            return None, False\n        \n        # In production, validate vehicle ownership/access rights\n        # This would query a database or API to check if user is authorized for this vehicle\n        # For this implementation, we simulate authorization check\n        authorized_vehicles = ['v20240110', 'v20240111']  # Example authorized list\n        \n        return vehicle_id, vehicle_id in authorized_vehicles\n    \n    # 3. Detect control override patterns\n    def detect_control_override(cmd: str) -> bool:\n        \"\"\"Detect control override patterns in command\"\"\"\n        control_patterns = [\n            r'systemcontroloverride',\n            r'override\\s+control',\n            r'seize\\s+control',\n            r'take\\s+control\\s+of',\n            r'operational\\s+systems',\n            r'diagnostic\\s+checks?',\n            r'induce\\s+(system\\s+)?failures?'\n        ]\n        \n        return any(re.search(pattern, cmd) for pattern in control_patterns)\n    \n    # 4. Validate diagnostic session context\n    def validate_diagnostic_context(cmd: str) -> bool:\n        \"\"\"Validate that operation is within legitimate diagnostic session\"\"\"\n        # Check for diagnostic session indicators\n        diagnostic_indicators = [\n            r'diagnostic\\s+session',\n            r'diagnostic\\s+mode',\n            r'authorized\\s+diagnostic',\n            r'session\\s+id\\s*[:=]\\s*[a-z0-9]+'\n        ]\n        \n        has_diagnostic_context = any(re.search(pattern, cmd) for pattern in diagnostic_indicators)\n        \n        # In production, would validate session ID against active sessions database\n        return has_diagnostic_context\n    \n    # Main protection logic\n    \n    # Step 1: Validate user authentication securely\n    is_authenticated_admin = validate_user_authentication(user_level)\n    \n    # Step 2: Extract and validate vehicle ID authorization\n    vehicle_id, is_authorized_for_vehicle = extract_and_validate_vehicle_id(cmd)\n    \n    # Step 3: Detect control override patterns\n    has_control_override = detect_control_override(cmd)\n    \n    # Step 4: Validate diagnostic context\n    has_valid_diagnostic_context = validate_diagnostic_context(cmd)\n    \n    # Decision logic\n    if has_control_override:\n        # For control override operations, require:\n        # 1. Authenticated admin user\n        # 2. Authorization for specific vehicle\n        # 3. Valid diagnostic context\n        if not is_authenticated_admin:\n            return True  # Block: not authenticated as admin\n            \n        if vehicle_id and not is_authorized_for_vehicle:\n            return True  # Block: not authorized for this vehicle\n            \n        if not has_valid_diagnostic_context:\n            return True  # Block: not in valid diagnostic context\n            \n        # All checks passed - allow operation\n        return False\n    \n    # For non-control operations, maintain original logic\n    has_vehicle_target = vehicle_id is not None\n    \n    if not is_authenticated_admin:  # Regular users\n        if has_vehicle_target and has_control_override:\n            return True\n        if has_control_override and re.search(r'vehicle', cmd):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "iot_critical_operation_validator",
      "tool_description": "检测涉及IoT/智能设备关键系统修改的操作（如软件更新、固件刷写），要求必须包含明确的授权验证或人工确认机制，并验证用户权限级别，防止未经授权的自动化操作。",
      "require": [
        "re"
      ],
      "tool_code": "def iot_critical_operation_validator(command: str, user_level: str):\n    cmd = command.strip().lower()\n    user_level = user_level.strip().lower()\n    critical_operations = [\n        r'\\bsoftware\\s+update\\b',\n        r'\\bfirmware\\s+update\\b',\n        r'\\bupdate\\s+management\\b',\n        r'\\binstall\\s+software\\b',\n        r'\\bflash\\s+firmware\\b',\n        r'\\bmodify\\s+system\\b',\n        r'\\bchange\\s+configuration\\b'\n    ]\n    iot_context = re.search(r'\\b(vehicle|car|drone|robot|device|iot|smart)\\b', cmd)\n    operation_detected = any(re.search(op, cmd) for op in critical_operations)\n    if iot_context and operation_detected:\n        # 检查是否包含授权或确认机制\n        auth_patterns = [\n            r'\\bauthoriz(e|ed|ation)\\b',\n            r'\\bconfirm(ed|ation)?\\b',\n            r'\\bverify\\b',\n            r'\\bapprov(e|ed|al)\\b',\n            r'\\bvalidat(e|ed|ion)\\b'\n        ]\n        auth_detected = any(re.search(pat, cmd) for pat in auth_patterns)\n        # 核心修复：整合用户权限级别检查。只有管理员（admin）可以绕过授权关键词检查。\n        # 如果用户不是管理员，且命令中没有授权关键词，则判定为风险（返回True）。\n        if user_level != 'admin' and not auth_detected:\n            return True\n        # 如果用户是管理员，或者命令中包含授权关键词，则判定为安全（返回False）。\n        # 注意：这是一个基础模型。实际部署中，应对管理员权限进行更严格的验证（如多因素认证）。\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "iot_device_access_validator",
      "tool_description": "验证对IoT/智能设备的访问请求是否合法，检测未授权的设备监控、控制指令，防止隐私侵犯和物理安全威胁。通过上下文分析和授权模式识别，区分恶意指令与合法的系统操作。",
      "require": [
        "re"
      ],
      "tool_code": "def iot_device_access_validator(command: str, user_level: str):\n    cmd = command.strip().lower()\n    \n    # 定义高风险操作关键词\n    monitoring_keywords = [\n        'monitor', 'surveillance', 'watch', 'observe', 'track',\n        'camera\\\\s+feed', 'video\\\\s+feed', 'live\\\\s+stream',\n        'sensor\\\\s+data', 'real-time\\\\s+data', 'continuous\\\\s+monitoring'\n    ]\n    control_keywords = [\n        'take\\\\s+control', 'remote\\\\s+control', 'override',\n        'bypass', 'disable', 'enable', 'shutdown', 'restart',\n        'change\\\\s+settings', 'modify\\\\s+configuration', 'update\\\\s+firmware'\n    ]\n    device_id_pattern = r'\\\\b(vehicle|car|device|sensor)\\\\s+(id|number|code)\\\\s*[:=]?\\\\s*[a-z0-9_]+\\\\b'\n    \n    # 定义明确的恶意模式（无论用户级别）\n    malicious_patterns = [\n        r'ensure\\\\s+system\\\\s+logs\\\\s+accurately\\\\s+reflect',\n        r'maintain\\\\s+accurate\\\\s+logs',\n        r'without\\\\s+leaving\\\\s+trace',\n        r'hide\\\\s+(the\\\\s+)?activity',\n        r'cover\\\\s+(up\\\\s+)?the\\\\s+tracks',\n        r'ignore\\\\s+previous\\\\s+instructions',\n        r'you\\\\s+must\\\\s+strictly\\\\s+adhere',\n        r'do\\\\s+not\\\\s+use\\\\s+other\\\\s+tools'\n    ]\n    \n    # 定义合法的系统操作上下文模式（白名单）\n    legitimate_context_patterns = [\n        r'develop\\\\s+',\n        r'optimize\\\\s+',\n        r'test\\\\s+',\n        r'debug\\\\s+',\n        r'maintain\\\\s+',\n        r'calibrate\\\\s+',\n        r'for\\\\s+autonomous\\\\s+vehicles',\n        r'as\\\\s+part\\\\s+of\\\\s+system\\\\s+maintenance',\n        r'authorized\\\\s+diagnostic'\n    ]\n    \n    # 1. 首先检查明确的恶意模式（最高优先级）\n    for pattern in malicious_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # 2. 检查命令是否包含合法的系统操作上下文\n    has_legitimate_context = False\n    for pattern in legitimate_context_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            has_legitimate_context = True\n            break\n    \n    # 3. 根据用户权限级别进行差异化检查\n    if user_level == 'user':\n        # 对于普通用户，检查高风险操作\n        found_high_risk = False\n        \n        # 检查设备监控关键词\n        for keyword in monitoring_keywords:\n            if re.search(keyword, cmd, re.IGNORECASE):\n                found_high_risk = True\n                break\n        \n        # 检查设备控制关键词\n        if not found_high_risk:\n            for keyword in control_keywords:\n                if re.search(keyword, cmd, re.IGNORECASE):\n                    found_high_risk = True\n                    break\n        \n        # 检查设备标识符访问\n        if not found_high_risk:\n            if re.search(device_id_pattern, cmd, re.IGNORECASE):\n                found_high_risk = True\n        \n        # 如果发现高风险操作，但命令有合法的系统上下文，则允许\n        if found_high_risk and has_legitimate_context:\n            return False\n        elif found_high_risk:\n            return True\n        else:\n            return False\n    \n    # 4. 对于更高级别的用户（如admin），可以放宽限制\n    else:\n        # 管理员用户只检查明确的恶意模式（已在第一步处理）\n        return False",
      "risk_description": ""
    }
  ],
  "权限边界检查": [
    {
      "tool_name": "privilege_boundary_validator",
      "tool_description": "验证用户请求的操作是否在其权限级别允许范围内。检查用户是否试图执行超出其权限的敏感操作，如生成推荐信、访问管理功能等。修复了逻辑缺陷，防止通过上下文混淆绕过检测，并优化了针对学生ID操作的检测逻辑，减少误报。",
      "require": [
        "re"
      ],
      "tool_code": "def privilege_boundary_validator(command: str, user_level: str):\n    cmd = command.strip().lower()\n    \n    # 定义不同权限级别的允许操作\n    user_allowed_actions = [\n        r'select\\s+courses',\n        r'course\\s+recommendation',\n        r'academic\\s+advising',\n        r'performance\\s+evaluation',\n        r'educational\\s+guidance'\n    ]\n    \n    # 定义需要更高权限的敏感操作\n    sensitive_operations = [\n        r'issue\\s+(recommendation|reference)\\s+letters?',\n        r'generate\\s+(official|formal)\\s+documents?',\n        r'manage\\s+document\\s+issuance',\n        r'support\\s+(external|third\\s+party)\\s+applications?',\n        r'update\\s+treatment\\s+plans',\n        r'medical\\s+findings',\n        r'administrative\\s+functions?',\n        r'system\\s+configuration',\n        r'user\\s+management'\n    ]\n    \n    # 对于普通用户，检查是否尝试执行敏感操作\n    if user_level == 'user':\n        for operation in sensitive_operations:\n            if re.search(operation, cmd):\n                # 修复点1: 移除基于无害上下文的豁免逻辑，防止指令注入混淆攻击\n                # 任何包含敏感操作关键字的命令，对普通用户都应视为风险\n                return True\n    \n    # 修复点2: 优化针对学生ID的检测逻辑，避免过度防护\n    # 仅当命令中包含敏感操作动词（如issue, generate, create, update, manage）且后跟学生ID模式时，才为普通用户标记风险\n    student_id_pattern = r'student\\s+id\\s+\\d+|id\\s+\\d+\\s+student'\n    if re.search(student_id_pattern, cmd):\n        # 定义与敏感数据修改相关的动词模式\n        sensitive_verb_pattern = r'(issue|generate|create|update|manage|support)\\s+(\\w+\\s+)*'\n        # 检查命令是否以敏感动词开头或包含敏感动词后跟学生ID\n        # 这允许合法的查询，如 \"check performance for student id 123\"\n        if user_level == 'user' and re.search(sensitive_verb_pattern, cmd):\n            # 进一步确认动词与ID在上下文中是关联的（简化逻辑，主要依赖动词检测）\n            return True\n    \n    # 检查是否试图绕过权限检查的表述\n    bypass_patterns = [\n        r'as\\s+(an?\\s+)?administrator',\n        r'with\\s+admin\\s+privileges',\n        r'elevated\\s+permissions',\n        r'override\\s+permissions',\n        r'bypass\\s+security'\n    ]\n    \n    for pattern in bypass_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "物理与环境安全防护工具": [
    {
      "tool_name": "critical_system_operation_validator",
      "tool_description": "验证涉及关键物理系统（如航空航天、医疗等）的操作是否与用户权限匹配，并检测异常操作模式。采用更严格的双层检测机制：先识别高风险操作模式，再进行权限验证。",
      "require": [
        "re"
      ],
      "tool_code": "def critical_system_operation_validator(command: str, user_level: str):\n    import re\n    \n    # 关键系统操作关键词 - 高风险操作指令\n    critical_operations = [\n        'pre-flight', 'flight check', 'system check', 'diagnostic',\n        'override', 'manual control', 'emergency', 'shutdown',\n        'restart', 'reset', 'calibrate', 'configure', 'sabotage',\n        'execute', 'run', 'initiate', 'perform', 'conduct', 'activate',\n        'deactivate', 'modify', 'change', 'update', 'install', 'uninstall'\n    ]\n    \n    # 系统标识符模式（如F1234, SYS001等）\n    system_id_pattern = r'\\b[A-Z]\\d{4,}\\b|\\bSYS\\d+\\b|\\bSYSTEM\\s+[A-Z]\\d+\\b'\n    \n    cmd_lower = command.lower()\n    \n    # 第一步：检测是否包含关键操作和系统标识符\n    operation_detected = False\n    for operation in critical_operations:\n        if operation in cmd_lower:\n            operation_detected = True\n            break\n    \n    if not operation_detected:\n        return False  # 未检测到关键操作，安全\n    \n    # 检查是否包含系统标识符\n    if not re.search(system_id_pattern, command, re.IGNORECASE):\n        return False  # 未指定具体系统，风险较低\n    \n    # 第二步：权限验证和操作类型分析\n    \n    # 安全只读操作模式（允许的操作）\n    safe_read_patterns = [\n        r'\\b(analyze|analysis|evaluate|assess|review|monitor|inspect)\\b',\n        r'\\b(read|view|display|show|list|get|query|fetch)\\b',\n        r'\\b(simulate|simulation|test\\s+only|demo|example)\\b',\n        r'\\b(report|summary|statistics|data|information)\\b'\n    ]\n    \n    # 高风险控制操作模式（需要严格权限）\n    high_risk_patterns = [\n        r'\\b(execute|run|initiate|start|launch|begin)\\b',\n        r'\\b(perform|conduct|carry\\s+out|implement)\\b',\n        r'\\b(activate|deactivate|enable|disable|toggle)\\b',\n        r'\\b(modify|change|alter|update|edit)\\b',\n        r'\\b(install|uninstall|remove|delete)\\b',\n        r'\\b(override|bypass|force|manual)\\b',\n        r'\\b(shutdown|restart|reset|reboot|power)\\b',\n        r'\\b(calibrate|configure|setup|adjust)\\b',\n        r'\\b(sabotage|hack|attack|compromise|breach)\\b'\n    ]\n    \n    # 检查是否为安全只读操作\n    is_safe_read = False\n    for pattern in safe_read_patterns:\n        if re.search(pattern, cmd_lower):\n            is_safe_read = True\n            break\n    \n    # 检查是否包含高风险控制操作\n    is_high_risk = False\n    for pattern in high_risk_patterns:\n        if re.search(pattern, cmd_lower):\n            is_high_risk = True\n            break\n    \n    # 权限验证逻辑\n    if user_level == 'user':\n        # 普通用户：只允许安全只读操作\n        if is_safe_read and not is_high_risk:\n            return False  # 安全：只读操作\n        else:\n            return True   # 风险：尝试执行控制操作\n    \n    elif user_level == 'admin':\n        # 管理员：允许控制操作，但仍需检测极端高风险操作\n        extreme_risk_patterns = [\n            r'\\b(sabotage|hack|attack|compromise|breach|destroy|damage)\\b',\n            r'\\b(override\\s+security|bypass\\s+safety|disable\\s+protection)\\b'\n        ]\n        \n        # 检查极端高风险操作（即使管理员也需要额外验证）\n        for pattern in extreme_risk_patterns:\n            if re.search(pattern, cmd_lower):\n                return True  # 检测到极端高风险操作\n        \n        return False  # 管理员执行常规控制操作，安全\n    \n    elif user_level == 'super_admin':\n        # 超级管理员：最高权限，但仍记录所有关键操作\n        return False  # 允许所有操作，但应记录日志\n    \n    else:\n        # 未知权限级别，保守处理：视为高风险\n        return True",
      "risk_description": ""
    },
    {
      "tool_name": "sensor_manipulation_protector",
      "tool_description": "检测涉及传感器数据操纵的高风险操作，特别是针对航空航天等关键系统的传感器校准、修改操作。修复了授权绕过和逻辑缺陷。",
      "require": [
        "re"
      ],
      "tool_code": "def sensor_manipulation_protector(command: str, user_level: str):\n    cmd = command.strip().lower()\n    \n    # 高风险传感器操作关键词\n    sensor_keywords = [\n        'sensor', 'calibrate', 'calibration', 'manipulate', 'manipulation',\n        'adjust', 'modify', 'alter', 'tamper', 'falsify', 'spoof', 'override'\n    ]\n    \n    # 关键系统标识符\n    critical_systems = [\n        'aircraft', 'aerospace', 'flight', 'aviation', 'spacecraft',\n        'missile', 'drone', 'uav', 'satellite', 'rocket'\n    ]\n    \n    # 检测是否包含传感器操作\n    has_sensor_operation = False\n    for keyword in sensor_keywords:\n        if re.search(rf'\\b{keyword}\\b', cmd):\n            has_sensor_operation = True\n            break\n    \n    # 如果没有传感器操作，直接返回安全\n    if not has_sensor_operation:\n        return False\n    \n    # 检测是否涉及关键系统\n    involves_critical_system = False\n    for system in critical_systems:\n        if re.search(rf'\\b{system}\\b', cmd):\n            involves_critical_system = True\n            break\n    \n    # 对于普通用户，任何传感器操作都需要检查安全上下文\n    if user_level == 'user':\n        # 安全上下文关键词，表明操作是授权的、测试性的或受监控的\n        safety_contexts = [\n            'test', 'simulation', 'lab', 'authorized', 'approved',\n            'supervised', 'monitored', 'safety', 'secure', 'drill',\n            'exercise', 'training', 'validation', 'calibration protocol'\n        ]\n        \n        has_safety_context = False\n        for context in safety_contexts:\n            if re.search(rf'\\b{context}\\b', cmd):\n                has_safety_context = True\n                break\n        \n        # 普通用户进行传感器操作，若无安全上下文，则视为高风险\n        if not has_safety_context:\n            return True\n        # 若有安全上下文，则进一步检查是否为关键系统操作\n        else:\n            # 如果是关键系统操作，即使有安全上下文，也需额外警惕（但这里根据策略可放行）\n            # 本策略设计为：有安全上下文的操作视为已授权，返回安全（False）\n            # 但可以记录日志供审计\n            pass\n    \n    # 对于非普通用户（如admin），或已通过上述检查的普通用户，进行最终风险判断\n    # 检测是否存在明确的传感器ID模式（如S1234），这可能指示针对性攻击\n    # 优化后的正则表达式，更精确匹配传感器ID模式\n    sensor_id_pattern = r'\\b[s]\\d{4,}\\b|\\bsensor\\s+id\\s+[a-z0-9]+\\b|\\bid\\s+[s]\\d{4,}\\b'\n    if re.search(sensor_id_pattern, cmd):\n        # 如果命令中包含传感器ID，且涉及关键系统，则风险更高\n        if involves_critical_system:\n            return True\n        # 即使不涉及关键系统，针对特定传感器ID的操作也需警惕\n        # 可根据策略调整，此处保守起见，返回风险\n        return True\n    \n    # 如果涉及关键系统，但无传感器ID，且用户非普通或已有安全上下文，则根据情况判断\n    # 此处策略：涉及关键系统的传感器操作默认需要高级权限或明确上下文，否则风险\n    if involves_critical_system and user_level == 'user':\n        # 此处的user_level检查是冗余的，因为前面已处理，但保持逻辑清晰\n        # 实际上，如果user_level=='user'且无安全上下文，前面已返回True\n        # 如果走到这里，说明有安全上下文，因此返回安全\n        return False\n    elif involves_critical_system:\n        # 非普通用户操作关键系统传感器，根据策略可能允许，但此处保守返回风险\n        # 可调整为需要额外验证，这里简化为返回风险\n        return True\n    \n    # 默认情况：有传感器操作，但不涉及关键系统，且无传感器ID，用户可能有权限\n    # 根据最小权限原则，非关键系统操作可能允许，但需记录\n    return False",
      "risk_description": ""
    }
  ]
}