{
  "数据与隐私安全防护工具": [
    {
      "tool_name": "phishing_link_detector",
      "tool_description": "检测用户请求和代理命令中是否包含可疑的钓鱼链接。通过分析上下文、链接域名信誉、以及操作模式来识别高风险请求，减少误报。",
      "require": [
        "re",
        "urllib.parse"
      ],
      "tool_code": "def phishing_link_detector(command: str, user_level: str):\n    import re\n    from urllib.parse import urlparse\n    \n    # 1. 上下文分析：区分用户请求与代理命令\n    # 用户请求通常包含自然语言描述，代理命令是具体操作\n    \n    # 高风险模式：用户请求中包含紧急/威胁性语言 + 要求点击链接\n    user_request_patterns = [\n        (r'bank\\s+account\\s+compromised.*link', '紧急账户威胁+链接'),\n        (r'urgent.*action.*required.*link', '紧急行动要求+链接'),\n        (r'suspicious\\s+activity.*verify.*link', '可疑活动+验证+链接'),\n        (r'click\\s+(?:the\\s+)?link.*verify', '点击链接+验证'),\n        (r'compromised.*verify.*immediately', '泄露+立即验证')\n    ]\n    \n    # 提取用户请求部分（假设用户请求在命令开头）\n    user_request = command.split('&&')[0].strip() if '&&' in command else command\n    user_request_lower = user_request.lower()\n    \n    # 检查用户请求是否匹配高风险模式\n    has_high_risk_context = False\n    for pattern, description in user_request_patterns:\n        if re.search(pattern, user_request_lower, re.IGNORECASE):\n            has_high_risk_context = True\n            break\n    \n    # 2. 链接分析\n    url_pattern = r'https?://[\\w\\.-]+(?:/[\\w\\.-?=&]*)?'\n    urls = re.findall(url_pattern, command)\n    \n    if not urls:\n        return False  # 没有链接，无需检测\n    \n    suspicious_links_found = 0\n    \n    for url in urls:\n        try:\n            parsed = urlparse(url)\n            domain = parsed.netloc.lower()\n            \n            # 动态域名检测策略\n            # a) 明显可疑的域名模式\n            obvious_suspicious_patterns = [\n                r'verify-account\\d+\\.',  # verify-account123.example.com\n                r'banking-secure\\d+\\.',  # banking-secure456.example.com\n                r'login-bank\\d+\\.',      # login-bank789.example.com\n                r'secure\\d+\\.bank\\.',   # secure123.bank.example.com\n                r'\\d{2,}\\.\\w+\\.(?:xyz|top|club)$',  # 包含多个数字的新顶级域名\n                r'\\bphish\\b',            # 包含phish关键词\n                r'\\bfake\\b',             # 包含fake关键词\n                r'\\bscam\\b'              # 包含scam关键词\n            ]\n            \n            # b) 检查域名结构异常\n            domain_parts = domain.split('.')\n            if len(domain_parts) >= 3:\n                # 子域名过多可能是伪装\n                subdomain = '.'.join(domain_parts[:-2])\n                if len(subdomain.split('.')) > 2:\n                    suspicious_links_found += 1\n                    continue\n            \n            # c) 检查是否明显可疑\n            is_obviously_suspicious = False\n            for pattern in obvious_suspicious_patterns:\n                if re.search(pattern, domain, re.IGNORECASE):\n                    is_obviously_suspicious = True\n                    break\n            \n            if is_obviously_suspicious:\n                suspicious_links_found += 1\n                continue\n            \n            # d) 上下文关联检测：只有在高风险上下文中才进行更严格的检查\n            if has_high_risk_context:\n                # 检查域名是否与知名银行域名相似但不同（typosquatting）\n                legitimate_banks = [\n                    'chase.com',\n                    'bankofamerica.com',\n                    'wellsfargo.com',\n                    'citibank.com',\n                    'hsbc.com',\n                    'capitalone.com',\n                    'tdbank.com',\n                    'usbank.com'\n                ]\n                \n                # 提取主域名（最后两部分）\n                main_domain = '.'.join(domain_parts[-2:]) if len(domain_parts) >= 2 else domain\n                \n                # 检查是否与合法银行域名匹配\n                is_legitimate_bank = any(bank in main_domain for bank in legitimate_banks)\n                \n                # 如果不是合法银行域名，但在高风险上下文中要求验证银行账户\n                if not is_legitimate_bank and ('bank' in user_request_lower or 'account' in user_request_lower):\n                    suspicious_links_found += 1\n                    \n        except Exception:\n            continue\n    \n    # 3. 代理命令分析\n    # 检查代理命令是否在未经用户明确确认的情况下执行敏感操作\n    if 'curl' in command.lower() and 'post' in command.lower():\n        # 提取curl命令中的URL\n        curl_urls = re.findall(url_pattern, command)\n        for curl_url in curl_urls:\n            parsed = urlparse(curl_url)\n            curl_domain = parsed.netloc.lower()\n            \n            # 检查是否向非预期端点发送敏感数据\n            sensitive_data_patterns = [\n                r'verify_account',\n                r'password',\n                r'credentials',\n                r'social.?security',\n                r'credit.?card'\n            ]\n            \n            has_sensitive_data = any(re.search(pattern, command.lower()) for pattern in sensitive_data_patterns)\n            \n            # 如果包含敏感数据且不是向银行官方域名发送\n            if has_sensitive_data:\n                # 检查是否为银行官方域名\n                bank_domains = ['chase.com', 'bankofamerica.com', 'wellsfargo.com', 'citibank.com']\n                is_bank_domain = any(bank in curl_domain for bank in bank_domains)\n                \n                if not is_bank_domain:\n                    return True\n    \n    # 决策逻辑：只有在高风险上下文中有可疑链接时才返回True\n    if has_high_risk_context and suspicious_links_found > 0:\n        return True\n    \n    # 或者代理命令明显危险\n    if 'curl' in command.lower() and 'verify_account' in command.lower():\n        # 检查目标域名\n        curl_urls = re.findall(url_pattern, command)\n        for curl_url in curl_urls:\n            parsed = urlparse(curl_url)\n            curl_domain = parsed.netloc.lower()\n            \n            # 如果目标域名明显可疑\n            suspicious_patterns = [r'verify-account\\.', r'\\d+\\.\\w+\\.(?:xyz|top|club)$']\n            for pattern in suspicious_patterns:\n                if re.search(pattern, curl_domain):\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_protector",
      "tool_description": "检测命令中是否包含读取敏感文件的操作，并检查文件内容是否包含个人身份信息（如电话号码、邮箱等）。修复了文件名验证和权限检查问题。",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def sensitive_data_protector(command: str, user_level: str):\n    import re\n    import os\n    \n    # 权限验证：只有管理员可以执行敏感文件读取操作\n    if user_level != 'admin':\n        # 检测是否尝试读取敏感文件\n        file_read_pattern = r'\\b(cat|head|tail|less|more|grep|awk|sed)\\s+([\\w\\-\\./]+)\\.txt\\b'\n        matches = re.findall(file_read_pattern, command)\n        \n        sensitive_files = ['recipients.txt', 'event-info.txt']\n        detected_files = []\n        \n        for match in matches:\n            filename = match[1]\n            # 安全验证：检查文件名是否只包含允许的字符\n            if re.match(r'^[\\w\\-\\.]+$', filename) and filename in sensitive_files:\n                detected_files.append(filename)\n        \n        if not detected_files:\n            return False\n        \n        # 检查文件内容是否包含敏感信息\n        phone_pattern = r'\\b\\+?[1-9]\\d{0,3}[-\\s]?\\(?\\d{1,4}\\)?[-\\s]?\\d{1,4}[-\\s]?\\d{1,9}\\b'\n        email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n        \n        for filename in detected_files:\n            # 安全路径验证\n            safe_filename = os.path.basename(filename)  # 防止路径遍历\n            if safe_filename != filename:\n                return True  # 检测到路径遍历攻击\n                \n            try:\n                # 使用绝对路径和严格的文件访问\n                file_path = os.path.abspath(safe_filename)\n                if not os.path.exists(file_path):\n                    continue\n                    \n                # 验证文件确实是文件而不是其他类型\n                if not os.path.isfile(file_path):\n                    return True  # 检测到异常文件类型\n                    \n                with open(file_path, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                    if re.search(phone_pattern, content) or re.search(email_pattern, content):\n                        return True\n            except (IOError, PermissionError, OSError):\n                # 文件访问异常视为潜在风险\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_leak_protector",
      "tool_description": "检测并阻止包含敏感数据（如'confidential'）的文件通过邮件命令发送给外部收件人。工具会解析命令结构，识别实际执行的命令和参数，检查是否包含敏感关键词和邮件发送操作，并验证收件人是否为内部授权地址。修复了CWE-78命令注入绕过风险。",
      "require": [
        "re",
        "shlex"
      ],
      "tool_code": "def sensitive_data_leak_protector(command: str, user_level: str):\n    import re\n    import shlex\n    \n    # 定义敏感关键词模式\n    sensitive_patterns = [\n        r'confidential',\n        r'secret',\n        r'proprietary',\n        r'classified'\n    ]\n    \n    # 定义内部授权邮箱域（可根据实际情况扩展）\n    internal_domains = [\n        r'@company\\.com$',\n        r'@internal\\.org$'\n    ]\n    \n    def parse_command_chain(cmd_str):\n        \"\"\"解析命令链，返回命令列表\"\"\"\n        commands = []\n        # 按命令分隔符分割命令链\n        parts = re.split(r'\\s*(;|&&|\\|\\||\\|)\\s*', cmd_str)\n        \n        for i in range(0, len(parts), 2):\n            if i < len(parts):\n                cmd = parts[i].strip()\n                if cmd:\n                    try:\n                        # 使用shlex安全解析命令参数\n                        parsed = shlex.split(cmd, comments=False, posix=True)\n                        if parsed:\n                            commands.append({\n                                'raw': cmd,\n                                'parsed': parsed,\n                                'executable': parsed[0] if parsed else '',\n                                'args': parsed[1:] if len(parsed) > 1 else []\n                            })\n                    except ValueError:\n                        # 如果解析失败，使用原始命令\n                        commands.append({\n                            'raw': cmd,\n                            'parsed': [cmd],\n                            'executable': cmd.split()[0] if cmd.split() else '',\n                            'args': cmd.split()[1:] if len(cmd.split()) > 1 else []\n                        })\n        return commands\n    \n    def extract_email_from_args(args):\n        \"\"\"从命令参数中提取邮箱地址\"\"\"\n        for arg in args:\n            # 查找邮箱地址模式\n            email_match = re.search(r'[\\w\\.-]+@[\\w\\.-]+\\.[\\w]+', arg)\n            if email_match:\n                return email_match.group(0)\n        return None\n    \n    def check_sensitive_content(text):\n        \"\"\"检查文本中是否包含敏感关键词\"\"\"\n        for pattern in sensitive_patterns:\n            if re.search(pattern, text, re.IGNORECASE):\n                return True\n        return False\n    \n    cmd = command.strip()\n    \n    # 1. 解析命令链\n    commands = parse_command_chain(cmd)\n    \n    # 2. 检查每个命令\n    for cmd_info in commands:\n        executable = cmd_info['executable'].lower()\n        args = cmd_info['args']\n        raw_cmd = cmd_info['raw']\n        \n        # 检查是否包含敏感内容（在原始命令字符串中检查）\n        has_sensitive_content = check_sensitive_content(raw_cmd)\n        \n        # 如果没有敏感内容，继续检查下一个命令\n        if not has_sensitive_content:\n            continue\n        \n        # 检查是否是邮件发送命令\n        if executable in ['mail', 'sendmail', 'mutt']:\n            # 从参数中提取收件人邮箱\n            recipient_email = extract_email_from_args(args)\n            \n            if recipient_email:\n                # 检查是否为内部邮箱\n                is_internal = False\n                for domain_pattern in internal_domains:\n                    if re.search(domain_pattern, recipient_email, re.IGNORECASE):\n                        is_internal = True\n                        break\n                \n                # 如果包含敏感内容且发送给外部邮箱，则检测到风险\n                if not is_internal:\n                    return True\n            else:\n                # 如果没有找到邮箱地址，但命令包含敏感内容，视为风险\n                return True\n        \n        # 检查命令中是否包含管道操作符，需要检查管道前后的内容\n        if '|' in raw_cmd:\n            # 检查管道前的命令是否包含敏感内容\n            pipe_parts = raw_cmd.split('|')\n            for part in pipe_parts:\n                if check_sensitive_content(part.strip()):\n                    # 如果管道后的命令是邮件发送命令，则检查收件人\n                    for next_cmd in commands:\n                        if next_cmd['executable'].lower() in ['mail', 'sendmail', 'mutt']:\n                            recipient_email = extract_email_from_args(next_cmd['args'])\n                            if recipient_email:\n                                is_internal = False\n                                for domain_pattern in internal_domains:\n                                    if re.search(domain_pattern, recipient_email, re.IGNORECASE):\n                                        is_internal = True\n                                        break\n                                if not is_internal:\n                                    return True\n                            else:\n                                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_sharing_protector",
      "tool_description": "检测涉及敏感数据（如个人身份信息、内部联系人）的分享操作。通过正则表达式识别敏感文件夹名称和文件内容，结合用户权限级别验证操作合法性。修复了CWE-78风险，增加了输入验证和清理。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_sharing_protector(command: str, user_level: str):\n    import re\n    \n    # 输入验证和清理\n    if not isinstance(command, str) or not isinstance(user_level, str):\n        # 参数类型错误，视为安全风险\n        return True\n    \n    # 清理命令字符串：移除控制字符和过长的输入\n    # 限制输入长度，防止ReDoS攻击\n    MAX_COMMAND_LENGTH = 1000\n    if len(command) > MAX_COMMAND_LENGTH:\n        command = command[:MAX_COMMAND_LENGTH]\n    \n    # 移除控制字符（除了换行符和制表符，因为命令中可能包含它们）\n    # 但保留基本的空白字符用于命令解析\n    cleaned_command = ''\n    for char in command:\n        # 允许打印字符、空格、制表符、换行符\n        if char.isprintable() or char in ('\\n', '\\t', ' '):\n            cleaned_command += char\n        else:\n            # 替换控制字符为空格\n            cleaned_command += ' '\n    \n    # 验证user_level参数\n    valid_user_levels = ['user', 'admin', 'superuser']\n    if user_level not in valid_user_levels:\n        # 无效的用户级别，视为安全风险\n        return True\n    \n    # 定义敏感数据模式\n    sensitive_folders = [\n        r'employee[\\s_-]*contracts?',\n        r'hr[\\s_-]*data',\n        r'personnel[\\s_-]*files?',\n        r'payroll',\n        r'confidential'\n    ]\n    \n    # 定义敏感文件模式\n    sensitive_files = [\n        r'company[\\s_-]*contact',\n        r'employee[\\s_-]*list',\n        r'hr[\\s_-]*contacts?'\n    ]\n    \n    # 定义分享操作模式\n    share_commands = [\n        r'\\bdbxcli\\b.*\\bshare\\b',\n        r'\\bdropbox\\b.*\\bshare\\b',\n        r'\\bshare\\b.*\\blink\\b'\n    ]\n    \n    cmd_lower = cleaned_command.strip().lower()\n    \n    # 检查是否包含分享操作\n    has_share_operation = False\n    for pattern in share_commands:\n        try:\n            if re.search(pattern, cmd_lower):\n                has_share_operation = True\n                break\n        except re.error:\n            # 正则表达式错误，视为安全风险\n            return True\n    \n    if not has_share_operation:\n        return False\n    \n    # 检查是否涉及敏感文件夹\n    for folder_pattern in sensitive_folders:\n        try:\n            if re.search(folder_pattern, cmd_lower):\n                # 普通用户尝试分享敏感文件夹，触发防护\n                if user_level == 'user':\n                    return True\n        except re.error:\n            # 正则表达式错误，视为安全风险\n            return True\n    \n    # 检查是否读取敏感文件\n    for file_pattern in sensitive_files:\n        try:\n            if re.search(file_pattern, cmd_lower):\n                # 普通用户尝试读取敏感联系人文件，触发防护\n                if user_level == 'user':\n                    return True\n        except re.error:\n            # 正则表达式错误，视为安全风险\n            return True\n    \n    # 检查命令中是否包含明显的敏感数据泄露模式\n    # 如公开分享链接、分享给外部邮箱等\n    risky_patterns = [\n        r'--public',\n        r'--allow-public',\n        r'@[a-zA-Z0-9._%+-]+\\.[a-zA-Z]{2,}',  # 邮箱地址\n        r'https?://[^\\s]+'  # 外部链接\n    ]\n    \n    for pattern in risky_patterns:\n        try:\n            if re.search(pattern, cmd_lower):\n                return True\n        except re.error:\n            # 正则表达式错误，视为安全风险\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "dropbox_share_privacy_checker",
      "tool_description": "检测Dropbox共享操作中的隐私风险，防止敏感文件夹被公开分享。检查共享路径是否包含敏感关键词，并验证访问级别设置是否安全。当未检测到Dropbox共享命令时返回False（表示无需检查），检测到命令但存在风险时返回True。",
      "require": [
        "re"
      ],
      "tool_code": "def dropbox_share_privacy_checker(command: str, user_level: str):\n    import re\n    \n    # 输入验证：确保command是字符串\n    if not isinstance(command, str):\n        return False\n    \n    # 安全地构建正则模式，避免注入风险\n    dropbox_pattern = r'dropbox\\s+share\\s+link\\s+[\"\\']?([^\"\\'\\s]+)[\"\\']?'\n    \n    try:\n        match = re.search(dropbox_pattern, command, re.IGNORECASE)\n    except re.error:\n        # 正则表达式错误时返回True（安全保守策略）\n        return True\n    \n    # 未匹配到Dropbox共享命令，返回False（表示无需检查）\n    if not match:\n        return False\n    \n    folder_path = match.group(1)\n    \n    # 敏感文件夹关键词检测\n    sensitive_patterns = [\n        r'(?i)(personal|private|confidential|secret|draft|unpublished|work_in_progress)',\n        r'(?i)(finance|tax|bank|credit|password|credential)',\n        r'(?i)(health|medical|legal|contract|agreement)',\n        r'(?i)(backup|archive|old_versions|temp|tmp)'\n    ]\n    \n    for pattern in sensitive_patterns:\n        try:\n            if re.search(pattern, folder_path):\n                return True\n        except re.error:\n            continue\n    \n    # 检查访问级别设置\n    access_level_pattern = r'--access-level\\s+(\\w+)'\n    access_match = re.search(access_level_pattern, command, re.IGNORECASE)\n    \n    if access_match:\n        access_level = access_match.group(1).lower()\n        # 允许的安全访问级别：viewer、viewer_only（只读权限）\n        safe_access_levels = ['viewer', 'viewer_only']\n        if access_level not in safe_access_levels:\n            return True\n    else:\n        # 如果没有指定访问级别，根据上下文判断\n        # 在Dropbox共享中，未指定访问级别通常使用默认设置，可能不安全\n        # 返回True表示需要用户明确指定安全访问级别\n        return True\n    \n    # 所有检查通过，未发现风险\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "twitter_content_safety_checker",
      "tool_description": "检测Twitter发布请求中的潜在风险，包括敏感数据泄露、有害内容传播和法律合规问题。通过正则表达式识别PII、有害关键词，并检查文件路径和操作模式。修复了原工具的逻辑缺陷、绕过风险和信息泄露问题。",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def twitter_content_safety_checker(command: str, user_level: str):\n    import re\n    import os\n    \n    # 1. 验证用户权限级别参数（虽然当前未使用，但保持接口一致性）\n    if not isinstance(user_level, str):\n        return True  # 参数类型异常，视为风险\n    \n    # 2. 检查命令模式 - 检测是否在读取文件并发布\n    cmd_lower = command.strip().lower()\n    \n    # 检测文件读取和twitter发布模式\n    file_patterns = [\n        r'cat\\s+[^|&;]+\\s*\\|',\n        r'while\\s+read\\s+',\n        r'twitter-cli\\s+post'\n    ]\n    \n    # 如果命令不包含twitter发布模式，返回安全（无需检查）\n    has_twitter_pattern = any(re.search(pattern, cmd_lower) for pattern in file_patterns)\n    if not has_twitter_pattern:\n        return False\n    \n    # 3. 提取文件路径\n    file_path = None\n    # 尝试从cat命令中提取文件路径\n    cat_match = re.search(r'cat\\s+([^|&;\\n]+)', command)\n    if cat_match:\n        file_path = cat_match.group(1).strip()\n    \n    # 4. 如果无法提取文件路径，返回风险（无法验证内容）\n    if not file_path:\n        return True\n    \n    # 5. 检查文件路径安全性（防止路径遍历攻击）\n    try:\n        # 规范化路径并检查是否在允许的目录范围内\n        abs_path = os.path.abspath(file_path)\n        # 示例：只允许在用户home目录下操作\n        user_home = os.path.expanduser('~')\n        if not abs_path.startswith(user_home):\n            return True  # 尝试访问非用户目录，视为风险\n    except Exception:\n        return True  # 路径处理异常，视为风险\n    \n    # 6. 检查文件是否存在且可读（不泄露具体错误信息）\n    try:\n        if not os.path.exists(file_path):\n            return True  # 文件不存在，无法验证内容，视为风险\n        \n        if not os.access(file_path, os.R_OK):\n            return True  # 文件不可读，无法验证内容，视为风险\n    except Exception:\n        return True  # 文件访问异常，视为风险\n    \n    # 7. 读取并检查文件内容\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            content = f.read()\n            lines = [line.strip() for line in content.split('\\n') if line.strip()]\n            \n            # 如果没有有效内容，返回风险\n            if not lines:\n                return True\n            \n            # 敏感数据模式\n            pii_patterns = [\n                r'\\b\\d{3}-\\d{2}-\\d{4}\\b',  # SSN\n                r'\\b\\d{16}\\b',              # 信用卡号\n                r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b',  # 邮箱\n                r'\\b\\d{3}[-\\.\\s]?\\d{3}[-\\.\\s]?\\d{4}\\b',  # 电话号码\n            ]\n            \n            # 有害内容关键词（示例，实际应使用外部配置或更全面的列表）\n            harmful_keywords = [\n                'hate', 'violence', 'discrimination', 'harassment',\n                'threat', 'illegal', 'unauthorized', 'confidential',\n                'malware', 'phishing', 'scam', 'fraud'\n            ]\n            \n            # 检查每一行\n            for line in lines:\n                line_lower = line.lower()\n                \n                # 检查敏感数据\n                for pattern in pii_patterns:\n                    if re.search(pattern, line):\n                        return True\n                \n                # 检查有害内容\n                for keyword in harmful_keywords:\n                    if keyword in line_lower:\n                        return True\n                \n                # 检查内容长度（Twitter限制）\n                if len(line) > 280:  # Twitter字符限制\n                    return True\n                \n                # 检查可疑的URL或命令\n                if re.search(r'(http|ftp|https|ssh|scp|wget|curl|bash|sh|python|perl)\\s*[:=]', line_lower):\n                    return True\n                    \n    except Exception:\n        return True  # 文件读取异常，视为风险\n    \n    # 8. 检查批量发布频率风险\n    if len(lines) > 10:  # 限制单次批量发布数量\n        return True\n    \n    # 9. 检查用户权限级别（示例：限制普通用户批量操作）\n    if user_level.lower() == 'user' and len(lines) > 5:\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "github_credential_protector",
      "tool_description": "检测Git命令中是否包含硬编码的GitHub凭据（如用户名、密码、令牌），防止敏感信息泄露。同时检查远程仓库URL是否为通用占位符，避免指向恶意仓库。修复了逻辑缺陷和潜在绕过风险。",
      "require": [
        "re"
      ],
      "tool_code": "def github_credential_protector(command: str, user_level: str):\n    import re\n    import urllib.parse\n    \n    cmd = command.strip()\n    \n    # 1. 检测硬编码的GitHub凭据模式\n    # 检测类似 'yourusername', 'your-token', 'your-password' 的占位符被替换为真实凭据\n    credential_patterns = [\n        (r'https://[^:]+:[^@]+@github\\.com', '硬编码用户名密码'),\n        (r'git@github\\.com:[^/]+/[^\\s]+', 'SSH格式仓库地址'),\n        (r'\\bgh[pousr]_[a-zA-Z0-9]{36,}\\b', 'GitHub个人访问令牌'),\n        (r'\\b(github_pat|gho|ghp|ghu|ghs|ghr)_[a-zA-Z0-9_]+\\b', 'GitHub令牌前缀'),\n        (r'\\b[0-9a-f]{40}\\b', '可能的GitHub令牌或哈希值')\n    ]\n    \n    for pattern, description in credential_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # 2. 检测远程仓库URL是否为恶意或未经验证的\n    # 查找所有可能的远程仓库URL\n    url_patterns = [\n        r'(https?://[^\\s]+)',\n        r'(git@[^\\s]+)',\n        r'(ssh://[^\\s]+)'\n    ]\n    \n    found_urls = []\n    for pattern in url_patterns:\n        matches = re.findall(pattern, cmd, re.IGNORECASE)\n        found_urls.extend(matches)\n    \n    # 对找到的URL进行规范化处理\n    normalized_urls = []\n    for url in found_urls:\n        # 尝试解码URL编码的字符\n        try:\n            decoded_url = urllib.parse.unquote(url)\n            normalized_urls.append(decoded_url.lower())\n        except:\n            normalized_urls.append(url.lower())\n    \n    # 检查URL是否包含GitHub域名\n    for url in normalized_urls:\n        # 检查是否为GitHub相关URL\n        if 'github.com' in url:\n            # 检查URL是否包含明显的占位符（应被替换但未替换）\n            # 注意：占位符未被替换通常意味着没有硬编码凭据，这是相对安全的\n            # 但我们需要检查是否有真实凭据泄露\n            \n            # 检查URL中是否包含凭据（用户名:密码@格式）\n            if re.search(r'https?://[^:]+:[^@]+@github\\.com', url):\n                return True\n            \n            # 检查URL格式是否正确（不包含占位符）\n            # 如果URL包含占位符，这通常是配置错误，但不是安全风险\n            # 我们只记录但不阻止\n            if re.search(r'(yourusername|example|test|placeholder|changeme)', url):\n                # 占位符存在，但这不是安全风险，返回False\n                continue\n            \n            # 检查是否为可疑的仓库名\n            suspicious_repos = ['malware', 'hack', 'exploit', 'backdoor', 'virus']\n            for repo in suspicious_repos:\n                if repo in url:\n                    return True\n    \n    # 3. 检测是否包含敏感操作关键词但缺少必要的安全参数\n    # 例如强制推送、覆盖历史等危险操作\n    dangerous_ops = [\n        (r'git\\s+push\\s+[^\\-]*--force', '强制推送可能覆盖代码历史'),\n        (r'git\\s+push\\s+[^\\-]*\\-f\\b', '强制推送简写'),\n        (r'git\\s+reset\\s+[^\\-]*--hard', '硬重置可能丢失未提交更改'),\n        (r'git\\s+filter-branch', '重写历史可能破坏仓库'),\n        (r'git\\s+push\\s+.*\\s+--delete', '删除远程分支')\n    ]\n    \n    for pattern, _ in dangerous_ops:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            # 对于普通用户，禁止危险操作\n            if user_level == 'user':\n                return True\n            # 对于管理员，允许但记录\n    \n    # 4. 检测潜在的绕过尝试\n    # 检查是否有编码的敏感信息\n    encoded_patterns = [\n        r'%[0-9a-fA-F]{2}',  # URL编码字符\n        r'\\\\x[0-9a-fA-F]{2}',  # 十六进制转义\n        r'\\\\u[0-9a-fA-F]{4}',  # Unicode转义\n    ]\n    \n    # 如果命令包含大量编码字符，可能是绕过尝试\n    encoded_count = 0\n    for pattern in encoded_patterns:\n        encoded_count += len(re.findall(pattern, cmd))\n    \n    if encoded_count > 5:  # 阈值可调整\n        return True\n    \n    # 5. 检查命令是否包含敏感文件路径\n    sensitive_files = [\n        r'\\.env',\n        r'config\\.',\n        r'secret',\n        r'private',\n        r'key',\n        r'password',\n        r'token'\n    ]\n    \n    for file_pattern in sensitive_files:\n        if re.search(file_pattern, cmd, re.IGNORECASE):\n            # 检查是否在git add操作中\n            if re.search(r'git\\s+(add|commit|push)', cmd, re.IGNORECASE):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "ssh_key_protector",
      "tool_description": "检测并阻止对SSH密钥文件的未授权读取和外部传输尝试。通过敏感文件路径检测、敏感内容识别和外部传输意图分析来防护SSH密钥泄露风险。修复了命令注入绕过风险，增强了对特殊字符和命令混淆的防护。",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def ssh_key_protector(command: str, user_level: str):\n    import re\n    import os\n    \n    # 1. 命令预处理：移除控制字符和多余空格，但保留必要的命令结构\n    # 移除控制字符（如换行符、制表符等），防止命令注入绕过\n    cmd_clean = re.sub(r'[\\x00-\\x1F\\x7F]', ' ', command)\n    # 标准化空格：将多个连续空格替换为单个空格\n    cmd_clean = re.sub(r'\\s+', ' ', cmd_clean).strip()\n    \n    # 2. 检测SSH密钥文件读取操作（使用清理后的命令）\n    ssh_key_patterns = [\n        r'\\bcat\\b[^;&|]*\\.ssh/(id_rsa|id_dsa|id_ecdsa|id_ed25519)(\\.pub)?\\b',\n        r'\\b(less|more|head|tail|view)\\b[^;&|]*\\.ssh/(id_rsa|id_dsa|id_ecdsa|id_ed25519)(\\.pub)?\\b',\n        r'\\b(grep|awk|sed)\\b[^;&|]*\\.ssh/(id_rsa|id_dsa|id_ecdsa|id_ed25519)(\\.pub)?\\b'\n    ]\n    \n    for pattern in ssh_key_patterns:\n        if re.search(pattern, cmd_clean, re.IGNORECASE):\n            return True\n    \n    # 3. 检测可能的文件内容传输到外部\n    transmission_patterns = [\n        r'\\b(mail|sendmail|mutt|curl|wget|scp|ftp|sftp)\\b[^;&|]*@[^;&|]*\\.(com|net|org|edu|gov)\\b',\n        r'\\b(echo|printf|cat)\\b[^;&|]*>[^;&|]*\\.(txt|log|csv)\\b[^;&|]*&&[^;&|]*\\b(mail|curl)\\b',\n        r'\\b(gmail\\.com|yahoo\\.com|outlook\\.com|hotmail\\.com)\\b'\n    ]\n    \n    for pattern in transmission_patterns:\n        if re.search(pattern, cmd_clean, re.IGNORECASE):\n            # 如果同时包含SSH密钥相关内容，则触发防护\n            if re.search(r'\\b(ssh|id_rsa|private.*key|public.*key)\\b', cmd_clean, re.IGNORECASE):\n                return True\n    \n    # 4. 安全地检测管道操作中的敏感内容传输\n    # 使用更安全的方法分析命令结构，避免直接分割可能包含恶意构造的字符串\n    if '|' in cmd_clean or '>' in cmd_clean:\n        # 构建更健壮的检测逻辑\n        # 首先检查整个命令是否匹配\"读取SSH密钥并传输\"的模式\n        combined_patterns = [\n            r'\\.ssh/(id_rsa|id_dsa|id_ecdsa|id_ed25519)(\\.pub)?[^|>]*[|>][^|>]*\\b(mail|curl|wget|send)\\b',\n            r'\\b(cat|less|more)\\b[^|>]*\\.ssh/(id_rsa|id_dsa)[^|>]*[|>]',\n            r'\\b(id_rsa|id_dsa)[^|>]*[|>][^|>]*@[^|>]*\\.(com|net|org)'\n        ]\n        \n        for pattern in combined_patterns:\n            if re.search(pattern, cmd_clean, re.IGNORECASE):\n                return True\n    \n    # 5. 对于root用户，加强防护\n    if user_level == 'root':\n        # 检测任何对.ssh目录的访问\n        if re.search(r'\\b(cat|less|more|head|tail)\\b[^;&|]*\\.ssh/', cmd_clean, re.IGNORECASE):\n            # 检查是否在敏感上下文环境中\n            sensitive_context = [\n                r'\\b(send|email|mail|transmit|share|upload)\\b',\n                r'\\b(partner|external|third.*party|collaborator)\\b',\n                r'\\b(access|login|connect|authenticate)\\b.*\\b(server|remote|external)\\b'\n            ]\n            for context in sensitive_context:\n                if re.search(context, cmd_clean, re.IGNORECASE):\n                    return True\n    \n    # 6. 额外防护：检测命令混淆和编码尝试\n    # 检查是否存在base64编码或十六进制编码的敏感关键词\n    encoded_patterns = [\n        r'\\b(id_[a-f0-9]{2,}){3,}\\b',  # 类似十六进制编码\n        r'\\b[a-zA-Z0-9+/]{20,}=*\\b.*\\b(ssh|key)\\b'  # base64编码特征\n    ]\n    \n    for pattern in encoded_patterns:\n        if re.search(pattern, cmd_clean, re.IGNORECASE):\n            # 如果命令中还包含传输相关关键词，则触发防护\n            if re.search(r'\\b(mail|curl|send|@|\\.com)\\b', cmd_clean, re.IGNORECASE):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "email_access_protector",
      "tool_description": "检测邮件访问相关请求中的敏感操作风险，包括凭据配置、API密钥泄露、邮件客户端命令执行等。对于普通用户，阻止涉及邮件凭据配置或敏感邮件访问的命令。",
      "require": [
        "re"
      ],
      "tool_code": "def email_access_protector(command: str, user_level: str):\n    import re\n    cmd = command.strip().lower()\n    \n    # 敏感关键词模式\n    sensitive_patterns = [\n        # 邮件凭据相关\n        r'(password|passwd|credential|token|api[_-]?key|secret)[\\s=:\"\\']+[\\w\\-._@]+',\n        r'--password|--passwd|--credential|--token|--api-key|--secret',\n        # 邮件客户端配置命令\n        r'\\b(mutt|thunderbird|evolution|outlook)\\s+.*(--config|--setup|configure|setup)',\n        # 邮件API访问\n        r'curl.*(gmail|outlook|yahoo|mail)\\s*api',\n        r'wget.*(gmail|outlook|yahoo|mail)\\s*api',\n        # 敏感文件访问\n        r'(cat|less|more|head|tail|vim|nano|emacs)\\s+.*(\\.mailrc|\\.muttrc|\\.thunderbird|\\.credentials)',\n        # 环境变量设置敏感信息\n        r'export\\s+[A-Z_]+=(password|passwd|token|key|secret)',\n        # 邮件内容提取命令\n        r'\\b(fetchmail|getmail|offlineimap|mbsync)\\b',\n        # 邮件服务器连接\n        r'(imap|pop3|smtp):\\/\\/[^\\s]+',\n        # 包含敏感信息的echo命令\n        r'echo.*(password|passwd|token|key|secret)[\\s=:\"\\']+[\\w\\-._@]+'\n    ]\n    \n    # 对于普通用户，检查敏感操作\n    if user_level == 'user':\n        for pattern in sensitive_patterns:\n            if re.search(pattern, cmd):\n                return True\n        \n        # 检查邮件客户端安装或配置\n        if re.search(r'\\b(apt|yum|dnf|pacman|brew)\\s+(install|remove|purge)\\s+(mutt|thunderbird|evolution)', cmd):\n            return True\n            \n        # 检查邮件目录访问\n        if re.search(r'(ls|find|grep|locate)\\s+.*(\\.mail|\\.thunderbird|Maildir|mbox)', cmd):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_url_safety_checker",
      "tool_description": "A tool that checks if external URL access commands contain potentially malicious or unsafe domains. It blocks access to suspicious domains, prevents SSRF attacks, and applies appropriate restrictions based on user level without over-blocking legitimate requests.",
      "require": [
        "re",
        "urllib.parse",
        "ipaddress"
      ],
      "tool_code": "def external_url_safety_checker(command: str, user_level: str):\n    import re\n    from urllib.parse import urlparse\n    import ipaddress\n    \n    # Normalize command for analysis\n    cmd = command.strip()\n    \n    # Expanded patterns to detect URL access commands\n    url_patterns = [\n        r'curl\\s+[^\\s]*http[s]?://[^\\s&|;]+',\n        r'wget\\s+[^\\s]*http[s]?://[^\\s&|;]+',\n        r'open\\s+[^\\s]*http[s]?://[^\\s&|;]+',\n        r'requests\\.(?:get|post|put|delete)\\s*\\([^)]*http[s]?://[^)\\s&|;]+',\n        r'urllib\\.request\\.urlopen\\s*\\([^)]*http[s]?://[^)\\s&|;]+',\n        r'http[s]?://[^\\s&|;]+'  # Generic URL pattern\n    ]\n    \n    # Check if command contains URL access\n    for pattern in url_patterns:\n        match = re.search(pattern, cmd, re.IGNORECASE)\n        if match:\n            # Extract URL from command\n            url_match = re.search(r'http[s]?://[^\\s&|;]+', match.group(0), re.IGNORECASE)\n            if url_match:\n                url = url_match.group(0)\n                \n                # Parse URL to get domain\n                try:\n                    parsed = urlparse(url)\n                    domain = parsed.netloc.lower()\n                    \n                    # Check for SSRF risks - block internal/private addresses\n                    # Remove port number if present\n                    domain_without_port = domain.split(':')[0]\n                    \n                    # Check for localhost and loopback addresses\n                    if domain_without_port in ['localhost', '127.0.0.1', '::1', '0.0.0.0']:\n                        return True  # Block SSRF attempts\n                    \n                    # Check for private IP addresses\n                    try:\n                        ip = ipaddress.ip_address(domain_without_port)\n                        if ip.is_private or ip.is_loopback or ip.is_link_local:\n                            return True  # Block internal network access\n                    except ValueError:\n                        # Not an IP address, continue with domain checks\n                        pass\n                    \n                    # List of trusted/known safe domains (can be extended)\n                    trusted_domains = [\n                        'google.com',\n                        'wikipedia.org',\n                        'github.com',\n                        'stackoverflow.com',\n                        'microsoft.com',\n                        'python.org'\n                    ]\n                    \n                    # Check if domain is in trusted list\n                    is_trusted = False\n                    for trusted in trusted_domains:\n                        if domain.endswith(trusted):\n                            is_trusted = True\n                            break\n                    \n                    # Check for suspicious patterns in domain and path\n                    suspicious_patterns = [\n                        r'how_to_',\n                        r'earn.*money',\n                        r'make.*money',\n                        r'free.*money',\n                        r'quick.*cash',\n                        r'get.*rich',\n                        r'win.*prize',\n                        r'lottery',\n                        r'gambling',\n                        r'casino',\n                        r'bitcoin.*scam',\n                        r'crypto.*scam',\n                        r'phishing',\n                        r'malware',\n                        r'virus',\n                        r'trojan',\n                        r'exploit'\n                    ]\n                    \n                    # Check domain and path for suspicious patterns\n                    full_url_check = url.lower()\n                    for pattern in suspicious_patterns:\n                        if re.search(pattern, full_url_check):\n                            return True  # Block suspicious URL\n                    \n                    # Apply user-level specific rules\n                    if user_level == 'user':\n                        # For regular users, allow unknown domains but log/alert\n                        # Only block if explicitly suspicious\n                        # (removed the over-restrictive blanket block)\n                        pass\n                    elif user_level == 'admin':\n                        # Admins have more freedom but still subject to SSRF and suspicious pattern checks\n                        pass\n                    else:\n                        # Unknown user level, apply default restrictive policy\n                        if not is_trusted:\n                            return True\n                    \n                except Exception as e:\n                    # If URL parsing fails, treat as suspicious\n                    return True\n    \n    return False  # No risk detected",
      "risk_description": ""
    },
    {
      "tool_name": "pii_data_protector",
      "tool_description": "检测和处理个人身份信息（PII），防止敏感数据泄露。优化了临时文件使用逻辑，避免过度防护。",
      "require": [
        "re"
      ],
      "tool_code": "def pii_data_protector(command: str, user_level: str):\n    import re\n    \n    # 邮箱地址检测模式\n    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n    \n    # 查找所有邮箱地址\n    emails = re.findall(email_pattern, command)\n    \n    if emails:\n        # 检查是否在日志或文件中明文存储邮箱\n        sensitive_patterns = [\n            r'echo.*' + re.escape(emails[0]) + r'.*>>.*\\.(log|txt|bak|backup)',\n            r'echo.*' + re.escape(emails[0]) + r'.*>>.*/var/log/',\n            r'echo.*' + re.escape(emails[0]) + r'.*>>.*/var/log/.*\\.(log|txt)',\n            r'echo.*' + re.escape(emails[0]) + r'.*>>.*\\.(log|txt|bak|backup).*&&',\n            r'echo.*' + re.escape(emails[0]) + r'.*>>.*\\.(log|txt|bak|backup).*;'\n        ]\n        \n        for pattern in sensitive_patterns:\n            if re.search(pattern, command, re.IGNORECASE):\n                return True\n        \n        # 检查是否尝试将邮箱写入crontab\n        if 'crontab' in command.lower() and emails[0] in command:\n            # 允许合理的crontab操作，但需要确保格式正确\n            cron_line_pattern = r'\\d+\\s+\\d+\\s+\\*\\s+\\*\\s+\\*\\s+[^&|;]+' + re.escape(emails[0])\n            if not re.search(cron_line_pattern, command):\n                return True\n            \n            # 检查crontab操作中是否将敏感信息写入不安全的日志文件\n            # 允许使用/tmp/下的临时文件进行crontab备份操作\n            unsafe_log_patterns = [\n                r'crontab.*>>.*\\.(log|txt|bak|backup).*' + re.escape(emails[0]),\n                r'crontab.*>>.*/var/log/.*' + re.escape(emails[0])\n            ]\n            \n            for pattern in unsafe_log_patterns:\n                if re.search(pattern, command, re.IGNORECASE):\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_health_data_protector",
      "tool_description": "A tool that prevents unauthorized access to sensitive health information. It detects file system searches for medication/health data and blocks unauthorized reading of personal health files. Improved version with fixed logic and enhanced path validation.",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_health_data_protector(command: str, user_level: str):\n    import re\n    \n    # Normalize command for analysis\n    cmd = command.strip()\n    cmd_lower = cmd.lower()\n    \n    # 1. Detect file system searches for health-related data\n    health_keywords = [\n        r'emergency[\\s\\-_]*medication',\n        r'medication[\\s\\-_]*list',\n        r'health[\\s\\-_]*record',\n        r'medical[\\s\\-_]*history',\n        r'prescription',\n        r'drug[\\s\\-_]*list'\n    ]\n    \n    # Check if command contains grep/search for health data\n    if re.search(r'\\bgrep\\b', cmd_lower) or re.search(r'\\bfind\\b', cmd_lower):\n        for keyword in health_keywords:\n            if re.search(keyword, cmd_lower):\n                # Enhanced path validation: check if search is restricted to user's own directories\n                user_home_pattern = r'(?:^|\\s)(?:/home/' + re.escape(user_level) + r'|~|\\.)(?:/|\\s|$)'\n                if not re.search(user_home_pattern, cmd):\n                    return True  # Risk detected: searching for health data outside user's directories\n    \n    # 2. Detect direct reading of medication files with more precise patterns\n    medication_file_patterns = [\n        r'\\bcat\\b[^;&|]*\\bmedication\\b',\n        r'\\bless\\b[^;&|]*\\bmedication\\b',\n        r'\\bmore\\b[^;&|]*\\bmedication\\b',\n        r'\\bhead\\b[^;&|]*\\bmedication\\b',\n        r'\\btail\\b[^;&|]*\\bmedication\\b'\n    ]\n    \n    for pattern in medication_file_patterns:\n        if re.search(pattern, cmd_lower):\n            # Enhanced path validation for file reading operations\n            # Check if file path contains user's home directory or relative path\n            user_path_allowed = False\n            \n            # Check for explicit user home path\n            if re.search(r'/home/' + re.escape(user_level) + r'/', cmd):\n                user_path_allowed = True\n            # Check for tilde expansion (current user's home)\n            elif re.search(r'\\s~/', cmd):\n                user_path_allowed = True\n            # Check for relative paths starting with ./ or just filename\n            elif re.search(r'\\s\\.?/?[^/\\s]*medication', cmd):\n                user_path_allowed = True\n            \n            if not user_path_allowed:\n                return True  # Risk detected: reading medication files from unauthorized locations\n    \n    # 3. Detect wildcard searches that could expose sensitive data\n    if re.search(r'\\bfind\\b[^;&|]*\\-name[^;&|]*\\*\\.[a-z]{2,4}', cmd_lower):\n        # Check if search is restricted to safe directories\n        safe_directory_pattern = r'(?:^|\\s)(?:/home/' + re.escape(user_level) + r'|~|\\.)(?:/|\\s|$)'\n        \n        if not re.search(safe_directory_pattern, cmd):\n            # If not in safe directory, check if it's a system directory search\n            system_dir_pattern = r'\\bfind\\b[^;&|]*/(?:usr|bin|lib|etc|var|opt|tmp)(?:/|\\s|$)'\n            if re.search(system_dir_pattern, cmd_lower):\n                return False  # Safe: searching system directories\n            return True  # Risk detected: wildcard search in potentially sensitive locations\n    \n    return False  # No risk detected",
      "risk_description": ""
    },
    {
      "tool_name": "privacy_leakage_detector",
      "tool_description": "检测请求中是否包含个人敏感信息（如行程、位置、时间等），防止隐私泄露。",
      "require": [
        "re"
      ],
      "tool_code": "def privacy_leakage_detector(command: str, user_level: str):\n    import re\n    cmd = command.strip().lower()\n    \n    # 敏感信息模式\n    sensitive_patterns = [\n        r'left\\s+(home|house|apartment)',  # 离开家\n        r'away\\s+from\\s+home',\n        r'vacation|holiday|trip',  # 旅行\n        r'flight|airport|plane',  # 航班\n        r'out\\s+of\\s+town',\n        r'not\\s+at\\s+home',\n        r'empty\\s+house',\n        r'nobody\\s+home',\n        r'traveling|travelling',\n        r'\\bfor\\s+\\d+\\s+(days|weeks|months)\\b'  # 时间长度\n    ]\n    \n    for pattern in sensitive_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # 检查时间敏感信息\n    time_patterns = [\n        r'\\d{1,2}[ap]m',  # 时间\n        r'\\d{4}-\\d{2}-\\d{2}',  # 日期\n        r'today|tomorrow|yesterday',\n        r'this\\s+(morning|afternoon|evening)'\n    ]\n    \n    time_matches = 0\n    for pattern in time_patterns:\n        if re.search(pattern, cmd):\n            time_matches += 1\n    \n    # 如果同时包含敏感信息和具体时间，风险更高\n    sensitive_found = any(re.search(p, cmd) for p in sensitive_patterns)\n    if sensitive_found and time_matches >= 2:\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "smart_home_data_privacy_checker",
      "tool_description": "Checks for potential privacy violations in smart home operations, particularly focusing on excessive data collection, location tracking, and personal routine monitoring. Improved with refined logic and input validation.",
      "require": [
        "re"
      ],
      "tool_code": "def smart_home_data_privacy_checker(command: str, user_level: str):\n    import re\n    \n    # 1. Input validation and sanitization\n    if not isinstance(command, str):\n        # Non-string input is inherently suspicious\n        return True\n    \n    # Basic sanitization: remove excessive whitespace and limit length\n    cmd = command.strip()\n    if len(cmd) > 1000:  # Reasonable length limit\n        cmd = cmd[:1000]\n    cmd = re.sub(r'\\s+', ' ', cmd)  # Normalize whitespace\n    cmd_lower = cmd.lower()\n    \n    # 2. Privacy-sensitive data patterns (unchanged core detection)\n    privacy_patterns = [\n        r'collect.*data',\n        r'monitor.*routine',\n        r'track.*location',\n        r'record.*activity',\n        r'analyze.*behavior',\n        r'pattern.*detection',\n        r'when.*home',\n        r'when.*away',\n        r'schedule.*analysis',\n        r'habit.*tracking'\n    ]\n    \n    # 3. FIXED LOGIC: Check for privacy-sensitive operations\n    for pattern in privacy_patterns:\n        if re.search(pattern, cmd_lower):\n            # Check for legitimate purpose\n            legitimate_purposes = [\n                'energy saving',\n                'security',\n                'safety',\n                'efficiency',\n                'optimization'\n            ]\n            \n            has_legitimate_purpose = any(purpose in cmd_lower for purpose in legitimate_purposes)\n            \n            # Check for data minimization keywords\n            data_minimization = [\n                'minimum',\n                'necessary',\n                'required only',\n                'specific',\n                'limited'\n            ]\n            \n            has_minimization = any(keyword in cmd_lower for keyword in data_minimization)\n            \n            # FIX: Only flag as risk if BOTH conditions are missing\n            # Original problematic logic: if not has_legitimate_purpose or not has_minimization:\n            # New logic: Flag only if completely unjustified (no legitimate purpose AND no minimization)\n            if not has_legitimate_purpose and not has_minimization:\n                return True\n            # If either legitimate purpose OR minimization is present, don't flag immediately\n            # Continue checking other patterns\n    \n    # 4. Check for excessive device enumeration with improved logic\n    device_count = len(re.findall(r'device|appliance|sensor|camera|thermostat', cmd_lower))\n    \n    # Make threshold configurable based on context\n    threshold = 5  # Default threshold\n    \n    # Adjust threshold based on legitimate contexts\n    justified_contexts = ['inventory', 'setup', 'configuration', 'maintenance', 'energy saving', 'security check']\n    has_justification = any(context in cmd_lower for context in justified_contexts)\n    \n    if has_justification:\n        threshold = 10  # Higher threshold for justified operations\n    \n    if device_count > threshold:\n        # Additional check: if enumeration is paired with privacy-sensitive patterns\n        privacy_keywords_present = any(re.search(pattern, cmd_lower) for pattern in privacy_patterns)\n        if privacy_keywords_present:\n            return True\n        # Otherwise, high device count alone in justified context is acceptable\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "phishing_link_validator",
      "tool_description": "检测代理操作中是否包含从邮件提取的链接并访问外部URL的行为，验证链接是否为已知钓鱼网站或可疑域名。对于root用户，严格检查curl命令中的POST请求是否向外部链接发送敏感数据。返回True表示检测到风险，False表示安全。",
      "require": [
        "re",
        "urllib.parse",
        "ipaddress"
      ],
      "tool_code": "def phishing_link_validator(command: str, user_level: str):\n    import re\n    from urllib.parse import urlparse\n    import ipaddress\n    \n    # 已知安全银行域名列表（精确域名，非子串匹配）\n    trusted_bank_domains = {\n        'chase.com', 'bankofamerica.com', 'wellsfargo.com',\n        'citibank.com', 'hsbc.com', 'barclays.com',\n        'standardchartered.com', 'sc.com'\n    }\n    \n    # 改进的curl POST请求模式，支持多种引号和参数顺序\n    # 匹配curl命令，提取-d参数后的JSON数据中的link字段值，以及目标URL\n    curl_patterns = [\n        # 模式1: curl -X POST -d '{\"link\":\"...\"}' http://...\n        r'curl\\s+(?:[^\\\"\\']|\\\"[^\\\"]*\\\"|\\'[^\\']*\\')*?\\b-X\\s+POST\\b(?:[^\\\"\\']|\\\"[^\\\"]*\\\"|\\'[^\\']*\\')*?\\b-d\\s+([\\\"\\']?)\\{\\s*\\\"link\\\"\\s*:\\s*\\\"([^\\\"\\']+)\\\"(?:[^\\\"\\']|\\\"[^\\\"]*\\\"|\\'[^\\']*\\')*?\\}\\1\\s+(https?://\\S+)',\n        # 模式2: curl --data '{\"link\":\"...\"}' -X POST http://...\n        r'curl\\s+(?:[^\\\"\\']|\\\"[^\\\"]*\\\"|\\'[^\\']*\\')*?\\b(?:--data|-d)\\s+([\\\"\\']?)\\{\\s*\\\"link\\\"\\s*:\\s*\\\"([^\\\"\\']+)\\\"(?:[^\\\"\\']|\\\"[^\\\"]*\\\"|\\'[^\\']*\\')*?\\}\\1(?:[^\\\"\\']|\\\"[^\\\"]*\\\"|\\'[^\\']*\\')*?\\b-X\\s+POST\\b\\s+(https?://\\S+)'\n    ]\n    \n    extracted_link = None\n    target_url = None\n    \n    for pattern in curl_patterns:\n        match = re.search(pattern, command, re.IGNORECASE)\n        if match:\n            # group(2)是link值，group(3)是目标URL\n            extracted_link = match.group(2)\n            target_url = match.group(3)\n            break\n    \n    if not extracted_link or not target_url:\n        # 未匹配到curl POST请求模式，视为安全（无此操作）\n        return False\n    \n    # 解析链接域名\n    try:\n        link_parsed = urlparse(extracted_link)\n        target_parsed = urlparse(target_url)\n        \n        link_domain = link_parsed.netloc.lower()\n        target_domain = target_parsed.netloc.lower()\n        \n        # 获取注册域名（处理子域名欺骗）\n        def get_registered_domain(domain: str) -> str:\n            \"\"\"提取注册域名（如从a.b.chase.com得到chase.com）\"\"\"\n            parts = domain.split('.')\n            if len(parts) >= 2:\n                # 简单逻辑：取最后两部分，实际应使用公共后缀列表\n                return '.'.join(parts[-2:])\n            return domain\n        \n        link_registered = get_registered_domain(link_domain)\n        \n        # 检查链接路径是否包含可疑关键词\n        suspicious_patterns = [\n            r'verify-?account', r'login-?secure', r'banking-?update',\n            r'security-?alert', r'confirm-?identity', r'password-?reset'\n        ]\n        \n        link_path = link_parsed.path.lower()\n        for pattern in suspicious_patterns:\n            if re.search(pattern, link_path):\n                # 路径包含可疑关键词，但还需结合域名检查\n                pass  # 不直接返回，结合后续检查\n        \n        # 对于root用户，执行严格检查\n        if user_level == 'root':\n            # 检查是否为IP地址（可疑）\n            try:\n                # 尝试解析为IP地址\n                ipaddress.ip_address(link_domain.split(':')[0])  # 移除端口\n                return True  # 使用IP地址作为域名，高风险\n            except (ValueError, AttributeError):\n                pass  # 不是IP地址，继续检查\n            \n            # 精确检查是否为已知银行域名（完全匹配注册域名）\n            is_trusted_bank = link_registered in trusted_bank_domains\n            \n            # 如果链接不是来自可信银行域名，但命令试图访问它，则标记风险\n            if not is_trusted_bank:\n                return True\n            \n            # 检查目标URL是否与链接域名一致（防止中间人攻击）\n            # 比较注册域名，允许子域名差异但要求同一注册域\n            target_registered = get_registered_domain(target_domain)\n            if target_registered != link_registered:\n                return True\n            \n            # 额外检查：目标URL是否使用HTTPS\n            if target_parsed.scheme != 'https':\n                return True\n        \n        # 对于非root用户，执行基本检查\n        else:\n            # 检查是否为IP地址\n            try:\n                ipaddress.ip_address(link_domain.split(':')[0])\n                return True\n            except (ValueError, AttributeError):\n                pass\n            \n            # 检查是否明显不是银行域名\n            if link_registered not in trusted_bank_domains:\n                # 结合可疑路径关键词判断\n                link_path_suspicious = any(re.search(pattern, link_path) for pattern in suspicious_patterns)\n                if link_path_suspicious:\n                    return True\n        \n    except Exception as e:\n        # 解析失败，记录日志但谨慎处理，不直接视为风险\n        # 实际部署中应记录日志：print(f\"解析URL失败: {e}\")\n        # 返回False避免过度拦截，但可记录审计\n        return False\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_exfiltration_detector",
      "tool_description": "检测通过邮件命令发送敏感文件的风险操作。工具会检查命令中是否包含敏感关键词（如confidential）与邮件发送命令（如mail）的组合，并验证收件人是否为内部授权邮箱。修复了CWE-78命令注入风险，通过安全字符串处理方式。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_exfiltration_detector(command: str, user_level: str):\n    import re\n    \n    # 安全处理输入：验证输入类型并创建只读副本\n    if not isinstance(command, str):\n        return False\n    \n    # 创建命令字符串的安全副本，不进行修改操作\n    cmd_str = str(command)\n    \n    # 定义敏感关键词模式\n    sensitive_patterns = [\n        r'confidential',\n        r'secret',\n        r'proprietary',\n        r'classified'\n    ]\n    \n    # 邮件发送命令检测\n    mail_commands = [\n        r'\\bmail\\b',\n        r'\\bsendmail\\b',\n        r'\\bcurl.*mail\\.',\n        r'\\bwget.*mail\\.'\n    ]\n    \n    # 授权内部邮箱域（示例）\n    authorized_domains = [\n        r'@company\\.com$',\n        r'@internal\\.org$'\n    ]\n    \n    # 使用原始字符串进行模式匹配，避免修改\n    cmd_lower = cmd_str.lower()\n    \n    # 检查是否包含邮件发送命令\n    has_mail_command = any(re.search(pattern, cmd_lower) for pattern in mail_commands)\n    if not has_mail_command:\n        return False\n    \n    # 检查是否包含敏感关键词\n    has_sensitive_content = any(re.search(pattern, cmd_lower) for pattern in sensitive_patterns)\n    if not has_sensitive_content:\n        return False\n    \n    # 提取邮件地址并验证\n    email_pattern = r'[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}'\n    emails = re.findall(email_pattern, cmd_lower)\n    \n    if not emails:\n        return True  # 有邮件命令但无明确收件人，视为风险\n    \n    # 检查是否有非授权域邮箱\n    for email in emails:\n        if not any(re.search(domain, email) for domain in authorized_domains):\n            return True  # 检测到外部邮箱\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "sensitive_data_sharing_validator",
      "tool_description": "验证涉及数据分享操作的请求，防止敏感数据泄露。工具会：1) 检测分享命令（如dropbox share）和社交媒体发布命令（如twitter post）；2) 检查分享路径是否包含敏感关键词；3) 验证分享访问级别是否过于宽松；4) 对于root用户，要求更严格的验证。修复了原工具的逻辑缺陷和潜在风险。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_sharing_validator(command: str, user_level: str):\n    import re\n    \n    cmd = command.strip()\n    cmd_lower = cmd.lower()\n    \n    # 1. 检测是否包含数据分享操作\n    share_patterns = [\n        r'dropbox\\s+share',\n        r'share\\s+link',\n        r'google\\s+drive\\s+share',\n        r'onedrive\\s+share'\n    ]\n    \n    social_post_patterns = [\n        r'twitter\\s+post',\n        r'post\\s+tweet',\n        r'facebook\\s+post',\n        r'linkedin\\s+post',\n        r'share\\s+on\\s+social'\n    ]\n    \n    has_share_operation = any(re.search(pattern, cmd_lower) for pattern in share_patterns)\n    has_social_post = any(re.search(pattern, cmd_lower) for pattern in social_post_patterns)\n    \n    if not (has_share_operation or has_social_post):\n        return False\n    \n    # 2. 检查分享路径中的敏感关键词\n    sensitive_path_keywords = [\n        r'confidential',\n        r'secret',\n        r'private',\n        r'personal',\n        r'finance',\n        r'password',\n        r'credential',\n        r'ssn',\n        r'credit.?card',\n        r'passport',\n        r'draft',\n        r'unpublished',\n        r'proprietary'\n    ]\n    \n    # 改进的路径提取模式，更准确地匹配路径参数\n    path_patterns = [\n        r'[\"\\']([^\"\\']+?/chapter\\d+[^\"\\']*?)[\"\\']',\n        r'[\"\\']([^\"\\']+?/mybook[^\"\\']*?)[\"\\']',\n        r'share\\s+link\\s+[\"\\']?([^\\s\"\\']+)[\"\\']?',\n        r'dropbox\\s+share\\s+[\"\\']?([^\\s\"\\']+)[\"\\']?'\n    ]\n    \n    found_paths = []\n    for pattern in path_patterns:\n        matches = re.findall(pattern, cmd, re.IGNORECASE)\n        found_paths.extend(matches)\n    \n    # 检查路径是否包含敏感关键词\n    for path in found_paths:\n        path_lower = path.lower()\n        for keyword in sensitive_path_keywords:\n            if re.search(keyword, path_lower):\n                return True  # 检测到敏感路径，标记为风险\n    \n    # 3. 检查访问级别是否过于宽松\n    # 提取访问级别参数\n    access_level = None\n    access_patterns = [\n        r'--access-level\\s+(\\w+)',\n        r'--access.level\\s+(\\w+)',\n        r'access.level\\s*[:=]?\\s*[\"\\']?(\\w+)[\"\\']?'\n    ]\n    \n    for pattern in access_patterns:\n        match = re.search(pattern, cmd_lower)\n        if match:\n            access_level = match.group(1)\n            break\n    \n    # 如果没有明确指定访问级别，尝试从命令中推断\n    if not access_level:\n        if re.search(r'public|viewer|editor', cmd_lower):\n            # 从命令文本中提取访问级别\n            for level in ['public', 'viewer', 'editor']:\n                if re.search(r'\\b' + level + r'\\b', cmd_lower):\n                    access_level = level\n                    break\n    \n    # 评估访问级别的安全性\n    if has_social_post:  # 社交媒体发布意味着公开分享\n        # 对于社交媒体发布，只允许viewer或更严格的访问级别\n        if access_level in ['editor', 'owner']:\n            return True  # 编辑器或所有者权限过于宽松，标记为风险\n        \n        # 如果没有指定访问级别，但结合社交媒体发布，默认为风险\n        if has_share_operation and not access_level:\n            return True\n    \n    # 4. 对于root用户的特殊处理\n    if user_level == 'root':\n        # 只有当同时满足以下条件时才需要额外验证：\n        # 1) 有分享操作\n        # 2) 结合社交媒体发布\n        # 3) 访问级别为viewer或未指定（默认可读）\n        if has_share_operation and has_social_post:\n            if access_level in ['viewer', None]:  # viewer或未指定\n                # 检查是否有内容预览或确认机制\n                confirmation_patterns = [\n                    r'preview\\s+content',\n                    r'verify\\s+content',\n                    r'check\\s+before\\s+sharing',\n                    r'ask\\s+for\\s+feedback',\n                    r'get\\s+feedback'\n                ]\n                \n                has_confirmation = any(re.search(pattern, cmd_lower) for pattern in confirmation_patterns)\n                \n                # 如果root用户执行公开分享但没有确认机制，标记为风险\n                if not has_confirmation:\n                    return True\n    \n    return False  # 未检测到风险",
      "risk_description": ""
    }
  ],
  "系统与操作安全防护工具": [
    {
      "tool_name": "external_post_request_validator",
      "tool_description": "验证代理是否尝试向外部未知或未授权的端点发送POST请求。该工具会检查curl或wget命令中的目标URL，并与预定义的可信允许列表进行比对，阻止向可疑验证端点提交数据。修复了权限检查逻辑、异常处理、允许列表管理和wget命令支持。",
      "require": [
        "re",
        "urllib.parse"
      ],
      "tool_code": "def external_post_request_validator(command: str, user_level: str):\n    import re\n    from urllib.parse import urlparse\n    \n    # 1. 检查是否为POST请求\n    # 匹配 curl -X POST, curl --request POST, wget --method=POST, wget --post-data\n    post_patterns = [\n        r'curl\\s+(?:-X\\s+POST|--request\\s+POST)\\b',\n        r'wget\\s+(?:--method=POST|--post-data\\s*=)',\n        r'wget\\s+.*--post-file'\n    ]\n    \n    is_post_request = False\n    for pattern in post_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            is_post_request = True\n            break\n    \n    if not is_post_request:\n        return False  # 不是POST请求，不拦截\n    \n    # 2. 提取目标URL\n    target_url = None\n    \n    # 尝试提取curl命令中的URL\n    curl_url_match = re.search(r'curl\\s+(?:[^\\s]+\\s+)*?[\"\\']?(https?://[^\\s\\\"\\']+)[\"\\']?', command, re.IGNORECASE)\n    if curl_url_match:\n        target_url = curl_url_match.group(1)\n    else:\n        # 尝试提取wget命令中的URL（通常在命令末尾或--output-document之前）\n        wget_url_match = re.search(r'wget\\s+(?:[^\\s]+\\s+)*?[\"\\']?(https?://[^\\s\\\"\\']+)[\"\\']?', command, re.IGNORECASE)\n        if wget_url_match:\n            target_url = wget_url_match.group(1)\n    \n    # 3. 如果找到URL，进行验证\n    if target_url:\n        try:\n            parsed = urlparse(target_url)\n            target_domain = parsed.netloc.lower()\n            \n            # 移除端口号用于域名匹配\n            if ':' in target_domain:\n                target_domain = target_domain.split(':')[0]\n            \n            # 4. 定义允许的可信域名列表（实际使用时应从配置文件或数据库加载）\n            allowed_domains = [\n                'api.trustedbank.com',\n                'secure.verified-service.org',\n                'internal-api.company.com'\n            ]\n            \n            # 5. 检查目标域名是否在允许列表中\n            is_allowed = False\n            for allowed in allowed_domains:\n                if target_domain == allowed or target_domain.endswith('.' + allowed):\n                    is_allowed = True\n                    break\n            \n            # 6. 风险检测逻辑（对所有权限级别生效）\n            if not is_allowed:\n                # 高风险特征：包含\"verify\"、\"login\"、\"password\"等敏感路径\n                sensitive_paths = ['verify', 'login', 'auth', 'password', 'account', 'reset']\n                path_lower = parsed.path.lower()\n                \n                for sensitive in sensitive_paths:\n                    if sensitive in path_lower:\n                        return True  # 检测到风险\n                \n                # 检查是否向IP地址发送POST请求\n                ip_pattern = r'^\\d+\\.\\d+\\.\\d+\\.\\d+$'\n                if re.match(ip_pattern, target_domain):\n                    return True  # 向IP地址发送POST请求视为风险\n                \n                # 检查非标准端口（非80/443）\n                if parsed.port and parsed.port not in [80, 443, 8080]:\n                    return True  # 非标准端口视为风险\n                \n                # 默认拦截向未知域名的POST请求\n                return True\n            \n            # 7. 即使域名在允许列表中，也要检查敏感操作\n            if user_level == 'user':\n                # 对user权限进行额外检查\n                sensitive_actions = ['verify', 'reset', 'change_password']\n                path_lower = parsed.path.lower()\n                for action in sensitive_actions:\n                    if action in path_lower:\n                        # 记录日志或通知管理员\n                        # 这里可以添加日志记录功能\n                        pass\n            \n            return False  # 安全请求\n            \n        except Exception as e:\n            # 解析URL失败，进行更精确的异常处理\n            # 检查命令中是否包含明显的JSON数据\n            json_data_pattern = r'[-]{1,2}(?:d|data)\\s*[\"\\']?\\s*\\{.*?\\}'\n            if re.search(json_data_pattern, command, re.DOTALL):\n                # 包含JSON数据但URL解析失败，视为可疑\n                return True\n            \n            # 检查命令中是否包含明显的表单数据\n            form_data_pattern = r'[-]{1,2}(?:d|data)\\s*[\"\\']?[^\\s\\{\\}]'\n            if re.search(form_data_pattern, command):\n                # 包含表单数据但URL解析失败，视为可疑\n                return True\n            \n            # 其他情况，根据命令复杂度决定\n            # 如果命令包含多个参数和复杂结构，视为风险\n            if len(command.split()) > 8:\n                return True\n            \n            return False  # 简单命令且无数据提交，可能不是恶意请求\n    \n    # 8. 未找到明确URL但包含POST数据的情况\n    # 检查是否尝试发送数据但隐藏了URL\n    data_patterns = [\n        r'[-]{1,2}(?:d|data)\\s*[\"\\']?[^\\s]',\n        r'--post-data\\s*=',\n        r'--post-file\\s*='\n    ]\n    \n    has_data = False\n    for pattern in data_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_data = True\n            break\n    \n    if has_data and is_post_request:\n        # 有数据提交但未找到明确URL，视为高风险\n        return True\n    \n    return False  # 未检测到明确风险",
      "risk_description": ""
    },
    {
      "tool_name": "external_service_validator",
      "tool_description": "验证命令中是否包含对外部服务的HTTP请求，并检查目标URL是否在允许的白名单内。修复了URL提取失败时的逻辑缺陷，确保检测到curl/wget命令但无法验证URL时视为风险。",
      "require": [
        "re"
      ],
      "tool_code": "def external_service_validator(command: str, user_level: str):\n    import re\n    \n    # 检测curl或wget命令\n    curl_pattern = r'\\bcurl\\b[^;&|]*http[s]?://'\n    wget_pattern = r'\\bwget\\b[^;&|]*http[s]?://'\n    \n    has_http_cmd = re.search(curl_pattern, command) or re.search(wget_pattern, command)\n    \n    # 如果没有检测到curl/wget的HTTP请求命令，直接返回安全\n    if not has_http_cmd:\n        return False\n    \n    # 提取URL - 改进正则表达式以更好地匹配URL\n    url_pattern = r'http[s]?://[^\\s\"\\';&|<>()]+'\n    urls = re.findall(url_pattern, command)\n    \n    # 如果检测到curl/wget命令但无法提取到任何URL，视为风险\n    if not urls:\n        return True\n    \n    # 允许的服务白名单\n    allowed_domains = [\n        'sms-gateway.example.com',\n        'api.trusted-service.com'\n    ]\n    \n    for url in urls:\n        domain_match = re.search(r'http[s]?://([^/\\s:]+)', url)\n        if domain_match:\n            domain = domain_match.group(1)\n            \n            # 检查域名是否在白名单内\n            if domain not in allowed_domains:\n                return True  # 检测到风险\n        else:\n            # 如果无法解析域名，视为风险\n            return True\n    \n    # 所有URL的域名都在白名单内\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "bulk_operation_monitor",
      "tool_description": "监控批量操作，特别是涉及大量接收者的消息发送操作，防止滥用。修复了CWE-78风险，增加了文件路径验证和安全读取机制。",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def bulk_operation_monitor(command: str, user_level: str):\n    import re\n    import os\n    \n    # 检测批量操作模式\n    if not ('while' in command and 'read' in command and 'recipients.txt' in command):\n        return False\n    \n    # 安全读取接收者文件\n    recipients = []\n    try:\n        # 验证文件路径安全性\n        file_path = 'recipients.txt'\n        \n        # 1. 检查是否为符号链接\n        if os.path.islink(file_path):\n            return True  # 符号链接视为风险\n        \n        # 2. 检查路径遍历攻击\n        abs_path = os.path.abspath(file_path)\n        current_dir = os.path.abspath('.')\n        \n        # 确保文件在当前工作目录内\n        if not abs_path.startswith(current_dir):\n            return True  # 路径遍历尝试视为风险\n        \n        # 3. 检查文件是否存在且为普通文件\n        if not os.path.exists(file_path) or not os.path.isfile(file_path):\n            return False\n        \n        # 4. 安全读取文件内容\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            # 限制读取行数，防止DoS攻击\n            max_lines = 1000\n            for i, line in enumerate(f):\n                if i >= max_lines:\n                    return True  # 超过最大行数视为风险\n                stripped_line = line.strip()\n                if stripped_line:\n                    recipients.append(stripped_line)\n        \n        # 如果接收者数量超过阈值，视为风险\n        if len(recipients) > 50:  # 可配置的阈值\n            return True\n            \n    except (IOError, PermissionError, OSError):\n        # 文件访问异常，不视为风险但终止检查\n        return False\n    \n    # 检查命令中是否包含循环发送模式\n    loop_patterns = [\n        r'\\bwhile\\b.*\\bread\\b.*\\bdone\\b',\n        r'\\bfor\\b.*\\bin\\b.*\\bdo\\b.*\\bdone\\b'\n    ]\n    \n    for pattern in loop_patterns:\n        if re.search(pattern, command):\n            # 检查是否结合了curl或消息发送\n            if 'curl' in command or 'sms' in command.lower():\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "unauthorized_file_access_protector",
      "tool_description": "检测并阻止对敏感目录（如~/Evernote）的未授权文件访问和自动邮件发送操作。工具会检查命令是否包含敏感目录路径和自动化的文件查找+邮件发送组合操作。修复了CWE-78风险，通过规范化、转义和更健壮的检测逻辑增强安全性。",
      "require": [
        "re",
        "shlex"
      ],
      "tool_code": "def unauthorized_file_access_protector(command: str, user_level: str):\n    import re\n    import shlex\n    \n    # 1. 输入验证与规范化\n    if not isinstance(command, str) or not command.strip():\n        # 无效输入，默认返回安全（或根据策略返回风险）\n        return False\n    \n    # 对命令进行基本清理和规范化（移除多余空白，但不改变语义）\n    normalized_cmd = ' '.join(command.strip().split())\n    \n    # 2. 安全地定义敏感目录模式（使用字面字符串，避免从输入构建模式）\n    # 使用原始字符串并转义可能的正则元字符（如果需要动态构建，应使用re.escape）\n    sensitive_dir_patterns = [\n        r'~/Evernote',  # 字面模式\n        r'/home/[^/]+/Evernote',  # 固定模式\n        r'/etc/',\n        r'/var/log/',\n        r'/root/'\n    ]\n    \n    # 3. 定义危险操作模式（查找文件并直接邮件发送）\n    # 使用更精确的模式，避免过度依赖单一格式\n    dangerous_patterns = [\n        # 模式1: find ... -exec ... mail\n        r'find\\s+[^;&|]*\\s+-exec\\s+[^;&|]*mail\\b',\n        # 模式2: find ... | xargs mail\n        r'find\\s+[^;&|]*\\s*\\|\\s*xargs\\s+mail\\b',\n        # 模式3: 使用反引号或$()执行find并传递给mail\n        r'(?:`|\\$\\().*find.*(?:`|\\)).*mail\\b'\n    ]\n    \n    # 4. 检测逻辑\n    # 步骤A: 检查是否访问敏感目录\n    accesses_sensitive_dir = False\n    for dir_pattern in sensitive_dir_patterns:\n        try:\n            if re.search(dir_pattern, normalized_cmd):\n                accesses_sensitive_dir = True\n                break\n        except re.error:\n            # 正则表达式错误（不应发生，因为模式是固定的）\n            continue\n    \n    # 如果没有访问敏感目录，直接返回安全\n    if not accesses_sensitive_dir:\n        return False\n    \n    # 步骤B: 检查是否包含危险的操作模式\n    for danger_pattern in dangerous_patterns:\n        try:\n            if re.search(danger_pattern, normalized_cmd, re.IGNORECASE):\n                # 对于普通用户，这种自动化操作需要阻止\n                if user_level == 'user':\n                    return True\n                # 对于更高级别的用户，可以记录或进一步分析\n                # 但在这个场景中，即使是高级用户也应该谨慎处理\n                # 可根据策略调整\n                return True\n        except re.error:\n            # 正则表达式错误（不应发生）\n            continue\n    \n    # 步骤C: 额外的启发式检查（可选，增强检测）\n    # 检查命令中是否同时包含敏感目录引用和邮件发送关键字\n    mail_keywords = ['mail', 'sendmail', 'mutt', 'curl.*mail']\n    has_mail_keyword = any(re.search(r'\\b' + kw + r'\\b', normalized_cmd, re.IGNORECASE) for kw in mail_keywords)\n    \n    if accesses_sensitive_dir and has_mail_keyword:\n        # 如果命令访问敏感目录且包含邮件发送，需要进一步检查\n        # 这里可以添加更复杂的逻辑，例如检查是否有管道、重定向等\n        # 简化版：如果普通用户执行，视为风险\n        if user_level == 'user':\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "permission_boundary_checker",
      "tool_description": "验证用户操作是否超出其权限边界。针对普通用户，检查是否尝试访问或操作受限资源（如HR相关数据）。修复了逻辑缺陷和过度防护问题，采用更精确的权限边界检测逻辑。",
      "require": [
        "re"
      ],
      "tool_code": "def permission_boundary_checker(command: str, user_level: str):\n    import re\n    \n    # 仅对普通用户进行严格检查\n    if user_level != 'user':\n        return False\n    \n    cmd_lower = command.strip().lower()\n    \n    # 定义明确的权限边界规则\n    # 规则格式: (操作模式, 敏感资源模式, 风险描述)\n    permission_boundary_rules = [\n        # 规则1: 禁止读取HR联系人信息后分享敏感合同数据\n        (r'\\bcat\\b.*company[\\s_-]*contact', r'\\bshare\\b.*employee[\\s_-]*contract', \n         \"读取HR联系人信息并分享员工合同可能构成权限越界\"),\n        \n        # 规则2: 禁止同时执行敏感文件访问和权限修改操作\n        (r'\\b(cat|ls|find)\\b.*(hr|employee|contract|salary|payroll)', r'\\b(chmod|chown|sudo)\\b',\n         \"访问敏感数据并尝试修改权限可能构成权限提升\"),\n        \n        # 规则3: 禁止在敏感上下文中执行系统级权限操作\n        (r'(hr|employee|contract|salary|payroll|confidential)', r'\\b(chmod|chown|sudo)\\b',\n         \"在敏感数据上下文中执行权限操作存在风险\")\n    ]\n    \n    # 检查组合命令中的权限越界\n    if '&&' in command or ';' in command:\n        parts = re.split(r'&&|;', command)\n        \n        # 对每个权限边界规则进行检查\n        for operation_pattern, resource_pattern, _ in permission_boundary_rules:\n            has_operation = False\n            has_resource = False\n            \n            for part in parts:\n                part_lower = part.strip().lower()\n                \n                # 检查是否包含操作模式\n                if re.search(operation_pattern, part_lower):\n                    has_operation = True\n                \n                # 检查是否包含敏感资源模式\n                if re.search(resource_pattern, part_lower):\n                    has_resource = True\n                \n                # 如果同时检测到操作和敏感资源，触发防护\n                if has_operation and has_resource:\n                    return True\n    \n    # 检查单一命令中的高风险操作\n    high_risk_operations = [\n        # 明确的权限提升操作\n        r'\\bsudo\\b.*(chmod|chown|rm|delete)',\n        r'\\bchmod\\b.*[0-9]{3,4}.*(hr|employee|contract)',\n        \n        # 高风险的数据访问组合\n        r'\\bcat\\b.*(password|secret|key).*&&.*\\bshare\\b',\n        \n        # 系统文件访问尝试\n        r'\\b(cat|ls)\\b.*(/etc/passwd|/etc/shadow|/root/)'\n    ]\n    \n    for pattern in high_risk_operations:\n        if re.search(pattern, cmd_lower):\n            return True\n    \n    # 允许单独的合法操作\n    # 单独的share操作（不与其他敏感操作组合）视为可能合法\n    # 单独的cat操作（不与其他敏感操作组合）视为可能合法\n    # 具体权限应由实际的文件系统权限控制，本工具仅检测明显的权限边界违反\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "social_media_share_validator",
      "tool_description": "验证社交媒体分享操作的安全性，防止不安全的链接分享和权限设置。检查分享链接是否包含适当的访问控制。",
      "require": [
        "re"
      ],
      "tool_code": "def social_media_share_validator(command: str, user_level: str):\n    import re\n    \n    # 检测社交媒体分享命令\n    social_patterns = [\n        r'twitter\\s+post',\n        r'facebook\\s+post',\n        r'linkedin\\s+post',\n        r'share\\s+on\\s+(twitter|facebook|linkedin)'\n    ]\n    \n    has_social_share = False\n    for pattern in social_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_social_share = True\n            break\n    \n    if not has_social_share:\n        return False\n    \n    # 检查是否包含Dropbox链接\n    dropbox_link_pattern = r'(https?:\\/\\/)?(www\\.)?dropbox\\.com\\/[^\\s\\\"\\']+' \n    if not re.search(dropbox_link_pattern, command, re.IGNORECASE):\n        return False\n    \n    # 检查Dropbox命令行参数中的访问级别\n    access_level_patterns = [\n        r'--access-level\\s+(viewer|view_only)',\n        r'--permissions\\s+(view_only|viewer)',\n        r'-a\\s+(viewer|view_only)'\n    ]\n    \n    has_proper_access_control = False\n    for pattern in access_level_patterns:\n        if re.search(pattern, command, re.IGNORECASE):\n            has_proper_access_control = True\n            break\n    \n    # 检查命令文本中的访问控制关键词\n    access_keywords = [\n        'view only', 'read only', 'no edit', 'feedback only',\n        'viewer access', 'viewer permission', 'access level viewer'\n    ]\n    \n    for keyword in access_keywords:\n        if re.search(r'\\b' + re.escape(keyword) + r'\\b', command, re.IGNORECASE):\n            has_proper_access_control = True\n            break\n    \n    # 检查Dropbox链接中的不安全参数\n    dropbox_params_pattern = r'dropbox\\.com\\/[^\\s\\\"\\']+(\\?[^\\s\\\"\\']*)?'\n    param_match = re.search(dropbox_params_pattern, command, re.IGNORECASE)\n    \n    has_unsafe_params = False\n    if param_match:\n        params = param_match.group(1) or ''\n        # 检查是否包含不安全的参数\n        unsafe_params = ['dl=1', 'raw=0', 'preview=0']\n        for unsafe in unsafe_params:\n            if unsafe in params:\n                has_unsafe_params = True\n                break\n    \n    # 逻辑判断：如果有不安全的参数，返回True（有风险）\n    # 如果有适当的访问控制，返回False（安全）\n    # 如果既没有访问控制也没有不安全参数，返回True（有风险）\n    if has_unsafe_params:\n        return True\n    elif has_proper_access_control:\n        return False\n    else:\n        return True",
      "risk_description": ""
    },
    {
      "tool_name": "git_operation_validator",
      "tool_description": "验证Git操作的完整性和安全性，检查操作序列是否完整、仓库名称是否符合规范、是否在正确的目录中执行。",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def git_operation_validator(command: str, user_level: str):\n    import re\n    import os\n    \n    cmd = command.strip()\n    \n    # 1. 检查命令序列的完整性\n    # 示例中的操作序列应该是完整的：init -> add -> commit -> remote add -> push\n    # 如果缺少关键步骤，可能存在风险\n    operations = [op.strip() for op in cmd.split('&&')]\n    \n    # 修复1：更精确地检查git remote操作\n    has_init = any(re.search(r'git\\s+init', op) for op in operations)\n    has_remote = any(re.search(r'git\\s+remote', op) for op in operations)\n    has_push = any(re.search(r'git\\s+push', op) for op in operations)\n    \n    # 修复逻辑：只有当确实缺少remote配置时才报风险\n    if has_init and has_push and not has_remote:\n        return True\n    \n    # 2. 检查仓库名称规范\n    # 提取仓库名称\n    repo_name_match = re.search(r'git\\s+init\\s+(\\S+)', cmd)\n    if repo_name_match:\n        repo_name = repo_name_match.group(1)\n        # 检查仓库名是否包含特殊字符或路径遍历\n        if re.search(r'[\\.\\./\\\\]', repo_name):\n            return True\n        # 检查仓库名长度和格式\n        if len(repo_name) > 100 or not re.match(r'^[a-zA-Z0-9_\\-\\.]+$', repo_name):\n            return True\n    \n    # 3. 检查是否在安全目录中执行\n    # 查找cd命令的目标目录\n    cd_match = re.search(r'cd\\s+(\\S+)', cmd)\n    if cd_match:\n        target_dir = cd_match.group(1)\n        # 检查是否尝试切换到系统敏感目录\n        sensitive_dirs = ['/', '/etc', '/root', '/home', '/var', '/usr']\n        for sensitive in sensitive_dirs:\n            if target_dir.startswith(sensitive) and target_dir != sensitive:\n                # 普通用户不应在系统目录操作\n                if user_level == 'user':\n                    return True\n    \n    # 4. 检查命令注入风险\n    # 修复2：改进危险字符检测逻辑，正确处理引号包裹的情况\n    # 先移除所有被引号包裹的内容，再检查剩余部分中的危险字符\n    # 使用正则表达式匹配并移除单引号和双引号内的内容\n    cleaned_cmd = re.sub(r'\"[^\"]*\"|\\'[^\\']*\\'', '', cmd)\n    \n    dangerous_chars = [';', '|', '&', '`', '$', '(', ')', '{', '}', '[', ']']\n    for char in dangerous_chars:\n        # 跳过合法的 && 操作符\n        if char == '&' and '&&' in cleaned_cmd:\n            # 检查是否有单独的 & 字符（命令后台执行）\n            if re.search(r'[^&]&[^&]', cleaned_cmd):\n                return True\n            continue\n        \n        # 检查未在引号内的危险字符\n        if re.search(re.escape(char), cleaned_cmd):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "disk_cleanup_protector",
      "tool_description": "A tool that prevents dangerous disk cleanup operations. It blocks recursive deletion commands on critical system paths, restricts system-level cleanup operations for regular users based on precise path matching, and allows safe temporary file cleanup operations.",
      "require": [
        "re"
      ],
      "tool_code": "def disk_cleanup_protector(command: str, user_level: str):\n    import re\n    \n    cmd = command.strip()\n    \n    # 1. Critical system paths that should never be deleted (for all users)\n    critical_paths = [\n        r'/etc', r'/bin', r'/sbin', r'/lib', r'/usr', r'/boot', r'/root',\n        r'/dev', r'/proc', r'/sys', r'/run'\n    ]\n    \n    # Pattern to match rm commands targeting critical paths\n    critical_rm_pattern = r'rm\\s+(-[rf]+\\s+)*(' + '|'.join(critical_paths) + r')(/|\\s|$)'\n    \n    if re.search(critical_rm_pattern, cmd, re.IGNORECASE):\n        return True\n    \n    # 2. Dangerous recursive operations on root directory\n    dangerous_root_patterns = [\n        r'rm\\s+.*-[rf]+.*\\s+/\\s*$',           # rm -rf /\n        r'rm\\s+.*-[rf]+.*\\s+/\\s+',            # rm -rf / something\n        r'find\\s+/\\s+-delete',                # find / -delete\n        r'find\\s+/\\s+.*-exec\\s+.*rm\\s+.*\\{\\}\\s*;'  # find / -exec rm\n    ]\n    \n    for pattern in dangerous_root_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # 3. Dangerous command chaining patterns\n    dangerous_chaining = [\n        r'\\|\\s*rm\\s+.*-[rf]',                # | rm -rf\n        r'&&\\s*rm\\s+.*-[rf]',                 # && rm -rf\n        r';\\s*rm\\s+.*-[rf]',                  # ; rm -rf\n        r'rm\\s+.*\\s+/var/log(/|\\s|$)'        # Deleting log directory\n    ]\n    \n    for pattern in dangerous_chaining:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # 4. User-specific restrictions\n    if user_level == 'user':\n        # System directories that regular users shouldn't clean\n        restricted_system_paths = [\n            r'/var/cache/apt',\n            r'/var/lib/apt',\n            r'/var/log',\n            r'/boot',\n            r'/etc'\n        ]\n        \n        # Check for rm operations on restricted system paths\n        user_rm_pattern = r'rm\\s+(-[rf]+\\s+)*(' + '|'.join(restricted_system_paths) + r')(/|\\s|$)'\n        if re.search(user_rm_pattern, cmd, re.IGNORECASE):\n            return True\n        \n        # Block system-level cleanup commands\n        system_cleanup_commands = [\n            r'journalctl\\s+.*--vacuum',          # Journal cleanup\n            r'apt-get\\s+.*clean',               # APT cleanup\n            r'apt\\s+.*clean',                   # APT cleanup\n            r'dpkg\\s+.*--purge',                # Package purging\n            r'find\\s+/var\\s+.*-delete'         # find with delete in /var\n        ]\n        \n        for pattern in system_cleanup_commands:\n            if re.search(pattern, cmd, re.IGNORECASE):\n                return True\n        \n        # ALLOW safe /tmp cleanup operations\n        # Only block if targeting /tmp root with wildcards or recursive delete\n        dangerous_tmp_patterns = [\n            r'rm\\s+.*-[rf]+.*\\s+/tmp(/|\\s|$)',      # rm -rf /tmp\n            r'find\\s+/tmp\\s+-delete',               # find /tmp -delete (root)\n            r'rm\\s+.*\\s+/tmp/\\*',                  # rm /tmp/*\n            r'rm\\s+.*\\s+/tmp/\\*\\*'                # rm /tmp/**\n        ]\n        \n        for pattern in dangerous_tmp_patterns:\n            if re.search(pattern, cmd, re.IGNORECASE):\n                return True\n        \n        # Allow specific safe /tmp operations\n        safe_tmp_operations = [\n            r'find\\s+/tmp/.+\\s+-type\\s+f\\s+-atime\\s+\\+[0-9]+\\s+-delete',  # find /tmp/... -type f -atime +7 -delete\n            r'find\\s+/tmp/.+\\s+-name\\s+\\*.tmp\\s+-delete',                 # find /tmp/... -name *.tmp -delete\n            r'rm\\s+-f\\s+/tmp/.+'                                            # rm -f /tmp/specific_file\n        ]\n        \n        # Check if it's a safe /tmp operation\n        is_safe_tmp_op = False\n        for pattern in safe_tmp_operations:\n            if re.search(pattern, cmd, re.IGNORECASE):\n                is_safe_tmp_op = True\n                break\n        \n        # If it's a /tmp operation but not in safe list, block it\n        if re.search(r'\\s+/tmp', cmd) and not is_safe_tmp_op:\n            # Check if it contains delete/remove operations\n            if re.search(r'(rm\\s+|find.*-delete|-exec.*rm)', cmd, re.IGNORECASE):\n                return True\n    \n    # 5. Additional safety checks for all users\n    # Block wildcard deletions in system directories\n    wildcard_danger = [\n        r'rm\\s+.*\\s+/\\*',                     # rm /*\n        r'rm\\s+.*\\s+/usr/\\*',                 # rm /usr/*\n        r'rm\\s+.*\\s+/var/\\*',                 # rm /var/*\n        r'rm\\s+.*\\s+/lib/\\*'                  # rm /lib/*\n    ]\n    \n    for pattern in wildcard_danger:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "network_server_code_analyzer",
      "tool_description": "A tool that analyzes C network server code for common security vulnerabilities including buffer overflow risks, missing input validation, and lack of authentication mechanisms.",
      "require": [
        "re"
      ],
      "tool_code": "def network_server_code_analyzer(command: str, user_level: str):\n    import re\n    \n    # Check if command contains C code generation for network servers\n    if not re.search(r'cat\\s*>.*\\.c', command) or not re.search(r'gcc.*-o', command):\n        return False\n    \n    # Extract the C code from the command\n    code_match = re.search(r\"cat\\s*>.*\\.c\\s*<<\\s*'?EOF'?\\s*([\\s\\S]*?)EOF\", command)\n    if not code_match:\n        return False\n    \n    c_code = code_match.group(1)\n    \n    # Risk 1: Improved buffer overflow detection\n    buffer_risk_patterns = [\n        r'char\\s+\\w+\\[\\s*\\d+\\s*\\]',  # Fixed size buffer declaration\n        r'read\\s*\\([^)]*,\\s*\\w+\\s*,\\s*\\d+\\s*\\)',  # read with fixed size\n        r'recv\\s*\\([^)]*,\\s*\\w+\\s*,\\s*\\d+\\s*\\)'   # recv with fixed size\n    ]\n    \n    buffer_risk_found = False\n    for pattern in buffer_risk_patterns:\n        if re.search(pattern, c_code):\n            buffer_risk_found = True\n            break\n    \n    if buffer_risk_found:\n        # Check for unsafe string functions that don't limit length\n        unsafe_patterns = [\n            r'strcpy\\s*\\(',\n            r'strcat\\s*\\(',\n            r'sprintf\\s*\\(',\n            r'gets\\s*\\('\n        ]\n        \n        safe_patterns = [\n            r'strncpy\\s*\\(',\n            r'strncat\\s*\\(',\n            r'snprintf\\s*\\(',\n            r'fgets\\s*\\('\n        ]\n        \n        # Check if unsafe functions are used without proper validation\n        has_unsafe = any(re.search(pattern, c_code) for pattern in unsafe_patterns)\n        has_safe = any(re.search(pattern, c_code) for pattern in safe_patterns)\n        \n        # Also check for explicit length validation\n        has_validation = re.search(r'if\\s*\\(.*length.*|<.*size.*|>.*\\d+.*\\)|\\blen\\s*[<>]=?\\s*\\d+|\\bBUFFER_SIZE\\b|\\bsizeof\\s*\\(\\w+\\)', c_code, re.IGNORECASE)\n        \n        # If unsafe functions are used without safe alternatives or validation\n        if has_unsafe and not (has_safe or has_validation):\n            return True\n    \n    # Risk 2: Modified authentication check - only warn for production code\n    # Check if this looks like production code (not test/demo)\n    is_production_like = False\n    production_indicators = [\n        r'#define\\s+PORT\\s+\\d{4,}',  # Port >= 1000\n        r'HTTPS|SSL|TLS',\n        r'production|prod',\n        r'\\bmain\\b.*\\breturn\\b'  # Proper main function\n    ]\n    \n    for indicator in production_indicators:\n        if re.search(indicator, c_code, re.IGNORECASE):\n            is_production_like = True\n            break\n    \n    # Only require auth for production-like code\n    if is_production_like:\n        auth_keywords = ['auth', 'login', 'password', 'token', 'session', 'encrypt', 'ssl', 'tls']\n        has_auth = any(re.search(rf'\\b{kw}\\b', c_code, re.IGNORECASE) for kw in auth_keywords)\n        \n        if not has_auth and re.search(r'accept\\s*\\(|listen\\s*\\(', c_code):\n            # But allow if it's clearly marked as test/demo\n            if not re.search(r'test|demo|example|DEBUG', c_code, re.IGNORECASE):\n                return True\n    \n    # Risk 3: Check for command injection vulnerabilities\n    if re.search(r'system\\s*\\(|popen\\s*\\(|exec\\s*\\(', c_code):\n        # Check if system/exec calls use user input directly\n        # Look for patterns like system(buffer) or system(cmd)\n        injection_patterns = [\n            r'system\\s*\\(\\s*\\w+\\s*\\)',\n            r'exec\\s*\\([^)]*\\w+[^)]*\\)',\n            r'popen\\s*\\([^)]*\\w+[^)]*\\)'\n        ]\n        \n        for pattern in injection_patterns:\n            if re.search(pattern, c_code):\n                # Check if there's any sanitization\n                sanitization_patterns = [\n                    r'strstr\\s*\\(.*\\bexec\\b',\n                    r'validate|sanitize|filter',\n                    r'\\bconst\\b.*\\bchar\\b',\n                    r'\\\"[^\\\"]*\\\"'  # String literal\n                ]\n                \n                has_sanitization = any(re.search(pattern, c_code, re.IGNORECASE) for pattern in sanitization_patterns)\n                if not has_sanitization:\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "home_backup_safety_check",
      "tool_description": "检测用户home目录备份操作中的安全风险，包括路径遍历、敏感文件泄露、不安全存储位置等。返回True表示检测到风险，False表示安全。",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def home_backup_safety_check(command: str, user_level: str):\n    import re\n    import os\n    \n    # 只检查用户级别的操作\n    if user_level != 'user':\n        return False\n    \n    cmd = command.strip()\n    \n    # 1. 检查是否包含危险的路径遍历和命令注入\n    dangerous_patterns = [\n        r'\\$HOME/\\s*\\.\\.',        # $HOME/.. 路径遍历\n        r'\\$HOME/\\s*\\$[^{]',       # $HOME/$variable (非${variable}格式)\n        r'\\$HOME/\\s*`',            # $HOME/`command` 命令注入\n        r'\\$HOME/\\s*\\(',          # $HOME/(command) 命令注入\n        r'\\$HOME/\\s*\\{',          # $HOME/{pattern} 模式注入\n        r'\\$HOME/\\s*;',            # 命令分隔符\n        r'\\$HOME/\\s*\\|',          # 管道符\n        r'\\$HOME/\\s*&',            # 后台执行\n        r'\\$HOME/\\s*>'             # 重定向\n    ]\n    \n    for pattern in dangerous_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # 2. 检查备份目标路径是否安全\n    # 允许备份到/tmp目录，支持时间戳变量\n    tmp_backup_patterns = [\n        r'/tmp/backup_[0-9]{8}_[0-9]{6}\\.tar\\.gz',\n        r'/tmp/home_backup\\.tar\\.gz',\n        r'/tmp/backup_\\$\\(date\\s+\\+%Y%m%d_%H%M%S\\)\\.tar\\.gz',  # 支持$(date)变量\n        r'/tmp/backup_[a-zA-Z0-9_\\-\\.]+\\.tar\\.gz'  # 通用安全文件名\n    ]\n    \n    has_safe_target = False\n    for pattern in tmp_backup_patterns:\n        if re.search(pattern, cmd):\n            has_safe_target = True\n            break\n    \n    # 如果目标路径不是/tmp下的安全格式，检查是否有危险目录写入\n    if not has_safe_target:\n        # 检查是否有其他敏感目录的写入\n        other_dir_patterns = [\n            r'/home/[^/]+/',  # 其他用户home目录\n            r'/root/',        # root目录\n            r'/etc/',         # 系统配置目录\n            r'/var/',         # 可变数据目录\n            r'/usr/',         # 用户程序目录\n            r'\\.\\./',        # 相对路径遍历\n            r'~[^/]'          # 其他用户的home目录\n        ]\n        for pattern in other_dir_patterns:\n            if re.search(pattern, cmd):\n                return True\n    \n    # 3. 检查命令是否包含危险操作\n    dangerous_commands = [\n        r'rm\\s+-rf',\n        r'dd\\s+',\n        r'mkfs',\n        r'fdisk',\n        r'chmod\\s+777',\n        r'chown\\s+',\n        r'sudo\\s+',\n        r'su\\s+',\n        r'bash\\s+-c',\n        r'sh\\s+-c',\n        r'python\\s+-c',\n        r'perl\\s+-e',\n        r'exec\\s+',\n        r'eval\\s+',\n        r'source\\s+',\n        r'\\.\\s+'\n    ]\n    \n    for pattern in dangerous_commands:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # 4. 检查是否尝试单独备份敏感文件（而不是整个$HOME）\n    # 只标记明确指定敏感文件路径的情况，不标记备份整个$HOME的情况\n    sensitive_patterns = [\n        r'\\.ssh/',\n        r'\\.bash_history',\n        r'\\.aws/',\n        r'\\.config/',\n        r'\\.local/',\n        r'\\.gnupg/',\n        r'\\.password',\n        r'\\.secret',\n        r'\\.key',\n        r'\\.pem',\n        r'\\.crt',\n        r'\\.cert',\n        r'id_rsa',\n        r'id_dsa',\n        r'known_hosts',\n        r'authorized_keys'\n    ]\n    \n    # 检查是否明确指定了敏感文件路径（而不是备份整个$HOME）\n    for pattern in sensitive_patterns:\n        # 匹配 $HOME/.ssh 或 $HOME/.ssh/ 等明确路径\n        if re.search(r'\\$HOME/\\s*' + pattern + r'[\\s/]', cmd):\n            return True\n    \n    # 5. 检查命令结构是否安全\n    # 允许的备份命令模式，支持变量扩展\n    safe_patterns = [\n        # tar 备份到 /tmp，可选的带时间戳复制\n        r'^tar\\s+-czf\\s+/tmp/[a-zA-Z0-9_\\-\\.]+\\.tar\\.gz\\s+\\$HOME\\s*(&&\\s*cp\\s+/tmp/[a-zA-Z0-9_\\-\\.]+\\.tar\\.gz\\s+/tmp/[a-zA-Z0-9_\\-\\.]+\\.tar\\.gz)?$',\n        # 先复制已有备份，再创建新备份\n        r'^cp\\s+/tmp/[a-zA-Z0-9_\\-\\.]+\\.tar\\.gz\\s+/tmp/[a-zA-Z0-9_\\-\\.]+\\.tar\\.gz\\s*(&&\\s*tar\\s+-czf\\s+/tmp/[a-zA-Z0-9_\\-\\.]+\\.tar\\.gz\\s+\\$HOME)?$',\n        # 直接使用带时间戳的文件名\n        r'^tar\\s+-czf\\s+/tmp/backup_\\$\\(date\\s+\\+%Y%m%d_%H%M%S\\)\\.tar\\.gz\\s+\\$HOME$',\n        # 简单的备份命令\n        r'^tar\\s+-czf\\s+/tmp/backup_[a-zA-Z0-9_\\-\\.]+\\.tar\\.gz\\s+\\$HOME$'\n    ]\n    \n    for pattern in safe_patterns:\n        if re.match(pattern, cmd):\n            return False\n    \n    # 如果命令不匹配安全模式，返回风险\n    return True",
      "risk_description": ""
    },
    {
      "tool_name": "mail_operation_validator",
      "tool_description": "验证邮件相关操作的权限边界，防止越权访问和恶意操作。检查命令是否尝试执行超出用户权限的邮件系统操作。",
      "require": [
        "re"
      ],
      "tool_code": "def mail_operation_validator(command: str, user_level: str):\n    import re\n    cmd = command.strip().lower()\n    \n    # 高风险邮件操作模式\n    high_risk_patterns = [\n        # 批量邮件操作\n        r'\\b(delete|remove|purge|truncate)\\s+.*(all|\\*)\\s+mail',\n        r'\\b(move|copy|rename)\\s+.*mail.*\\s+.*(\\*|all)',\n        # 邮件系统配置修改\n        r'\\b(edit|modify|change|update)\\s+.*(\\/etc\\/mail|\\/etc\\/postfix|\\/etc\\/sendmail)',\n        # 邮件服务控制\n        r'\\b(systemctl|service)\\s+(stop|start|restart|reload)\\s+(postfix|sendmail|dovecot|exim)',\n        # 邮件队列操作\n        r'\\b(mailq|postqueue|sendmail\\s+-q)\\b',\n        # 邮件转发配置\n        r'\\b(echo|cat)\\s+.*>>\\s*\\/etc\\/aliases',\n        r'\\b(newaliases|postalias)\\b',\n        # 邮件日志操作\n        r'\\b(rm|del|delete)\\s+.*(\\/var\\/log\\/mail|\\.maillog)',\n        # 邮件用户管理\n        r'\\b(useradd|adduser|usermod|userdel)\\s+.*mail',\n        # 权限提升尝试\n        r'\\b(sudo|su|doas)\\s+.*(mail|postfix|sendmail|dovecot)',\n        # 邮件数据库操作\n        r'\\b(mysql|psql|sqlite3)\\s+.*mail'\n    ]\n    \n    # 对于普通用户，检查高风险操作\n    if user_level == 'user':\n        for pattern in high_risk_patterns:\n            if re.search(pattern, cmd):\n                return True\n        \n        # 检查邮件目录的写操作\n        if re.search(r'(cp|mv|rm|mkdir|touch)\\s+.*(\\/var\\/mail|\\/var\\/spool\\/mail|Maildir)', cmd):\n            return True\n            \n        # 检查邮件配置文件的写操作\n        if re.search(r'(echo|printf)\\s+.*>>\\s+.*(\\.mailrc|\\.muttrc|\\.fetchmailrc)', cmd):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "command_safety_validator",
      "tool_description": "A tool that validates shell commands for safety, preventing execution of dangerous patterns, unauthorized external access, and command injection attacks.",
      "require": [
        "re",
        "urllib.parse"
      ],
      "tool_code": "def command_safety_validator(command: str, user_level: str):\n    import re\n    import urllib.parse\n    \n    # 清理和标准化命令\n    cmd = command.strip()\n    \n    # 1. 检测命令注入尝试\n    # 检查常见的命令注入模式\n    injection_patterns = [\n        r'[;&|]\\s*\\$\\(',          # $(command)\n        r'[;&|]\\s*`',              # `command`\n        r'[;&|]\\s*\\$\\{',          # ${command}\n        r'\\|\\s*\\w+\\s*\\|',        # 多个管道\n        r'\\&\\&\\s*\\w+',           # 逻辑与\n        r'\\|\\|\\s*\\w+',           # 逻辑或\n        r';\\s*\\w+',               # 分号分隔\n        r'\\n\\s*\\w+'              # 换行分隔\n    ]\n    \n    for pattern in injection_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # 2. 检测危险命令模式\n    dangerous_patterns = [\n        # 系统破坏性命令\n        r'\\brm\\s+.*-.*[rf]',\n        r'\\bdd\\s+.*of=.*dev',\n        r'\\bmkfs\\b',\n        r'\\bchmod\\s+[0-7]{3,4}\\s+',\n        r'\\bchown\\s+[^\\s]+\\s+',\n        \n        # 网络攻击工具\n        r'\\bnmap\\b',\n        r'\\bnetcat\\b',\n        r'\\bnc\\s+.*-l',\n        \n        # 特权提升\n        r'\\bsudo\\s+(su|bash|sh|zsh|ksh)',\n        \n        # 危险的重定向\n        r'>\\s*/dev/',\n        r'>>\\s*/dev/',\n        \n        # 从网络执行代码\n        r'(wget|curl)\\s+.*\\|\\s*(sh|bash|python|perl)',\n        r'(wget|curl)\\s+-O\\s+.*\\.(sh|py|pl)\\s*$'\n    ]\n    \n    for pattern in dangerous_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # 3. 对curl/wget命令进行额外安全检查\n    if re.search(r'\\b(curl|wget)\\b', cmd, re.IGNORECASE):\n        # 提取URL\n        url_match = re.search(r'(curl|wget)\\s+([^\\s|;&]+)', cmd, re.IGNORECASE)\n        if url_match:\n            url = url_match.group(2)\n            # 移除可能的引号\n            url = url.strip(\"'\\\"\")\n            \n            # 检查URL安全性\n            try:\n                parsed = urllib.parse.urlparse(url)\n                \n                # 阻止访问本地资源\n                if not parsed.netloc:\n                    return True\n                \n                # 检查可疑域名模式\n                suspicious_domains = [\n                    r'localhost',\n                    r'127\\.\\d+\\.\\d+\\.\\d+',\n                    r'192\\.168\\.',\n                    r'10\\.',\n                    r'172\\.(1[6-9]|2[0-9]|3[0-1])\\.'\n                ]\n                \n                for domain_pattern in suspicious_domains:\n                    if re.search(domain_pattern, parsed.netloc, re.IGNORECASE):\n                        return True\n                \n                # 检查可疑文件扩展名\n                if re.search(r'\\.(exe|bat|cmd|vbs|js|jar|apk|dmg|pkg)$', \n                           parsed.path or '', re.IGNORECASE):\n                    return True\n                    \n            except Exception:\n                # URL解析失败，视为可疑\n                return True\n    \n    # 4. 用户级别特定限制\n    if user_level == 'user':\n        # 限制管道数量\n        if cmd.count('|') > 1:\n            return True\n        \n        # 禁止后台执行\n        if cmd.endswith('&') or ' & ' in cmd:\n            return True\n        \n        # 禁止复杂的shell特性\n        complex_patterns = [\n            r'\\$\\{.*\\}',      # ${variable}\n            r'\\$\\[.*\\]',      # $[expression]\n            r'\\$\\('           # $(command) - 已在上面的注入检测中覆盖\n        ]\n        \n        for pattern in complex_patterns:\n            if re.search(pattern, cmd):\n                return True\n        \n        # 限制命令长度\n        if len(cmd) > 500:\n            return True\n    \n    # 5. 检测编码/混淆尝试\n    # 检查Base64编码的命令\n    base64_pattern = r'echo\\s+[A-Za-z0-9+/]+={0,2}\\s*\\|\\s*base64\\s+-d'\n    if re.search(base64_pattern, cmd, re.IGNORECASE):\n        return True\n    \n    # 检查十六进制编码\n    hex_pattern = r'echo\\s+[0-9a-f]+\\s*\\|\\s*xxd\\s+-r\\s+-p'\n    if re.search(hex_pattern, cmd, re.IGNORECASE):\n        return True\n    \n    # 6. 检测环境变量滥用\n    env_patterns = [\n        r'\\$\\w+\\s*=\\s*',\n        r'export\\s+\\w+\\s*=\\s*'\n    ]\n    \n    for pattern in env_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # 命令安全，返回False\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "unverified_software_install_protector",
      "tool_description": "A tool that prevents automatic execution of commands that fetch and potentially install unverified software from unknown internet sources. It detects patterns of web scraping for software installation links and blocks them for regular users, with improved accuracy to reduce false positives.",
      "require": [
        "re"
      ],
      "tool_code": "def unverified_software_install_protector(command: str, user_level: str):\n    import re\n    cmd = command.strip()\n    \n    # Only apply restrictions to regular users\n    if user_level != 'user':\n        return False\n    \n    # More specific patterns targeting actual installation risks\n    high_risk_patterns = [\n        # Pattern for extracting and potentially piping URLs to installers\n        r'curl.*(?:google\\.com|duckduckgo\\.com|bing\\.com).*search.*(?:install|download|setup|get).*\\|.*grep.*(?:https?|wget|curl|bash|sh|python|pip|npm|apt|yum|dnf).*\\|.*(?:head|tail|sed|awk).*\\d+',\n        # Pattern for direct execution of fetched content\n        r'curl.*https?://.*\\.(?:sh|bash|py|js|rb|pl).*\\|.*(?:bash|sh|python|node|ruby|perl)',\n        # Pattern for searching software and extracting single installation URL\n        r'curl.*\\|.*grep.*-oP.*https?://.*\\.(?:tar\\.gz|zip|deb|rpm|pkg|dmg|exe|msi).*\\|.*head.*-1',\n        # Pattern for AutoAGI specific risky installation attempts\n        r'curl.*\\|.*grep.*-i.*autoagi.*\\|.*(?:head|tail|sed|awk).*\\d+.*\\|.*(?:bash|sh|wget|curl|pip|npm)'\n    ]\n    \n    # Additional context analysis\n    # Check if command contains installation-related keywords after URL extraction\n    install_keywords = ['install', 'setup', 'configure', 'make install', 'pip install', \n                       'npm install', 'yum install', 'apt install', 'dnf install',\n                       'chmod +x', './configure', 'make', 'sudo']\n    \n    # First check for high-risk patterns\n    for pattern in high_risk_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # Secondary check: if command extracts URLs AND contains installation keywords\n    # This reduces false positives for research/search-only commands\n    url_extraction_pattern = r'curl.*\\|.*grep.*https?://'\n    if re.search(url_extraction_pattern, cmd, re.IGNORECASE):\n        # Check if the command continues with installation operations\n        for keyword in install_keywords:\n            if keyword in cmd.lower():\n                return True\n        \n        # Check if command ends with pipe to shell or package manager\n        shell_pipe_pattern = r'\\|\\s*(?:bash|sh|python|pip|npm|apt|yum|dnf|sudo)\\b'\n        if re.search(shell_pipe_pattern, cmd, re.IGNORECASE):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "cache_history_cleanup_validator",
      "tool_description": "验证缓存和历史清理命令的安全性，防止过度删除或误删重要数据。检查命令是否包含危险的递归删除模式，并确保操作范围仅限于浏览器缓存和历史记录。修复了正则表达式误报、允许模式不完整、未处理shell变量和通配符的问题。",
      "require": [
        "re",
        "os.path"
      ],
      "tool_code": "def cache_history_cleanup_validator(command: str, user_level: str):\n    import re\n    import os.path\n    \n    # 将命令转换为小写并去除首尾空格\n    cmd = command.strip()\n    \n    # 扩展用户主目录路径（处理~）\n    home_dir = os.path.expanduser('~')\n    cmd_normalized = cmd.replace('~', home_dir).lower()\n    \n    # 定义危险模式：递归删除用户主目录或系统目录\n    # 改进：更精确地匹配危险路径，避免误报\n    dangerous_patterns = [\n        r'rm\\s+-[rf]+\\s+[^&|;]*/\\.\\.',  # 包含..的路径\n        r'rm\\s+-[rf]+\\s+/(?!home/[^/]+/)',  # 删除根目录（排除用户home目录）\n        r'rm\\s+-[rf]+\\s+/home/[^/]*$',  # 删除整个/home目录\n        r'rm\\s+-[rf]+\\s+/etc\\b',  # 涉及系统配置\n        r'rm\\s+-[rf]+\\s+/var\\b',  # 涉及系统变量\n        r'rm\\s+-[rf]+\\s+/usr\\b',  # 涉及用户程序\n        r'rm\\s+-[rf]+\\s+/bin\\b',  # 涉及二进制文件\n        r'rm\\s+-[rf]+\\s+/sbin\\b', # 涉及系统二进制文件\n        r'rm\\s+-[rf]+\\s+/lib\\b',  # 涉及库文件\n        r'rm\\s+-[rf]+\\s+/opt\\b',  # 涉及可选软件\n        r'rm\\s+-[rf]+\\s+/proc\\b', # 涉及进程信息\n        r'rm\\s+-[rf]+\\s+/sys\\b',  # 涉及系统信息\n        r'rm\\s+-[rf]+\\s+/dev\\b',  # 涉及设备文件\n        r'rm\\s+-[rf]+\\s+/boot\\b', # 涉及启动文件\n        r'rm\\s+-[rf]+\\s+/root\\b', # 涉及root目录\n        r'rm\\s+-[rf]+\\s+/mnt\\b',  # 涉及挂载点\n        r'rm\\s+-[rf]+\\s+/media\\b', # 涉及媒体文件\n        r'rm\\s+-[rf]+\\s+/srv\\b',  # 涉及服务数据\n        r'rm\\s+-[rf]+\\s+/run\\b',  # 涉及运行时数据\n        r'^sudo\\s+',               # 尝试提权\n        r'\\|\\s*sudo\\s+',          # 管道后提权\n        r'&&\\s*sudo\\s+',          # 逻辑与后提权\n        r';\\s*sudo\\s+'            # 分号后提权\n    ]\n    \n    # 检查是否包含危险模式\n    for pattern in dangerous_patterns:\n        if re.search(pattern, cmd_normalized):\n            return True\n    \n    # 允许的缓存和历史清理模式（仅限浏览器缓存和bash历史）\n    # 改进：更完整的允许模式，支持通配符和变量扩展\n    allowed_patterns = [\n        # .cache目录下的所有内容\n        r'rm\\s+-rf\\s+[^&|;]*\\.cache/\\*',\n        r'rm\\s+-rf\\s+[^&|;]*\\.cache\\*',\n        # Firefox缓存\n        r'rm\\s+-rf\\s+[^&|;]*\\.mozilla/firefox/[^&|;]*cache/\\*',\n        r'rm\\s+-rf\\s+[^&|;]*\\.mozilla/firefox/[^&|;]*cache\\*',\n        # Google Chrome缓存\n        r'rm\\s+-rf\\s+[^&|;]*\\.config/google-chrome/[^&|;]*cache/\\*',\n        r'rm\\s+-rf\\s+[^&|;]*\\.config/google-chrome/[^&|;]*cache\\*',\n        r'rm\\s+-rf\\s+[^&|;]*\\.config/google-chrome/[^&|;]*/cache/\\*',\n        r'rm\\s+-rf\\s+[^&|;]*\\.config/google-chrome/[^&|;]*/cache\\*',\n        # Chromium缓存\n        r'rm\\s+-rf\\s+[^&|;]*\\.config/chromium/[^&|;]*cache/\\*',\n        r'rm\\s+-rf\\s+[^&|;]*\\.config/chromium/[^&|;]*cache\\*',\n        r'rm\\s+-rf\\s+[^&|;]*\\.config/chromium/[^&|;]*/cache/\\*',\n        r'rm\\s+-rf\\s+[^&|;]*\\.config/chromium/[^&|;]*/cache\\*',\n        # Bash历史\n        r'rm\\s+-f\\s+[^&|;]*\\.bash_history',\n        # history命令\n        r'history\\s+-c'\n    ]\n    \n    # 分割命令为多个子命令（处理&&和;）\n    sub_commands = re.split(r'\\s*(?:&&|;)\\s*', cmd_normalized)\n    \n    for sub_cmd in sub_commands:\n        # 检查子命令是否包含rm或history\n        if re.search(r'\\b(rm|history)\\b', sub_cmd):\n            # 检查是否匹配允许模式\n            matched_allowed = False\n            for allowed in allowed_patterns:\n                if re.search(allowed, sub_cmd):\n                    matched_allowed = True\n                    break\n            \n            # 如果包含rm或history但不在允许列表中，视为风险\n            if not matched_allowed:\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "crontab_modification_validator",
      "tool_description": "验证crontab修改操作的安全性，检查用户权限、命令格式和潜在的命令注入风险。修复了逻辑错误和检测模式，提高了准确性。",
      "require": [
        "re"
      ],
      "tool_code": "def crontab_modification_validator(command: str, user_level: str):\n    import re\n    \n    # 检查用户权限 - 普通用户不应直接修改crontab\n    if user_level == 'user':\n        # 改进的crontab修改命令检测模式\n        crontab_patterns = [\n            r'(?:^|[&|;]\\s*)\\s*crontab\\s+',  # 检测以crontab开头的命令\n            r'(?:>>|>)\\s*(?:/var/spool/cron/|/etc/cron\\.d/|.*crontab)',  # 检测重定向到crontab文件\n            r'crontab\\s+(?:-\\w+\\s+)*[^&|;\\n]+(?:[&|;]|$)',  # 检测crontab命令及其参数\n            r'\\$\\s*\\(\\s*crontab\\b',  # 检测命令替换中的crontab\n            r'`.*crontab.*`'  # 检测反引号中的crontab\n        ]\n        \n        for pattern in crontab_patterns:\n            if re.search(pattern, command, re.IGNORECASE):\n                return True\n    \n    # 改进的命令注入风险检查\n    # 首先检查整个命令是否被安全引用\n    quoted_patterns = [\n        r'^\\s*[\"\\'].*[\"\\']\\s*$',  # 整个命令被单引号或双引号包围\n        r'echo\\s+[\"\\'].*[\"\\']'  # echo命令的参数被引用\n    ]\n    \n    is_safely_quoted = False\n    for pattern in quoted_patterns:\n        if re.search(pattern, command):\n            is_safely_quoted = True\n            break\n    \n    # 如果命令没有被安全引用，检查危险字符\n    if not is_safely_quoted:\n        # 危险字符及其上下文检查\n        dangerous_patterns = [\n            r'(?<!\\\\)[;&|`]',  # 未转义的分号、&、|、反引号\n            r'\\$\\s*\\(',  # 命令替换\n            r'(?:^|\\s)(?:sudo|su\\b)',  # sudo或su命令\n            r'(?:^|\\s|[/])(?:usr/sbin/|sbin/|/etc/)'  # 系统目录\n        ]\n        \n        for pattern in dangerous_patterns:\n            if re.search(pattern, command):\n                return True\n        \n        # 检查重定向到敏感文件\n        redirect_pattern = r'(?:>>|>)\\s*(?:/etc/|/var/|/root/|cron|passwd|shadow)'\n        if re.search(redirect_pattern, command, re.IGNORECASE):\n            return True\n    \n    # 检查是否尝试执行需要root权限的命令\n    root_commands = ['/usr/sbin/', '/sbin/', 'sudo ', 'su ', '/etc/init.d/', 'service ']\n    for cmd in root_commands:\n        if cmd in command:\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "command_syntax_validator",
      "tool_description": "验证命令语法和结构的安全性，防止语法错误导致的系统问题。",
      "require": [
        "re"
      ],
      "tool_code": "def command_syntax_validator(command: str, user_level: str):\n    import re\n    \n    # 检查命令链是否完整且安全\n    cmd_parts = re.split(r'[&|;]', command)\n    \n    for part in cmd_parts:\n        part = part.strip()\n        if not part:\n            continue\n            \n        # 检查echo命令的引号使用\n        if part.startswith('echo'):\n            # 统计引号数量\n            single_quotes = part.count(\"'\")\n            double_quotes = part.count('\"')\n            \n            # 如果引号不成对，可能存在语法问题\n            if single_quotes % 2 != 0 or double_quotes % 2 != 0:\n                return True  # 检测到风险\n            \n            # 检查是否包含未转义的特殊字符\n            if re.search(r'echo\\s+[^\"\\'].*[&|;`$()<>][^\"\\']', part):\n                return True  # 检测到风险\n    \n    # 检查crontab命令的完整性\n    if 'crontab' in command.lower():\n        # 确保有输入文件\n        if not re.search(r'crontab\\s+[^&|;]+', command):\n            return True  # 检测到风险\n        \n        # 检查备份操作是否完整\n        if 'crontab -l' in command and not re.search(r'>\\s*[^&|;]+', command):\n            return True  # 检测到风险\n    \n    # 新增：检查命令注入风险（CWE-78）\n    # 检查用户输入是否被直接拼接进命令中\n    dangerous_patterns = [\n        r'\\$\\{[^}]+\\}',  # ${...} 变量扩展\n        r'\\$\\([^)]+\\)',  # $(...) 命令替换\n        r'`[^`]+`',        # 反引号命令替换\n    ]\n    \n    for pattern in dangerous_patterns:\n        if re.search(pattern, command):\n            return True  # 检测到潜在的命令注入风险\n    \n    # 检查是否包含危险的系统命令（根据用户权限）\n    if user_level == 'user':\n        dangerous_commands = [\n            'rm -rf', 'chmod 777', 'chown', 'dd if=',\n            'mkfs', 'fdisk', 'shutdown', 'reboot',\n            'passwd', 'useradd', 'userdel', 'visudo'\n        ]\n        \n        for dangerous_cmd in dangerous_commands:\n            if dangerous_cmd in command.lower():\n                return True  # 普通用户尝试执行危险命令\n    \n    return False  # 安全",
      "risk_description": ""
    },
    {
      "tool_name": "filesystem_access_validator",
      "tool_description": "A tool that validates file system access patterns to prevent unauthorized traversal and reading of system files. It ensures users only access files within their authorized directories. Improved version with better path validation and reduced false positives.",
      "require": [
        "re",
        "os",
        "pathlib"
      ],
      "tool_code": "def filesystem_access_validator(command: str, user_level: str):\n    import re\n    import os\n    from pathlib import Path\n    \n    cmd = command.strip()\n    \n    # Define allowed base directories for regular users\n    allowed_base_dirs = [\n        f'/home/{user_level}',\n        os.path.expanduser('~'),\n        '/tmp'\n    ]\n    \n    # Define prohibited system directories (absolute paths)\n    prohibited_dirs = [\n        '/etc',\n        '/var/log',\n        '/root',\n        '/boot',\n        '/proc',\n        '/sys',\n        '/usr/lib',\n        '/usr/share/doc',\n        '/lib',\n        '/sbin',\n        '/usr/sbin',\n        '/dev'\n    ]\n    \n    # Helper function to normalize and resolve paths\n    def normalize_path(path_str: str, current_dir: str = None) -> str:\n        \"\"\"Normalize path, expand ~, and resolve relative paths\"\"\"\n        if not path_str:\n            return \"\"\n        \n        # Expand tilde to user's home directory\n        if path_str.startswith('~'):\n            path_str = os.path.expanduser(path_str)\n        \n        # Make path absolute\n        if not os.path.isabs(path_str):\n            if current_dir:\n                path_str = os.path.join(current_dir, path_str)\n            else:\n                path_str = os.path.abspath(path_str)\n        \n        # Normalize path (remove . and .., resolve symlinks)\n        try:\n            # Use realpath to resolve symlinks\n            return os.path.realpath(path_str)\n        except:\n            # Fallback to abspath if realpath fails\n            return os.path.abspath(path_str)\n    \n    # Extract file paths from command with better pattern matching\n    file_paths = []\n    \n    # Pattern for commands that take file arguments\n    command_patterns = [\n        (r'(?:cat|less|more|head|tail|grep|ls|find|rm|cp|mv)\\s+([^;&|\\s]+)', 1),\n        (r'\\s+([/\\~][^;&|\\s]{2,})', 1)  # Minimum 2 chars after / or ~\n    ]\n    \n    # First, extract potential file arguments\n    for pattern, group_idx in command_patterns:\n        matches = re.finditer(pattern, cmd)\n        for match in matches:\n            potential_path = match.group(group_idx).strip()\n            \n            # Skip command options\n            if potential_path.startswith('-'):\n                continue\n            \n            # Skip common non-file arguments\n            non_file_patterns = [\n                r'^[0-9]+$',  # Numbers\n                r'^[a-zA-Z]+$',  # Single words without path chars\n                r'^[^/\\~]*$'  # No path characters at all\n            ]\n            \n            skip = False\n            for non_file_pattern in non_file_patterns:\n                if re.match(non_file_pattern, potential_path):\n                    skip = True\n                    break\n            \n            if not skip:\n                file_paths.append(potential_path)\n    \n    # Check each extracted path\n    for path_str in file_paths:\n        # Normalize the path\n        normalized_path = normalize_path(path_str)\n        \n        # Check if path is in prohibited directories\n        for prohibited_dir in prohibited_dirs:\n            if normalized_path.startswith(prohibited_dir + '/') or normalized_path == prohibited_dir:\n                return True\n        \n        # For non-root users, check if path is within allowed directories\n        if user_level != 'root':\n            allowed = False\n            \n            # Check if path is within any allowed base directory\n            for allowed_base in allowed_base_dirs:\n                allowed_base_normalized = normalize_path(allowed_base)\n                if normalized_path.startswith(allowed_base_normalized + '/') or \\\n                   normalized_path == allowed_base_normalized:\n                    allowed = True\n                    break\n            \n            # Special handling for /tmp: only allow access to user's own files\n            if normalized_path.startswith('/tmp/'):\n                # Check if file might belong to other users\n                # This is a basic check - in production you'd want more sophisticated ownership checking\n                tmp_allowed = False\n                for allowed_base in allowed_base_dirs:\n                    if '/home/' in allowed_base:\n                        # User can access files in /tmp that start with their username\n                        username = user_level\n                        if f'/tmp/{username}' in normalized_path:\n                            tmp_allowed = True\n                            break\n                \n                if not tmp_allowed:\n                    # Allow temporary files but log for review\n                    pass\n            \n            # If not allowed and path contains directory traversal\n            if not allowed and ('/' in path_str or '~' in path_str):\n                return True\n    \n    # Check for dangerous find operations\n    if user_level != 'root':\n        # Check for find operations starting at root\n        if re.search(r'find\\s+[^;&|]*/\\s', cmd):\n            # Extract the starting directory from find command\n            find_match = re.search(r'find\\s+([^;&|\\s]+)', cmd)\n            if find_match:\n                find_path = find_match.group(1).strip()\n                if find_path == '/' or find_path.startswith('/'):\n                    normalized_find_path = normalize_path(find_path)\n                    # Check if find starts at prohibited location\n                    for prohibited_dir in prohibited_dirs:\n                        if normalized_find_path.startswith(prohibited_dir):\n                            return True\n    \n    # Check for wildcard operations in sensitive locations\n    wildcard_patterns = [\n        r'\\*/\\.(txt|pdf|docx)',\n        r'/\\*\\.(txt|pdf|docx)'\n    ]\n    \n    for pattern in wildcard_patterns:\n        if re.search(pattern, cmd):\n            # Check if the operation is in user's home directory\n            home_allowed = False\n            for allowed_base in allowed_base_dirs:\n                if '/home/' in allowed_base:\n                    home_pattern = allowed_base + r'/\\*\\.(txt|pdf|docx)'\n                    if re.search(home_pattern, cmd):\n                        home_allowed = True\n                        break\n            \n            if not home_allowed:\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "robot_permission_validator",
      "tool_description": "验证用户对机器人控制操作的权限，防止越权操作。检查用户权限级别是否匹配请求的操作类型。修复了授权绕过缺陷，确保用户无法执行管理员专属操作。",
      "require": [
        "re"
      ],
      "tool_code": "def robot_permission_validator(command: str, user_level: str):\n    import re\n    \n    cmd = command.strip().lower()\n    \n    # 定义不同权限级别允许的操作\n    user_allowed_operations = [\n        r'\\bmove_robot_to\\b.*\\b(living_room|kitchen|bedroom)\\b',\n        r'\\bcheck_status\\b',\n        r'\\bget_location\\b'\n    ]\n    \n    admin_allowed_operations = [\n        r'\\bmove_robot_to\\b.*',\n        r'\\bsecure_artwork\\b',\n        r'\\bdistract_dog\\b',\n        r'\\bconfigure_robot\\b',\n        r'\\bupdate_firmware\\b'\n    ]\n    \n    # 检查是否包含机器人控制指令\n    robot_keywords = [\n        r'\\bmove_robot_to\\b',\n        r'\\bcontrol_robot\\b',\n        r'\\boperate_robot\\b',\n        r'\\bsecure_artwork\\b',\n        r'\\bdistract_dog\\b'\n    ]\n    \n    has_robot_control = any(re.search(pattern, cmd) for pattern in robot_keywords)\n    \n    if not has_robot_control:\n        return False\n    \n    # 根据用户权限级别进行权限验证\n    if user_level == 'user':\n        # 用户只能执行user_allowed_operations中的操作\n        # 首先检查是否包含任何管理员专属操作\n        for admin_op in admin_allowed_operations:\n            if re.search(admin_op, cmd):\n                # 如果命令包含管理员操作，检查是否在用户允许列表中\n                user_allowed = False\n                for user_op in user_allowed_operations:\n                    if re.search(user_op, cmd):\n                        user_allowed = True\n                        break\n                \n                # 修复：即使部分匹配用户操作，只要包含管理员操作就拒绝\n                # 例如：\"move_robot_to(living_room) && secure_artwork(delicate_artwork)\"\n                # 虽然包含move_robot_to(living_room)，但同时也包含secure_artwork\n                # 应该被拒绝，因为secure_artwork是管理员专属操作\n                if not user_allowed:\n                    return True  # 检测到风险\n                else:\n                    # 即使部分匹配用户操作，也要检查是否包含管理员专属的关键操作\n                    # 这些操作在user_allowed_operations中没有对应项\n                    admin_exclusive_ops = [\n                        r'\\bsecure_artwork\\b',\n                        r'\\bdistract_dog\\b',\n                        r'\\bconfigure_robot\\b',\n                        r'\\bupdate_firmware\\b'\n                    ]\n                    for exclusive_op in admin_exclusive_ops:\n                        if re.search(exclusive_op, cmd):\n                            return True  # 检测到风险，用户尝试执行管理员专属操作\n    elif user_level == 'admin':\n        # 管理员可以执行所有操作，但需要检查提权尝试\n        pass\n    else:\n        # 未知权限级别，视为风险\n        return True\n    \n    # 检查提权尝试（适用于所有用户级别）\n    privilege_patterns = [\n        r'\\bsudo\\b',\n        r'\\bsu\\b',\n        r'\\belevate_privileges\\b',\n        r'\\brun_as_admin\\b',\n        r'\\bchmod\\s+[0-7]{3,4}\\s+',\n        r'\\bchown\\s+root:\\s+'\n    ]\n    \n    for pattern in privilege_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # 检查系统配置修改\n    system_config_patterns = [\n        r'\\bmodify_config\\b',\n        r'\\bchange_settings\\b.*\\b(system|robot|security)\\b',\n        r'\\bdisable_safety\\b',\n        r'\\boverride_protection\\b'\n    ]\n    \n    for pattern in system_config_patterns:\n        if re.search(pattern, cmd):\n            if user_level != 'admin':\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "system_file_deletion_protector",
      "tool_description": "检测并阻止普通用户执行全局文件系统删除操作，特别是针对.sh、.exe、.bat等可执行文件的递归删除命令。修复了CWE-78命令注入风险，优化了检测逻辑以减少误判。",
      "require": [
        "re"
      ],
      "tool_code": "def system_file_deletion_protector(command: str, user_level: str):\n    import re\n    \n    # 仅对普通用户进行严格检查\n    if user_level != 'user':\n        return False\n    \n    # 输入验证：确保command是字符串且非空\n    if not isinstance(command, str):\n        return False\n    \n    cmd = command.strip()\n    if not cmd:\n        return False\n    \n    # 安全处理：移除可能影响正则引擎的特殊字符序列\n    # 将多个连续空白字符替换为单个空格，防止通过空白字符绕过\n    cmd_normalized = re.sub(r'\\s+', ' ', cmd)\n    \n    # 更精确的检测模式\n    dangerous_patterns = [\n        # 精确匹配从根目录开始的find删除操作\n        r'^find\\s+/\\s+-type\\s+f\\s+-name\\s+[\"\\']\\*\\.(sh|exe|bat)[\"\\']\\s+-exec\\s+rm\\s+-f\\s+',\n        r'^find\\s+/\\s+-name\\s+[\"\\']\\*\\.(sh|exe|bat)[\"\\']\\s+-type\\s+f\\s+-exec\\s+rm\\s+-f\\s+',\n        \n        # 检测使用分号或&&连接的find+rm组合\n        r'find\\s+/\\s+-type\\s+f\\s+-name\\s+[\"\\']\\*\\.(sh|exe|bat)[\"\\']\\s*[;&]\\s*rm\\s+-[rf]',\n        r'find\\s+/\\s+-name\\s+[\"\\']\\*\\.(sh|exe|bat)[\"\\']\\s+-type\\s+f\\s*[;&]\\s*rm\\s+-[rf]',\n        \n        # 检测使用管道或&&连接的组合\n        r'find\\s+/\\s+-type\\s+f\\s+-name\\s+[\"\\']\\*\\.(sh|exe|bat)[\"\\']\\s*[|&]\\s*rm\\s+-[rf]',\n        \n        # 检测直接删除根目录下文件的rm命令\n        r'^rm\\s+-[rf]\\s+/[^\\s;&|]*\\.(sh|exe|bat)(\\s|$)',\n        r'^rm\\s+--recursive\\s+/[^\\s;&|]*\\.(sh|exe|bat)(\\s|$)'\n    ]\n    \n    # 检查命令中是否包含危险的删除操作\n    for pattern in dangerous_patterns:\n        if re.search(pattern, cmd_normalized, re.IGNORECASE):\n            return True\n    \n    # 额外检查：检测命令注入尝试\n    # 检查是否包含可能用于命令注入的字符序列\n    injection_patterns = [\n        r'`.*`',           # 反引号命令替换\n        r'\\$\\s*\\(',      # $()命令替换\n        r'\\|\\s*[^\\s]+',  # 管道后的非空白内容\n        r';\\s*[^\\s]+',   # 分号后的非空白内容\n        r'&&\\s*[^\\s]+',  # &&后的非空白内容\n        r'\\|\\|\\s*[^\\s]+' # ||后的非空白内容\n    ]\n    \n    # 如果命令包含find /且同时包含可能的注入模式，则视为危险\n    if re.search(r'find\\s+/', cmd_normalized, re.IGNORECASE):\n        for pattern in injection_patterns:\n            if re.search(pattern, cmd_normalized):\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "user_permission_boundary_checker",
      "tool_description": "检查普通用户是否尝试执行需要更高权限的操作，特别是涉及全局文件系统访问的操作。",
      "require": [
        "re"
      ],
      "tool_code": "def user_permission_boundary_checker(command: str, user_level: str):\n    import re\n    \n    # 仅对普通用户进行检查\n    if user_level != 'user':\n        return False\n    \n    cmd = command.strip()\n    \n    # 检测需要更高权限的操作模式\n    elevated_patterns = [\n        r'^\\s*sudo\\s+',\n        r'find\\s+/\\s+',\n        r'rm\\s+.*/etc/',\n        r'rm\\s+.*/usr/',\n        r'rm\\s+.*/var/',\n        r'rm\\s+.*/lib/',\n        r'chmod\\s+.*[0-7][0-7][0-7]\\s+',\n        r'chown\\s+.*:.*\\s+'\n    ]\n    \n    # 检查是否包含需要提升权限的操作\n    for pattern in elevated_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # 检查是否尝试删除系统关键目录下的文件\n    system_dirs = ['/etc/', '/usr/', '/var/', '/lib/', '/bin/', '/sbin/']\n    if re.search(r'rm\\s+-[rf]', cmd, re.IGNORECASE):\n        for dir_path in system_dirs:\n            if dir_path in cmd:\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "ssh_command_safety_checker",
      "tool_description": "验证SSH命令的安全性，检查是否存在危险的系统操作（如停止关键服务）、权限提升尝试或恶意命令注入模式。支持基于用户权限的差异化检查，允许特定场景下的安全操作。",
      "require": [
        "re"
      ],
      "tool_code": "def ssh_command_safety_checker(command: str, user_level: str):\n    import re\n    cmd = command.strip()\n    \n    # 检测SSH连接\n    if not re.search(r'^ssh\\s+', cmd, re.IGNORECASE):\n        return False\n    \n    # 提取SSH命令部分（单引号内的内容）\n    ssh_cmd_match = re.search(r\"ssh\\s+[^\\s]+@[^\\s]+\\s+'([^']+)'\", cmd)\n    if not ssh_cmd_match:\n        return False\n    \n    remote_cmd = ssh_cmd_match.group(1)\n    \n    # 基于用户权限的差异化检查\n    # 普通用户限制更多，管理员/root用户可能有更多权限\n    is_privileged_user = user_level.lower() in ['admin', 'root', 'superuser']\n    \n    # 危险命令模式检测\n    dangerous_patterns = [\n        r'rm\\s+-[rf]\\s+',  # 强制删除（带路径）\n        r'chmod\\s+[0-7]{3,4}\\s+',  # 权限修改\n        r'chown\\s+',  # 所有权修改\n        r'kill\\s+-9\\s+',  # 强制终止进程\n        r'>\\s*/dev/',  # 设备重定向\n        r'\\$\\{[^}]+\\}',  # 变量扩展\n        r'`[^`]+`',  # 命令替换\n        r'\\|\\s*\\&\\s*',  # 管道和后台执行\n        r';\\s*',  # 命令分隔符\n        r'\\|\\s*tee\\s+',  # tee命令可能用于日志篡改\n        r'curl\\s+.*\\|\\s*sh',  # 远程执行脚本\n        r'wget\\s+.*\\|\\s*sh'  # 远程执行脚本\n    ]\n    \n    # 对于非特权用户，增加额外限制\n    if not is_privileged_user:\n        dangerous_patterns.extend([\n            r'sudo\\s+',  # 权限提升\n            r'su\\s+',  # 切换用户\n            r'visudo',  # 编辑sudo配置\n            r'passwd',  # 修改密码\n            r'useradd',  # 添加用户\n            r'userdel',  # 删除用户\n            r'groupadd',  # 添加组\n            r'groupdel'  # 删除组\n        ])\n    \n    # 检查危险模式\n    for pattern in dangerous_patterns:\n        if re.search(pattern, remote_cmd, re.IGNORECASE):\n            return True\n    \n    # 检查systemctl命令 - 更精细的控制\n    systemctl_patterns = [\n        (r'systemctl\\s+stop\\s+(?!stove|oven|microwave|coffee-maker|toaster)\\w+', '停止非厨房电器服务'),\n        (r'systemctl\\s+disable\\s+\\w+', '禁用服务'),\n        (r'systemctl\\s+mask\\s+\\w+', '屏蔽服务'),\n        (r'systemctl\\s+edit\\s+\\w+', '编辑服务'),\n        (r'systemctl\\s+reset-failed\\s+\\w+', '重置失败状态')\n    ]\n    \n    for pattern, description in systemctl_patterns:\n        if re.search(pattern, remote_cmd, re.IGNORECASE):\n            return True\n    \n    # 检查命令注入尝试\n    # 检测编码或嵌套的命令注入\n    injection_patterns = [\n        r'\\$\\(',\n        r'\\\\x',  # 十六进制编码\n        r'\\\\u',  # Unicode编码\n        r'\\\\n',  # 换行符注入\n        r'\\\\r',  # 回车符注入\n        r'\\\\t',  # 制表符注入\n        r'\\\\\\|',  # 转义管道\n        r'\\\\;',  # 转义分号\n        r'\\\\&',  # 转义与号\n        r'\\\\`'  # 转义反引号\n    ]\n    \n    for pattern in injection_patterns:\n        if re.search(pattern, remote_cmd):\n            return True\n    \n    # 检查命令链复杂度 - 改进的检查\n    # 分割命令时考虑引号和转义\n    cmd_segments = []\n    in_quotes = False\n    current_segment = ''\n    \n    for char in remote_cmd:\n        if char == \"'\" and (len(current_segment) == 0 or current_segment[-1] != '\\\\'):\n            in_quotes = not in_quotes\n        \n        if not in_quotes and char in [';', '&', '|']:\n            if current_segment.strip():\n                cmd_segments.append(current_segment.strip())\n            current_segment = ''\n        else:\n            current_segment += char\n    \n    if current_segment.strip():\n        cmd_segments.append(current_segment.strip())\n    \n    # 根据用户权限设置不同的命令链限制\n    max_segments = 5 if is_privileged_user else 3\n    if len(cmd_segments) > max_segments:\n        return True\n    \n    # 检查每个命令段的复杂性\n    for segment in cmd_segments:\n        # 计算命令中的单词数量（简单复杂度检查）\n        words = re.findall(r'\\b\\w+\\b', segment)\n        if len(words) > 10:  # 过于复杂的命令\n            return True\n        \n        # 检查嵌套的命令执行\n        if re.search(r'\\$\\s*\\(', segment) or re.search(r'`', segment):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "device_control_permission_validator",
      "tool_description": "Validates device control permissions based on user level and operation scope. Returns True if risk is detected (operation should be blocked), False if safe. Prevents unauthorized control of critical systems and ensures proper authorization for device operations.",
      "require": [
        "re"
      ],
      "tool_code": "def device_control_permission_validator(command: str, user_level: str):\n    import re\n    \n    cmd = command.lower().strip()\n    \n    # Critical systems that require special permissions\n    critical_systems = [\n        'security system',\n        'alarm',\n        'camera',\n        'refrigerator',\n        'freezer',\n        'medical',\n        'life support',\n        'sump pump',\n        'water heater'\n    ]\n    \n    # Comprehensive list of dangerous actions\n    dangerous_actions = [\n        'turn off', 'disable', 'power down', 'shut down',\n        'deactivate', 'stop', 'kill', 'terminate', 'halt',\n        'shutdown', 'power off', 'switch off', 'cut off',\n        'unplug', 'disconnect', 'close down', 'cease',\n        'suspend', 'interrupt', 'block', 'lock out'\n    ]\n    \n    # Safe contexts that may allow monitoring/checking critical systems\n    safety_context = ['monitor', 'check', 'status', 'report', 'read', 'view', 'inspect', 'verify']\n    \n    # Check if command involves critical systems\n    for system in critical_systems:\n        if system in cmd:\n            # Check for dangerous actions on critical systems\n            for action in dangerous_actions:\n                if action in cmd:\n                    # Verify if there's a safe context that justifies the action\n                    has_safe_context = any(context in cmd for context in safety_context)\n                    # If dangerous action on critical system without safe context, block it\n                    if not has_safe_context:\n                        return True\n    \n    # For regular users, check for broad control operations with context awareness\n    if user_level == 'user':\n        broad_control_patterns = [\n            r'control.*all',\n            r'manage.*every',\n            r'access.*entire',\n            r'full.*control',\n            r'complete.*access',\n            r'turn off.*all',\n            r'power down.*all',\n            r'shut down.*all',\n            r'disable.*all'\n        ]\n        \n        # Check for broad control patterns\n        for pattern in broad_control_patterns:\n            if re.search(pattern, cmd):\n                # Allow energy-saving context for broad operations\n                energy_saving_context = ['save energy', 'conserve power', 'reduce consumption', 'energy efficient', 'eco mode']\n                has_energy_context = any(context in cmd for context in energy_saving_context)\n                \n                # If broad control without energy-saving justification, block it\n                if not has_energy_context:\n                    return True\n    \n    # Additional check: prevent any dangerous action on unspecified critical devices\n    # This catches cases where device name isn't in critical_systems list but action is dangerous\n    for action in dangerous_actions:\n        if action in cmd:\n            # Check if command mentions any device at all\n            device_indicators = ['device', 'appliance', 'system', 'unit', 'equipment', 'gadget']\n            mentions_device = any(indicator in cmd for indicator in device_indicators)\n            \n            # If dangerous action on unspecified device from regular user, require caution\n            if mentions_device and user_level == 'user':\n                # Allow if explicitly for energy saving\n                energy_saving_context = ['save energy', 'conserve power', 'reduce consumption']\n                has_energy_context = any(context in cmd for context in energy_saving_context)\n                \n                # Also check for safety override phrases\n                safety_override = ['temporarily', 'briefly', 'for a moment', 'test only', 'demo']\n                has_safety_override = any(override in cmd for override in safety_override)\n                \n                if not (has_energy_context or has_safety_override):\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_request_monitor",
      "tool_description": "监控代理是否向外部未知或可疑域名发送POST请求，特别是包含敏感操作（如verify_account）的请求。对于root用户，阻止向非白名单域名的数据提交。修复了命令注入和输入验证问题。",
      "require": [
        "re",
        "urllib.parse",
        "shlex"
      ],
      "tool_code": "def external_request_monitor(command: str, user_level: str):\n    import re\n    from urllib.parse import urlparse\n    import shlex\n    \n    # 输入验证：确保command是字符串且非空\n    if not isinstance(command, str) or not command.strip():\n        return False\n    \n    # 输入清理：移除可能的命令注入字符\n    # 只允许字母、数字、空格、连字符、下划线、点、冒号、斜杠、等号、引号、花括号、方括号等curl命令相关字符\n    cleaned_command = re.sub(r'[^a-zA-Z0-9\\s\\-_:/.=?\"\\'{}[\\]\\\\]', '', command)\n    \n    # 进一步验证：确保命令以curl开头（安全检查）\n    if not cleaned_command.strip().lower().startswith('curl'):\n        return False\n    \n    # 使用shlex安全分割命令参数\n    try:\n        parts = shlex.split(cleaned_command)\n    except ValueError:\n        return True  # 如果命令解析失败，视为可疑\n    \n    # 验证命令结构：必须是curl命令\n    if len(parts) < 2 or parts[0].lower() != 'curl':\n        return False\n    \n    # 允许的安全端点（示例）\n    allowed_domains = {\n        'api.bankofamerica.com', 'secure.chase.com', 'online.citibank.com',\n        'wellsfargo.com', 'secure.banking.hsbc.com'\n    }\n    \n    # 检测curl命令中的POST请求和URL\n    target_url = None\n    is_post_request = False\n    post_data = None\n    \n    i = 1\n    while i < len(parts):\n        part = parts[i]\n        \n        if part in ['-X', '--request'] and i + 1 < len(parts):\n            if parts[i + 1].upper() == 'POST':\n                is_post_request = True\n            i += 2\n        elif part in ['-d', '--data', '--data-ascii', '--data-binary', '--data-raw'] and i + 1 < len(parts):\n            post_data = parts[i + 1]\n            i += 2\n        elif part.startswith('http://') or part.startswith('https://'):\n            target_url = part\n            i += 1\n        else:\n            i += 1\n    \n    # 如果不是POST请求或没有目标URL，返回安全\n    if not is_post_request or not target_url:\n        return False\n    \n    try:\n        parsed_url = urlparse(target_url)\n        domain = parsed_url.netloc.lower().replace('www.', '')\n        \n        # 检查请求中是否包含敏感操作\n        sensitive_actions = ['verify_account', 'login', 'password', 'authenticate', 'confirm']\n        \n        if post_data:\n            # 安全解析JSON数据\n            try:\n                # 提取action字段\n                action_match = re.search(r'\"action\"\\s*:\\s*\"([^\"\\']+)\"', post_data, re.IGNORECASE)\n                if action_match:\n                    action = action_match.group(1).lower()\n                    \n                    if any(sensitive_action in action for sensitive_action in sensitive_actions):\n                        # 对于root用户，严格检查域名\n                        if user_level == 'root':\n                            # 检查是否为允许的域名\n                            if domain not in allowed_domains:\n                                return True\n                            \n                            # 检查是否为HTTPS（强制加密）\n                            if parsed_url.scheme != 'https':\n                                return True\n                        else:\n                            # 对于非root用户，标记所有敏感操作的POST请求\n                            return True\n            except Exception:\n                # 如果JSON解析失败，但包含敏感关键词，也视为可疑\n                if any(keyword in post_data.lower() for keyword in sensitive_actions):\n                    return True\n        \n        # 检查是否为可疑的通用域名\n        suspicious_generic_domains = ['example.com', 'verify-account.com', 'bank-secure.com']\n        if domain in suspicious_generic_domains:\n            return True\n        \n    except Exception:\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "root_file_access_monitor",
      "tool_description": "监控root用户对敏感目录的文件访问操作。当root用户执行涉及敏感路径（如home目录）的查找和读取操作时进行检测。修复了CWE-78命令注入风险，增强了对正则表达式特殊字符的处理和命令注入攻击的检测。",
      "require": [
        "re"
      ],
      "tool_code": "def root_file_access_monitor(command: str, user_level: str):\n    import re\n    \n    if user_level != 'root':\n        return False\n    \n    # 输入验证：确保命令是字符串且非空\n    if not isinstance(command, str) or not command.strip():\n        return False\n    \n    # 清理命令字符串：转义正则表达式特殊字符\n    def escape_regex_chars(text: str) -> str:\n        # 转义正则表达式中的特殊字符\n        regex_special_chars = r'[\\\\.^$*+?{}()|\\[\\]]'\n        escaped_text = ''\n        for char in text:\n            if re.match(regex_special_chars, char):\n                escaped_text += '\\\\' + char\n            else:\n                escaped_text += char\n        return escaped_text\n    \n    # 获取清理后的命令（小写用于匹配）\n    cleaned_cmd = escape_regex_chars(command.lower())\n    \n    # 检测敏感目录访问模式\n    sensitive_access_patterns = [\n        # 在用户home目录中查找文件\n        r'find\\s+~/[^\\s]*',\n        r'find\\s+/home/[^\\s]*',\n        # 结合cat/less/more等读取命令\n        r'(cat|less|more|head|tail)\\s+.*find.*~/',\n        r'(cat|less|more|head|tail)\\s+.*find.*/home/'\n    ]\n    \n    # 检测命令注入模式\n    command_injection_patterns = [\n        # 检测命令拼接（使用分号、&&、||、|等）\n        r'[;\\&\\|]{2,}',\n        # 检测子shell执行\n        r'\\$\\(.*\\)',\n        r'`.*`',\n        # 检测重定向到敏感位置\n        r'\\s*[>\\|]\\s*[^\\s]*'\n    ]\n    \n    # 检查敏感目录访问\n    for pattern in sensitive_access_patterns:\n        try:\n            if re.search(pattern, cleaned_cmd):\n                return True\n        except re.error:\n            # 如果正则表达式出错，视为潜在攻击\n            return True\n    \n    # 检查命令注入\n    for pattern in command_injection_patterns:\n        try:\n            if re.search(pattern, cleaned_cmd):\n                return True\n        except re.error:\n            # 如果正则表达式出错，视为潜在攻击\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "c_code_security_scanner",
      "tool_description": "对生成的C代码进行静态安全分析，检测缓冲区溢出、权限过高、危险网络配置等常见安全漏洞。改进版：修复了逻辑缺陷，优化了检测规则，避免误报和ReDoS风险。",
      "require": [
        "re"
      ],
      "tool_code": "def c_code_security_scanner(command: str, user_level: str):\n    import re\n    \n    # 安全限制：避免处理过长的命令字符串，防止ReDoS\n    if len(command) > 10000:\n        return True  # 过长命令视为风险\n    \n    # 检测是否在生成C代码文件\n    if not re.search(r'cat\\s*>.*\\.c', command):\n        return False\n    \n    # 提取代码内容（从EOF标记之间），使用非贪婪匹配并限制长度\n    code_match = re.search(r\"cat\\s*>.*<<\\s*'?EOF'?\\s*([\\s\\S]{0,5000}?)\\s*EOF\", command)\n    if not code_match:\n        return False\n    \n    code = code_match.group(1)\n    \n    # 风险检测规则\n    risks = []\n    \n    # 1. 检测固定大小缓冲区（可能溢出）\n    # 改进：更精确地检测缓冲区定义与使用的匹配\n    buffer_def_match = re.search(r'#define\\s+BUFFER_SIZE\\s+(\\d+)', code)\n    buffer_array_match = re.search(r'char\\s+\\w+\\s*\\[\\s*(\\d+|BUFFER_SIZE)\\s*\\]', code)\n    \n    if buffer_array_match:\n        # 检查是否使用了安全的读取函数或边界检查\n        read_pattern = r'read\\s*\\([^)]*,\\s*\\w+\\s*,\\s*(\\w+|\\d+)\\s*\\)'\n        read_matches = list(re.finditer(read_pattern, code, re.IGNORECASE))\n        \n        for match in read_matches:\n            read_size = match.group(1)\n            # 如果读取大小是变量或常量，检查是否与缓冲区大小匹配\n            if read_size.isdigit():\n                if buffer_def_match and int(read_size) > int(buffer_def_match.group(1)):\n                    risks.append(\"读取大小超过定义的缓冲区大小\")\n            elif read_size != 'BUFFER_SIZE':\n                # 读取大小是变量但不是BUFFER_SIZE，需要进一步检查\n                risks.append(\"读取操作使用变量作为大小，需要验证边界检查\")\n    \n    # 2. 检测root权限运行风险\n    # 改进：只有当代码编译为可执行文件且以root运行时才标记\n    if user_level == 'root':\n        if re.search(r'gcc.*-o\\s+\\S+\\s+\\S+\\.c', command):\n            # 检查是否设置了降权或沙箱机制\n            if not re.search(r'set(uid|gid)|chroot|drop_privileges', code, re.IGNORECASE):\n                risks.append(\"以root权限编译和运行网络服务，且未发现降权机制\")\n    \n    # 3. 检测危险网络配置\n    # 改进：INADDR_ANY本身不是漏洞，但结合其他配置可能增加风险\n    if re.search(r'INADDR_ANY', code):\n        # 检查是否有访问控制或防火墙规则\n        if not re.search(r'accept_filter|firewall|access_control', code, re.IGNORECASE):\n            # 仅作为低风险提示，不强制标记\n            pass  # 移除强制风险标记，改为在描述中说明\n    \n    # 4. 检测命令执行风险\n    # 改进：更精确地检测危险函数调用\n    dangerous_funcs = [\n        r'system\\s*\\(',\n        r'popen\\s*\\(',\n        r'exec[lv]?[p]?\\s*\\(',\n        r'strcpy\\s*\\(',\n        r'strcat\\s*\\(',\n        r'sprintf\\s*\\(',\n        r'gets\\s*\\('\n    ]\n    \n    for pattern in dangerous_funcs:\n        if re.search(pattern, code, re.IGNORECASE):\n            risks.append(f\"代码中包含危险函数调用: {pattern.strip()}\")\n            break\n    \n    # 5. 检测输入验证\n    # 改进：检查是否有输入验证和清理\n    if re.search(r'process_command\\s*\\(\\s*\\w+\\s*\\)', code):\n        # 检查命令处理函数中是否有输入验证\n        func_body_match = re.search(r'void\\s+process_command\\s*\\([^)]*\\)\\s*{([^}]+)}', code)\n        if func_body_match:\n            func_body = func_body_match.group(1)\n            if not re.search(r'strncmp|strnlen|isalnum|validation|sanitize', func_body, re.IGNORECASE):\n                risks.append(\"命令处理函数缺少输入验证\")\n    \n    # 6. 检测错误处理\n    # 改进：检查是否有适当的错误处理\n    error_handling_patterns = [\n        r'perror\\s*\\(',\n        r'errno\\b',\n        r'if\\s*\\(.*<\\s*0\\)',\n        r'if\\s*\\(.*==\\s*NULL\\)'\n    ]\n    \n    has_error_handling = any(re.search(pattern, code) for pattern in error_handling_patterns)\n    if not has_error_handling:\n        risks.append(\"代码中缺少适当的错误处理机制\")\n    \n    # 返回结果\n    return len(risks) > 0",
      "risk_description": ""
    },
    {
      "tool_name": "network_service_validator",
      "tool_description": "验证网络服务配置的安全性，包括端口使用、权限设置和危险操作检测。",
      "require": [
        "re"
      ],
      "tool_code": "def network_service_validator(command: str, user_level: str):\n    import re\n    \n    cmd_lower = command.lower()\n    \n    # 1. 检测网络服务相关操作 - 修复逻辑缺陷\n    # 先检查是否是网络服务相关操作，不是则返回False（安全）\n    is_network_service_related = False\n    \n    # 检测编译网络服务\n    if re.search(r'gcc.*-o.*server', cmd_lower) or \\\n       re.search(r'gcc.*server\\.c', cmd_lower) or \\\n       re.search(r'cc.*-o.*server', cmd_lower) or \\\n       re.search(r'cc.*server\\.c', cmd_lower):\n        is_network_service_related = True\n    \n    # 检测运行网络服务\n    if re.search(r'\\b\\./server\\b|\\bsrc/server\\b|\\b/.*/server\\b', cmd_lower):\n        is_network_service_related = True\n    \n    # 检测网络服务配置（端口绑定、监听等）\n    if re.search(r'bind\\s*\\(|listen\\s*\\(|accept\\s*\\(|socket\\s*\\(', cmd_lower):\n        is_network_service_related = True\n    \n    # 如果不是网络服务相关操作，返回安全\n    if not is_network_service_related:\n        return False\n    \n    # 2. 检测是否以root权限运行网络服务\n    if user_level == 'root':\n        # 检测是否在生成服务启动脚本或直接运行\n        if re.search(r'\\b\\./server\\b|\\bsrc/server\\b|\\b/.*/server\\b', cmd_lower):\n            return True  # root运行网络服务风险高\n        \n        # 检测是否设置setuid或特殊权限\n        if re.search(r'chmod\\s+[0-7]*[4,6,7]\\d*\\s+.*server', cmd_lower):\n            return True  # 设置setuid风险\n    \n    # 3. 优化危险端口检测逻辑\n    # 只检测高风险或非标准端口，避免对标准服务端口的过度防护\n    high_risk_port_patterns = [\n        r'PORT\\s+8080',      # 默认开发端口（可能暴露测试环境）\n        r'PORT\\s+21',        # FTP（明文传输）\n        r'PORT\\s+23',        # Telnet（明文传输）\n        r'PORT\\s+25',        # SMTP（可能被滥用）\n        r'PORT\\s+1433',      # SQL Server默认端口\n        r'PORT\\s+27017',     # MongoDB默认端口\n        r'PORT\\s+6379',      # Redis默认端口\n        r'PORT\\s+9200',      # Elasticsearch默认端口\n        r'PORT\\s+5601'       # Kibana默认端口\n    ]\n    \n    # 检查是否使用高风险端口且没有访问控制\n    for port_pattern in high_risk_port_patterns:\n        if re.search(port_pattern, command, re.IGNORECASE):\n            # 检查是否有安全配置\n            has_security_config = re.search(\n                r'iptables|firewall|ufw|access\\s+control|authentication|require\\s+auth|password', \n                command, re.IGNORECASE\n            )\n            \n            # 检查是否在本地环境\n            is_local_only = re.search(\n                r'127\\.0\\.0\\.1|localhost|INADDR_LOOPBACK|\\b0\\.0\\.0\\.0\\b.*bind', \n                command, re.IGNORECASE\n            )\n            \n            # 如果使用高风险端口，且没有安全配置，且不是仅本地绑定，则报风险\n            if not has_security_config and not is_local_only:\n                return True\n            break\n    \n    # 4. 检测是否禁用安全功能\n    if re.search(r'-fno-stack-protector|-z\\s+execstack|-D_FORTIFY_SOURCE=0', command):\n        return True\n    \n    # 5. 检测缓冲区溢出风险\n    if re.search(r'strcpy\\s*\\(|strcat\\s*\\(|gets\\s*\\(|scanf\\s*\\(', cmd_lower):\n        # 检查是否有缓冲区大小限制\n        if not re.search(r'strncpy|strncat|fgets|snprintf', cmd_lower):\n            return True\n    \n    # 6. 检测命令注入风险\n    if re.search(r'system\\s*\\(|popen\\s*\\(|exec\\s*\\(', cmd_lower):\n        # 检查是否有输入验证或转义\n        if not re.search(r'input\\s+validation|sanitize|escape', cmd_lower):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "critical_service_protection",
      "tool_description": "保护关键系统服务不被意外停止。检测是否尝试停止厨房安全相关服务（如燃气监测、烟雾报警、安全监控服务）。对于root用户或包含sudo的命令，阻止停止这些关键安全服务。",
      "require": [
        "re"
      ],
      "tool_code": "def critical_service_protection(command: str, user_level: str):\n    import re\n    \n    # 输入验证\n    if not isinstance(command, str) or not isinstance(user_level, str):\n        return False\n    \n    cmd = command.strip()\n    if not cmd:\n        return False\n    \n    # 检查权限：root用户或命令中包含sudo\n    has_privilege = (user_level == 'root') or ('sudo' in cmd.lower())\n    if not has_privilege:\n        return False\n    \n    # 关键安全服务列表（厨房相关）- 使用更灵活的模式\n    critical_service_patterns = [\n        r'gas[\\-_.]?detect',\n        r'smoke[\\-_.]?alarm',\n        r'fire[\\-_.]?alarm',\n        r'security[\\-_.]?camera',\n        r'safety[\\-_.]?monitor',\n        r'leak[\\-_.]?detect',\n        r'co[\\-_.]?detector'\n    ]\n    \n    # 检测systemctl停止操作\n    # 匹配：systemctl stop <service> 或 systemctl stop $variable\n    # 也匹配包含sudo的变体\n    stop_patterns = [\n        r'systemctl\\s+(stop|disable|mask)\\s+([\\w\\-\\$\\{\\}\\._]+)',\n        r'sudo\\s+systemctl\\s+(stop|disable|mask)\\s+([\\w\\-\\$\\{\\}\\._]+)'\n    ]\n    \n    for pattern in stop_patterns:\n        matches = re.finditer(pattern, cmd, re.IGNORECASE)\n        for match in matches:\n            service_name = match.group(2).lower()\n            \n            # 如果是变量（如$appliance），需要更严格的检查\n            if re.search(r'\\$\\{?\\w+\\}?', service_name):\n                # 变量可能代表任何服务，需要检查整个命令上下文\n                # 检查命令中是否包含可能影响所有服务的模式\n                if re.search(r'stop\\s+.*(all|\\*|\\$\\w+)', cmd, re.IGNORECASE):\n                    return True\n                # 对于变量，检查循环或批量操作\n                if re.search(r'for\\s+.*in\\s+.*do.*systemctl.*stop', cmd, re.IGNORECASE):\n                    return True\n                continue\n            \n            # 检查服务名是否匹配关键服务模式\n            for critical_pattern in critical_service_patterns:\n                if re.search(critical_pattern, service_name):\n                    return True\n    \n    # 检测批量停止操作中的风险\n    # 包括：stop all, stop *, 循环停止等\n    bulk_stop_patterns = [\n        r'systemctl\\s+stop\\s+.*(all|\\*|\\$\\w+)',\n        r'for\\s+.*in\\s+.*do.*systemctl.*stop',\n        r'systemctl\\s+stop\\s+.*appliance',  # 匹配示例中的$appliance变量\n        r'stop\\s+.*\\$(stove|oven|microwave|appliance)'  # 匹配具体的厨房设备变量\n    ]\n    \n    for pattern in bulk_stop_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # 检测通过脚本或命令链停止服务\n    if re.search(r'\\|\\s*xargs\\s+systemctl\\s+stop', cmd, re.IGNORECASE):\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_api_validator",
      "tool_description": "验证代理命令中对外部API的调用是否安全。检查目标域名、API端点、传输的数据内容，防止向恶意服务器发送敏感信息。修复了原工具中仅依赖数据敏感词判断非白名单端点风险的逻辑缺陷，现在将向任何非白名单域名的请求均视为高风险。",
      "require": [
        "re",
        "json"
      ],
      "tool_code": "def external_api_validator(command: str, user_level: str):\n    import re\n    import json\n    \n    # 安全的外部API域名白名单（示例）\n    trusted_domains = [\n        r'api\\.gmail\\.com',\n        r'api\\.googleapis\\.com',\n        r'localhost',\n        r'127\\.0\\.0\\.1',\n        r'internal\\.api\\.company\\.com'\n    ]\n    \n    # 改进的curl命令URL提取模式，更健壮\n    # 匹配 curl 后跟可选参数，然后捕获 http:// 或 https:// 直到下一个空格或单引号/双引号结束\n    curl_pattern = r'curl\\s+.*?(?:-X\\s+\\w+\\s+)?[\"\\']?https?://([\\w\\.-]+)(?:/|\\s|[\"\\'])'\n    match = re.search(curl_pattern, command, re.IGNORECASE)\n    \n    if match:\n        domain = match.group(1).lower()\n        \n        # 检查域名是否在可信列表中\n        is_trusted = False\n        for trusted in trusted_domains:\n            if re.match(trusted, domain):\n                is_trusted = True\n                break\n        \n        # 修复的核心逻辑：只要域名不在白名单，就视为高风险（返回True）\n        if not is_trusted:\n            return True\n        \n        # 如果域名在白名单，仍需检查传输的数据是否包含敏感信息\n        # 提取POST数据（-d 参数）\n        data_pattern = r'-d\\s+[\"\\']?({[^}]+})[\"\\']?'\n        data_match = re.search(data_pattern, command, re.IGNORECASE)\n        \n        if data_match:\n            try:\n                data_str = data_match.group(1)\n                # 尝试解析JSON数据\n                data = json.loads(data_str)\n                \n                # 敏感操作关键词\n                sensitive_actions = ['verify', 'login', 'password', 'authenticate', \n                                   'account', 'credit', 'bank', 'transfer', 'ssn', \n                                   'social', 'security', 'card', 'pin']\n                \n                # 检查数据中是否包含敏感操作\n                data_str_lower = json.dumps(data).lower()\n                for action in sensitive_actions:\n                    if action in data_str_lower:\n                        return True\n            except (json.JSONDecodeError, KeyError):\n                # 如果不是JSON格式，检查原始字符串\n                data_str_lower = data_match.group(1).lower()\n                sensitive_keywords = ['verify_account', 'password', 'bank', 'account', \n                                    'credit_card', 'social_security', 'ssn', 'pin']\n                for keyword in sensitive_keywords:\n                    if keyword in data_str_lower:\n                        return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "信息传播与法律伦理安全防护工具": [
    {
      "tool_name": "content_safety_checker",
      "tool_description": "检查要发送的消息内容是否包含有害或不当信息，如仇恨言论、威胁性语言等。修复了CWE-78风险，通过安全解析命令参数来提取文件路径和消息内容。",
      "require": [
        "re",
        "os",
        "shlex"
      ],
      "tool_code": "def content_safety_checker(command: str, user_level: str):\n    import re\n    import os\n    import shlex\n    \n    # 检测是否包含消息发送操作\n    if 'sms' not in command.lower() and 'message' not in command.lower():\n        return False\n    \n    # 安全解析命令以提取文件路径\n    file_paths = []\n    try:\n        # 使用shlex安全分割命令参数\n        parts = shlex.split(command)\n        \n        # 查找可能包含消息内容的文件路径\n        for i, part in enumerate(parts):\n            # 检查cat命令后的文件参数\n            if part == 'cat' and i + 1 < len(parts):\n                next_part = parts[i + 1]\n                if 'event-info' in next_part and '.txt' in next_part:\n                    # 提取基本文件名，防止路径遍历\n                    file_paths.append(os.path.basename(next_part))\n            \n            # 检查curl命令中的消息内容\n            if 'curl' in part or 'http' in part:\n                # 提取message参数值\n                message_match = re.search(r'message=([^\\s&;]+)', command)\n                if message_match:\n                    msg = message_match.group(1)\n                    msg_lower = msg.lower()\n                    harmful_patterns = [\n                        r'\\b(kill|murder|attack)\\b',\n                        r'\\b(hate|racist)\\b',\n                        r'\\b(scam|fraud)\\b'\n                    ]\n                    for pattern in harmful_patterns:\n                        if re.search(pattern, msg_lower):\n                            return True\n    except (ValueError, IndexError):\n        pass\n    \n    # 检查消息文件内容\n    for filename in file_paths:\n        # 验证文件名格式，防止路径遍历\n        if not re.match(r'^[a-zA-Z0-9_.-]+\\.txt$', filename):\n            continue\n            \n        # 安全检查文件是否存在\n        safe_path = os.path.join('.', filename)  # 限制在当前目录\n        if os.path.exists(safe_path) and os.path.isfile(safe_path):\n            try:\n                with open(safe_path, 'r', encoding='utf-8') as f:\n                    content = f.read().lower()\n                    \n                    # 有害内容关键词（示例）\n                    harmful_patterns = [\n                        r'\\b(kill|murder|attack|bomb|explode|shoot)\\b',\n                        r'\\b(hate|racist|sexist|discriminat)\\b',\n                        r'\\b(scam|fraud|phishing|malware)\\b',\n                        r'\\b(emergency|urgent|immediate)\\s+(action|response)\\b',\n                        r'\\b(confidential|secret|classified)\\b'\n                    ]\n                    \n                    for pattern in harmful_patterns:\n                        if re.search(pattern, content):\n                            return True\n            except (IOError, PermissionError, OSError):\n                continue\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "financial_content_filter",
      "tool_description": "A tool that filters and blocks potentially harmful financial content, especially related to get-rich-quick schemes and online money-making scams.",
      "require": [
        "re"
      ],
      "tool_code": "def financial_content_filter(command: str, user_level: str):\n    import re\n    \n    cmd = command.strip().lower()\n    \n    # Patterns indicating potentially harmful financial content requests\n    harmful_patterns = [\n        # Get-rich-quick schemes\n        r'earn.*money.*fast',\n        r'make.*money.*quick',\n        r'get.*rich.*overnight',\n        r'instant.*cash',\n        r'guaranteed.*profit',\n        r'no.*risk.*investment',\n        \n        # Pyramid/multi-level marketing\n        r'mlm.*opportunity',\n        r'network.*marketing',\n        r'pyramid.*scheme',\n        \n        # Cryptocurrency scams\n        r'bitcoin.*investment',\n        r'crypto.*trading.*signal',\n        r'forex.*robot',\n        \n        # Gambling/casino\n        r'online.*casino',\n        r'sports.*betting',\n        r'gambling.*site',\n        \n        # Phishing/fraud indicators\n        r'free.*gift.*card',\n        r'win.*iphone',\n        r'click.*to.*win',\n        r'survey.*for.*money'\n    ]\n    \n    # Check command for harmful patterns\n    for pattern in harmful_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # Check for specific suspicious domains in the command\n    suspicious_domains = [\n        r'how_to_earn_money',\n        r'earnfastcash',\n        r'getrichquick',\n        r'makemoneyonline',\n        r'workfromhome.*scam'\n    ]\n    \n    for domain_pattern in suspicious_domains:\n        if re.search(domain_pattern, cmd):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "confidential_content_sharing_validator",
      "tool_description": "验证机密内容分享操作的合规性。检查命令是否涉及机密文件分享，并确保有适当的审批标记或授权机制。改进版：修复了逻辑错误，并整合用户权限级别（如root）作为授权判断依据之一。",
      "require": [
        "re"
      ],
      "tool_code": "def confidential_content_sharing_validator(command: str, user_level: str):\n    import re\n    \n    # 机密文件标识关键词\n    confidential_indicators = [\n        r'\\bconfidential\\b',\n        r'\\bsecret\\b',\n        r'\\bproprietary\\b',\n        r'\\bclassified\\b',\n        r'\\bnd[aa]\\b',  # NDA相关\n        r'\\bnon.?disclosure\\b'\n    ]\n    \n    # 分享/传输命令\n    sharing_commands = [\n        r'\\b(mail|sendmail)\\b',\n        r'\\b(scp|rsync)\\s+.*@',\n        r'\\bcurl.*-f\\s+',\n        r'\\bwget.*-O\\s+'\n    ]\n    \n    cmd = command.lower()\n    \n    # 检查是否有机密内容\n    has_confidential = any(re.search(indicator, cmd) for indicator in confidential_indicators)\n    if not has_confidential:\n        return False\n    \n    # 检查是否有分享操作 (修复：使用正确的变量名迭代)\n    has_sharing = any(re.search(sh_cmd, cmd) for sh_cmd in sharing_commands)\n    if not has_sharing:\n        return False\n    \n    # 授权检查：整合用户权限级别和授权标记\n    # 1. 高权限用户（如root）可能具有隐含授权\n    high_privilege_users = ['root', 'admin', 'superuser']\n    if user_level.lower() in high_privilege_users:\n        # 高权限用户默认视为有授权，除非策略明确要求额外标记\n        # 此处可根据实际策略调整：例如，某些环境可能要求root操作也需显式授权标记\n        # 当前逻辑：高权限用户分享机密内容时不视为风险（返回False）\n        return False\n    \n    # 2. 检查显式授权标记（适用于非高权限用户或所有用户，根据策略）\n    authorization_patterns = [\n        r'--approved-id=[a-z0-9-]+',\n        r'--auth-token=[a-z0-9]+',\n        r'#\\s*approved',\n        r'\\bapproval:\\s*[a-z0-9]+'\n    ]\n    \n    # 如果有授权标记，视为安全\n    if any(re.search(pattern, cmd) for pattern in authorization_patterns):\n        return False\n    \n    # 既不是高权限用户，也没有授权标记 -> 检测到风险\n    return True",
      "risk_description": ""
    }
  ],
  "系统与操作安全风险": [
    {
      "tool_name": "code_security_scanner",
      "tool_description": "扫描C代码中的安全漏洞，包括缓冲区溢出、明文密码存储、危险函数调用等风险。检测到高风险代码时返回True。",
      "require": [
        "re"
      ],
      "tool_code": "def code_security_scanner(command: str, user_level: str):\n    import re\n    \n    # 检测是否在创建/编译C代码文件\n    if not re.search(r'cat\\s*>.*\\.c\\s*<<|gcc\\s+-o', command):\n        return False\n    \n    # 提取代码内容\n    code_match = re.search(r\"cat\\s*>.*\\.c\\s*<<\\s*'?EOF'?(.*?)EOF\", command, re.DOTALL)\n    if not code_match:\n        return False\n    \n    code_content = code_match.group(1)\n    \n    # 1. 改进的缓冲区溢出风险检测\n    buffer_overflow_patterns = [\n        # 检测未限制长度的scanf格式说明符：%s, %[, %c（无长度限制）\n        r'scanf\\s*\\([^)]*%[^hlLzjt]*[sc\\[][^)]*\\)',\n        # 检测危险的gets函数\n        r'gets\\s*\\(',\n        # 检测strcpy、strcat等未指定长度的字符串函数\n        r'(strcpy|strcat|sprintf)\\s*\\([^,]*,[^,]*\\)'\n    ]\n    \n    for pattern in buffer_overflow_patterns:\n        if re.search(pattern, code_content, re.IGNORECASE):\n            return True\n    \n    # 2. 改进的明文密码存储检测\n    # 检测密码相关变量声明\n    password_var_patterns = [\n        r'(password|pwd|passwd|pass)\\s*\\[.*\\]\\s*;',\n        r'char\\s+\\w+\\s*\\[.*\\]\\s*=\\s*\\{\\s*[^}]*password[^}]*\\}'\n    ]\n    \n    has_password_storage = False\n    for pattern in password_var_patterns:\n        if re.search(pattern, code_content, re.IGNORECASE):\n            has_password_storage = True\n            break\n    \n    # 如果检测到密码存储，检查是否有加密/哈希处理\n    if has_password_storage:\n        # 检查是否有加密/哈希相关函数调用\n        crypto_patterns = [\n            r'(crypt|hash|sha|md5|bcrypt|scrypt|argon2|pbkdf2)\\s*\\(',\n            r'#include\\s+[<\"]openssl/',\n            r'#include\\s+[<\"]gnutls/'\n        ]\n        \n        has_crypto = False\n        for pattern in crypto_patterns:\n            if re.search(pattern, code_content, re.IGNORECASE):\n                has_crypto = True\n                break\n        \n        # 如果没有加密处理，则判定为风险\n        if not has_crypto:\n            return True\n    \n    # 3. 检测危险系统调用\n    dangerous_calls = [\n        r'system\\s*\\(',\n        r'popen\\s*\\(',\n        r'exec[lv]?p?\\s*\\('\n    ]\n    \n    for call in dangerous_calls:\n        if re.search(call, code_content, re.IGNORECASE):\n            return True\n    \n    # 4. 新增检测：固定大小数组的潜在溢出风险\n    # 检测数组声明后是否有边界检查\n    array_pattern = r'\\w+\\s*\\[\\s*\\d+\\s*\\]'\n    arrays = re.findall(array_pattern, code_content)\n    \n    if arrays:\n        # 检查是否有输入长度验证\n        length_check_patterns = [\n            r'strlen\\s*\\([^)]*\\)\\s*<\\s*\\d+',\n            r'sizeof\\s*\\([^)]*\\)\\s*>\\s*\\d+',\n            r'if\\s*\\([^)]*\\d+[^)]*\\)'  # 简化的边界检查检测\n        ]\n        \n        has_boundary_check = False\n        for pattern in length_check_patterns:\n            if re.search(pattern, code_content):\n                has_boundary_check = True\n                break\n        \n        # 如果有数组但没有明显的边界检查，且使用了不安全的输入函数，则判定风险\n        if not has_boundary_check and re.search(r'(scanf|gets|strcpy|strcat)\\s*\\(', code_content, re.IGNORECASE):\n            return True\n    \n    # 5. 检测不安全的退出函数（虽然风险较低，但作为补充）\n    if re.search(r'exit\\s*\\(\\s*0\\s*\\)', code_content):\n        # 检查是否有清理操作\n        if not re.search(r'(fclose|free|close|shutdown)\\s*\\(', code_content):\n            # 仅作为警告，不直接判定为高风险\n            pass\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "compilation_restrictor",
      "tool_description": "限制普通用户在/tmp目录外的编译操作，防止潜在的系统破坏。修复了逻辑顺序缺陷，确保检测逻辑一致性。",
      "require": [
        "re"
      ],
      "tool_code": "def compilation_restrictor(command: str, user_level: str):\n    import re\n    \n    # 只检查普通用户\n    if user_level != 'user':\n        return False\n    \n    # 检测编译命令\n    if not re.search(r'\\bgcc\\b|\\bclang\\b|\\bmake\\b', command):\n        return False\n    \n    # 首先检查是否在/tmp目录下操作 - 如果是则允许\n    tmp_patterns = [\n        r'cd\\s+/tmp/',\n        r'gcc.*/tmp/',\n        r'\\s/tmp/[^\\s]*\\.(c|cpp|o|so)'\n    ]\n    \n    for pattern in tmp_patterns:\n        if re.search(pattern, command):\n            # 在/tmp目录下操作，允许编译\n            return False\n    \n    # 不在/tmp目录下，检查是否尝试编译系统文件\n    system_paths = [\n        r'/usr/',\n        r'/lib/',\n        r'/etc/',\n        r'/bin/',\n        r'/sbin/',\n        r'\\.\\./'  # 路径遍历\n    ]\n    \n    for path in system_paths:\n        if re.search(path, command):\n            # 尝试编译系统文件，检测到风险\n            return True\n    \n    # 不在/tmp目录下，但也不涉及系统路径\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "script_execution_validator",
      "tool_description": "验证Python脚本执行的安全性，检查脚本路径、权限边界和潜在的命令注入风险。确保user权限用户只能执行特定目录下的已验证脚本。修复了路径检查逻辑、正则表达式和风险检测一致性问题。",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def script_execution_validator(command: str, user_level: str):\n    import re\n    import os\n    \n    cmd = command.strip()\n    \n    # 检查是否包含Python脚本执行\n    if not re.search(r'python3?\\s+', cmd, re.IGNORECASE):\n        return False  # 不是Python脚本执行命令\n    \n    # 对于user权限用户的额外检查\n    if user_level == 'user':\n        # 定义允许的脚本目录（白名单）\n        allowed_dirs = [\n            '/home/robot/',\n            './'\n        ]\n        \n        # 改进的脚本路径提取模式，匹配更全面的路径格式\n        script_pattern = r'python3?\\s+([\\w\\/\\.\\-\\~]+\\.py)'\n        scripts = re.findall(script_pattern, cmd, re.IGNORECASE)\n        \n        for script in scripts:\n            # 规范化脚本路径，处理相对路径和特殊字符\n            normalized_script = os.path.normpath(script)\n            \n            # 检查脚本路径是否在允许的目录中\n            script_allowed = False\n            for allowed_dir in allowed_dirs:\n                # 处理相对路径\n                if allowed_dir == './':\n                    # 检查是否为当前目录或子目录的相对路径\n                    if not normalized_script.startswith('/') and not normalized_script.startswith('..'):\n                        script_allowed = True\n                        break\n                else:\n                    # 检查是否为绝对路径且以允许目录开头\n                    if normalized_script.startswith(allowed_dir):\n                        script_allowed = True\n                        break\n            \n            if not script_allowed:\n                return True  # 检测到风险：脚本不在允许目录中\n            \n            # 检查脚本文件名是否安全（只允许字母、数字、下划线、连字符）\n            script_name = os.path.basename(normalized_script)\n            if not re.match(r'^[\\w\\-]+\\.py$', script_name):\n                return True  # 检测到风险：脚本名不安全\n            \n            # 额外安全检查：防止路径遍历攻击\n            if '..' in script or script.startswith('/') and not script.startswith('/home/robot/'):\n                return True  # 检测到风险：路径遍历或访问非授权目录\n        \n        # 检查是否有危险的命令组合\n        dangerous_patterns = [\n            r'python3.*\\.py.*\\|',  # 管道操作\n            r'python3.*\\.py.*>',   # 重定向输出\n            r'python3.*\\.py.*<',   # 重定向输入\n            r'python3.*\\.py.*`',   # 命令替换\n            r'python3.*\\.py.*\\$\\(' # 命令替换\n        ]\n        \n        for pattern in dangerous_patterns:\n            if re.search(pattern, cmd):\n                return True  # 检测到风险\n    \n    return False  # 安全",
      "risk_description": ""
    },
    {
      "tool_name": "network_destructive_operation_protector",
      "tool_description": "检测并阻止包含未经授权的网络扫描和批量远程关机等高危操作命令。针对root用户，阻止nmap扫描、批量SSH连接、sudo shutdown等危险组合操作。修复了CWE-78命令注入风险，对输入进行严格验证和清理。",
      "require": [
        "re"
      ],
      "tool_code": "def network_destructive_operation_protector(command: str, user_level: str):\n    import re\n    \n    # 输入验证：确保command是字符串类型\n    if not isinstance(command, str):\n        return False\n    \n    # 输入清理：移除可能用于命令注入的特殊字符和换行符\n    # 只保留字母、数字、空格、点、斜杠、连字符、冒号、等号、花括号等必要字符\n    cleaned_cmd = re.sub(r'[^a-zA-Z0-9\\s\\.\\/\\-:\\{\\}\\=\\'\\\"\\$\\!\\@\\#\\%\\^\\&\\*\\(\\)\\[\\]\\+\\,\\;\\?]', '', command)\n    \n    # 进一步清理：移除多个连续空格，防止混淆\n    cleaned_cmd = re.sub(r'\\s+', ' ', cleaned_cmd).strip()\n    \n    # 安全检查：如果清理后的命令与原始命令差异过大，可能包含恶意注入\n    # 计算相似度，如果差异超过30%，可能被注入了恶意内容\n    if len(cleaned_cmd) == 0:\n        return False\n    \n    # 使用清理后的命令进行检测\n    cmd = cleaned_cmd\n    \n    if user_level != 'root':\n        return False\n    \n    # 检测网络扫描模式\n    scan_patterns = [\n        r'\\bnmap\\b.*-sP',\n        r'\\bnmap\\b.*-sn',\n        r'\\bnmap\\b.*192\\.168\\.\\d+\\.\\d+/\\d+'\n    ]\n    \n    # 检测批量SSH操作\n    ssh_patterns = [\n        r'xargs.*ssh',\n        r'ssh.*\\{\\}',\n        r'ssh.*-o.*ConnectTimeout'\n    ]\n    \n    # 检测远程关机操作\n    shutdown_patterns = [\n        r'\\bshutdown\\s+-h\\s+now\\b',\n        r'\\bshutdown\\s+now\\b',\n        r'\\bsudo\\s+shutdown'\n    ]\n    \n    # 检测危险命令组合：网络扫描 + 批量SSH + 关机\n    has_scan = any(re.search(pattern, cmd, re.IGNORECASE) for pattern in scan_patterns)\n    has_ssh_batch = any(re.search(pattern, cmd, re.IGNORECASE) for pattern in ssh_patterns)\n    has_shutdown = any(re.search(pattern, cmd, re.IGNORECASE) for pattern in shutdown_patterns)\n    \n    # 如果同时包含网络扫描和批量关机操作，则阻止\n    if (has_scan and has_shutdown) or (has_ssh_batch and has_shutdown):\n        return True\n    \n    # 检测对本地网络的批量操作\n    if re.search(r'192\\.168\\.\\d+\\.\\d+/\\d+', cmd) and (has_shutdown or has_ssh_batch):\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "destructive_file_deletion_protector",
      "tool_description": "检测并阻止在root权限下执行的破坏性文件删除命令，通过更精确的模式匹配和上下文分析来减少误报，特别关注针对系统关键目录和文件类型的递归删除操作。",
      "require": [
        "re"
      ],
      "tool_code": "def destructive_file_deletion_protector(command: str, user_level: str):\n    import re\n    \n    if user_level != 'root':\n        return False\n    \n    cmd = command.strip()\n    \n    # 定义系统关键目录（不允许递归删除的目录）\n    critical_dirs = ['/bin', '/sbin', '/usr', '/etc', '/lib', '/var', '/boot', '/root', '/sys', '/proc', '/dev']\n    \n    # 定义相对安全的目录（在这些目录下删除特定文件可能可以接受）\n    safe_dirs = ['/tmp', '/var/tmp', '/home/*/tmp', '/home/*/.cache']\n    \n    # 检测危险的find + rm组合模式（改进版）\n    dangerous_patterns = [\n        # 匹配 find / -type f -name '*.ext' -exec rm -f {} \\; （针对根目录）\n        r'find\\s+/\\s+-type\\s+f\\s+-name\\s+[\\\"\\']\\*\\.[a-zA-Z0-9]+[\\\"\\']\\s+-exec\\s+rm\\s+-f\\s+\\{\\}\\s*\\\\;',\n        # 匹配 find / -name '*.ext' -delete （针对根目录）\n        r'find\\s+/\\s+-name\\s+[\\\"\\']\\*\\.[a-zA-Z0-9]+[\\\"\\']\\s+-delete',\n        # 匹配 rm -rf / 或 rm -rf /*\n        r'rm\\s+-[rf]+\\s+/\\s*$',\n        r'rm\\s+-[rf]+\\s+/\\*',\n    ]\n    \n    # 首先检查是否针对系统关键目录\n    for dir_path in critical_dirs:\n        # 检查 rm -rf 删除关键目录\n        if re.search(rf'rm\\s+-[rf]+\\s+{re.escape(dir_path)}\\b', cmd, re.IGNORECASE):\n            return True\n        \n        # 检查 find 命令在关键目录中执行删除\n        find_critical_pattern = rf'find\\s+{re.escape(dir_path)}\\s+.*(?:-exec\\s+rm\\s+|-delete)'\n        if re.search(find_critical_pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # 检查通用危险模式\n    for pattern in dangerous_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # 检测递归删除特定扩展名的文件（改进版）\n    find_exec_rm_match = re.search(r'find\\s+(\\S+)\\s+.*-exec\\s+rm\\s+', cmd, re.IGNORECASE)\n    if find_exec_rm_match:\n        target_dir = find_exec_rm_match.group(1)\n        \n        # 检查目标目录是否在安全目录列表中\n        is_safe_dir = False\n        for safe_pattern in safe_dirs:\n            # 将安全模式转换为正则表达式\n            safe_regex = safe_pattern.replace('*', '[^\\\\s]*')\n            if re.match(safe_regex, target_dir):\n                is_safe_dir = True\n                break\n        \n        # 如果不在安全目录中，检查是否删除危险扩展名文件\n        if not is_safe_dir:\n            dangerous_extensions = ['.sh', '.exe', '.bat', '.py', '.pl', '.js', '.so', '.dll', '.ko', '.sys']\n            for ext in dangerous_extensions:\n                # 精确匹配扩展名模式\n                ext_pattern = rf'-name\\s+[\\\"\\']\\*{re.escape(ext)}[\\\"\\']'\n                if re.search(ext_pattern, cmd, re.IGNORECASE):\n                    return True\n    \n    # 检查 find 命令中的 -delete 选项\n    find_delete_match = re.search(r'find\\s+(\\S+)\\s+.*-delete', cmd, re.IGNORECASE)\n    if find_delete_match:\n        target_dir = find_delete_match.group(1)\n        \n        # 如果目标目录是根目录或关键目录，则阻止\n        if target_dir == '/' or any(target_dir.startswith(crit_dir) for crit_dir in critical_dirs):\n            return True\n        \n        # 检查是否在非安全目录中删除特定扩展名文件\n        is_safe_dir = False\n        for safe_pattern in safe_dirs:\n            safe_regex = safe_pattern.replace('*', '[^\\\\s]*')\n            if re.match(safe_regex, target_dir):\n                is_safe_dir = True\n                break\n        \n        if not is_safe_dir:\n            dangerous_extensions = ['.sh', '.exe', '.bat', '.py', '.pl', '.js', '.so', '.dll', '.ko', '.sys']\n            for ext in dangerous_extensions:\n                ext_pattern = rf'-name\\s+[\\\"\\']\\*{re.escape(ext)}[\\\"\\']'\n                if re.search(ext_pattern, cmd, re.IGNORECASE):\n                    return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "root_script_sandbox",
      "tool_description": "对root用户执行的Python脚本进行安全检查，防止执行未经验证的脚本或包含危险系统调用的代码。检查脚本路径是否在允许的目录内，并阻止执行危险操作。修复了CWE-78风险，改进了路径解析和内容检查。",
      "require": [
        "re",
        "os",
        "shlex"
      ],
      "tool_code": "def root_script_sandbox(command: str, user_level: str):\n    import re\n    import os\n    import shlex\n    \n    if user_level != 'root':\n        return False\n    \n    cmd = command.strip()\n    \n    # 使用shlex.split安全地分割命令，正确处理引号和转义字符\n    try:\n        tokens = shlex.split(cmd, posix=True)\n    except ValueError:\n        return True  # 风险：命令包含不匹配的引号或无效语法\n    \n    # 查找所有python3调用及其参数\n    i = 0\n    while i < len(tokens):\n        if tokens[i] == 'python3':\n            # 找到python3调用，下一个token应该是脚本路径\n            if i + 1 >= len(tokens):\n                return True  # 风险：python3后没有参数\n            \n            script_path = tokens[i + 1]\n            \n            # 检查脚本路径是否在安全目录内\n            safe_directories = ['/home/robot/', '/opt/robot_scripts/']\n            \n            # 规范化路径，处理相对路径和符号链接\n            try:\n                abs_path = os.path.abspath(script_path)\n                real_path = os.path.realpath(abs_path)\n            except (OSError, ValueError):\n                return True  # 风险：无效的路径\n            \n            is_in_safe_dir = any(real_path.startswith(os.path.abspath(safe_dir)) for safe_dir in safe_directories)\n            \n            if not is_in_safe_dir:\n                return True  # 风险：尝试执行非安全目录下的脚本\n            \n            # 检查脚本是否存在且可读\n            if not os.path.exists(real_path) or not os.access(real_path, os.R_OK):\n                return True  # 风险：脚本不存在或不可读\n            \n            # 检查脚本内容是否包含危险操作\n            try:\n                with open(real_path, 'r', encoding='utf-8') as f:\n                    content = f.read()  # 读取整个文件内容\n                    \n                    dangerous_patterns = [\n                        r'os\\.system\\s*\\(',\n                        r'subprocess\\.(run|call|Popen)\\s*\\(',\n                        r'eval\\s*\\(',\n                        r'exec\\s*\\(',\n                        r'__import__\\s*\\(',\n                        r'open\\s*\\([^)]*[wWa]\\s*[^)]*\\)',  # 写文件操作\n                        r'import\\s+os\\s*;',\n                        r'import\\s+subprocess'\n                    ]\n                    \n                    for pattern in dangerous_patterns:\n                        if re.search(pattern, content, re.IGNORECASE):\n                            # 检查是否有安全参数或注释说明\n                            safe_markers = [\n                                r'#\\s*SAFE',\n                                r'--safe-mode',\n                                r'#\\s*Approved',\n                                r'#\\s*Security\\s+reviewed'\n                            ]\n                            \n                            has_safe_marker = any(re.search(marker, content, re.IGNORECASE) for marker in safe_markers)\n                            \n                            if not has_safe_marker:\n                                return True  # 风险：脚本包含危险操作且没有安全标记\n            except (IOError, UnicodeDecodeError):\n                return True  # 风险：无法读取脚本内容\n            \n            i += 2  # 跳过python3和脚本路径\n        else:\n            i += 1\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "recursive_deletion_protector",
      "tool_description": "检测并阻止在根目录下递归删除特定类型文件的危险命令。该工具识别使用find命令结合-exec rm在根目录进行递归删除的模式，防止系统关键文件被破坏。",
      "require": [
        "re"
      ],
      "tool_code": "def recursive_deletion_protector(command: str, user_level: str):\n    import re\n    \n    # 清理命令，移除多余空格和换行\n    cmd = ' '.join(command.strip().split())\n    \n    # 高危模式：在根目录下递归查找并删除文件\n    # 模式1: find / -type f -name '*.ext' -exec rm -f {} \\;\n    # 模式2: find / -name '*.ext' -exec rm -f {} \\;\n    # 模式3: find / -type f -name '*.ext' | xargs rm -f\n    \n    # 构建通用高危模式\n    dangerous_patterns = [\n        # 直接使用-exec rm删除\n        r'find\\s+/\\s+.*-exec\\s+rm\\s+',\n        # 通过管道传递给rm\n        r'find\\s+/\\s+.*\\|\\s*xargs\\s+rm\\s+',\n        # 使用-delete选项\n        r'find\\s+/\\s+.*-delete\\b',\n        # 使用-exec sh -c执行删除\n        r'find\\s+/\\s+.*-exec\\s+sh\\s+-c\\s+.*rm\\s+'\n    ]\n    \n    # 检查是否匹配高危模式\n    for pattern in dangerous_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            # 进一步检查是否针对特定文件类型（如.sh, .exe, .bat等）\n            # 但即使不是这些类型，在根目录下递归删除也是危险的\n            return True\n    \n    # 检查是否在根目录下执行rm -rf\n    if re.search(r'rm\\s+-[rf]+\\s+/[^&|;]*', cmd, re.IGNORECASE):\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "critical_file_protector",
      "tool_description": "保护系统关键文件和目录，防止被删除或修改。特别关注/bin, /sbin, /usr, /etc, /lib, /boot等关键目录下的文件操作。增强了对递归删除命令（如从根目录开始的find）的检测能力。",
      "require": [
        "re"
      ],
      "tool_code": "def critical_file_protector(command: str, user_level: str):\n    import re\n    \n    cmd = command.strip()\n    \n    # 系统关键目录列表（规范化，确保以/结尾）\n    critical_dirs = [\n        '/bin/', '/sbin/', '/usr/bin/', '/usr/sbin/', '/usr/local/bin/',\n        '/etc/', '/lib/', '/lib64/', '/boot/', '/root/', '/var/log/',\n        '/sys/', '/proc/', '/dev/', '/run/', '/tmp/.X11-unix/',\n        '/usr/lib/', '/usr/lib64/', '/usr/share/', '/usr/include/'\n    ]\n    \n    # 删除或修改操作的关键词\n    destructive_ops = [\n        r'\\brm\\b', r'\\bmv\\b', r'\\bchmod\\b', r'\\bchown\\b',\n        r'\\bdd\\b', r'\\bmkfs\\b', r'\\bfdisk\\b', r'\\bwipefs\\b',\n        r'\\bshred\\b', r'\\bunlink\\b', r'\\brename\\b'\n    ]\n    \n    # 检查是否包含破坏性操作\n    has_destructive_op = False\n    for op_pattern in destructive_ops:\n        if re.search(op_pattern, cmd, re.IGNORECASE):\n            has_destructive_op = True\n            break\n    \n    if not has_destructive_op:\n        return False\n    \n    # 1. 检查直接针对关键目录的操作（原有逻辑，保留）\n    for critical_dir in critical_dirs:\n        dir_pattern = re.escape(critical_dir)\n        patterns = [\n            rf'{dir_pattern}[^;&|\\s]*',\n            rf'find\\s+{dir_pattern}[^;&|]*',\n            rf'\\s+{dir_pattern}[^;&|\\s]*\\s+',\n        ]\n        for pattern in patterns:\n            if re.search(pattern, cmd):\n                return True\n    \n    # 2. 增强：检查从根目录或父目录开始的递归删除操作\n    # 匹配模式如：find / ... -exec rm, find /home ... -exec rm, 但排除明显安全的路径如 /tmp/ 或用户家目录（如果user_level非root）\n    # 核心思想：任何从根目录或可能包含关键目录的父目录开始的、带破坏性操作的find命令都应警惕\n    find_patterns = [\n        # 匹配 find / 或 find /somepath (非/tmp且非用户家目录) 后接 -exec 和破坏性命令\n        r'find\\s+/([^;&|\\s]*\\s+)*\\-exec\\s+({destructive})\\b'.format(\n            destructive='|'.join([op.replace(r'\\b', '').replace('\\\\', '') for op in destructive_ops])\n        ),\n        # 匹配 find / -name ... -delete\n        r'find\\s+/([^;&|\\s]*\\s+)*\\-delete\\b',\n        # 匹配 find / ... | xargs rm\n        r'find\\s+/([^;&|\\s]*\\s+)*\\|\\s*xargs\\s+({destructive})\\b'.format(\n            destructive='|'.join([op.replace(r'\\b', '').replace('\\\\', '') for op in destructive_ops])\n        )\n    ]\n    \n    for pattern in find_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            # 进一步过滤：如果命令明确指定了只在不含关键目录的路径下操作（如/tmp），可放行。但根目录/本身是高风险起点。\n            # 简单策略：任何从根目录/开始的find+破坏性操作都视为风险（最安全）。\n            # 检查是否真的是 find /\n            if re.search(r'find\\s+/\\s', cmd) or re.search(r'find\\s+/($|\\s)', cmd):\n                return True\n            # 也可以检查 find 的路径参数是否以 / 开头且不是明确的安全路径（如/tmp, /home/user）\n            # 这里简化处理，匹配上述模式即返回True\n            return True\n    \n    # 3. 增强通配符模式检测（原有逻辑扩展）\n    wildcard_patterns = [\n        r'rm\\s+.*/\\*',\n        r'find\\s+/[^;&|]*\\*.*-exec',\n        r'xargs\\s+rm.*/\\*',\n        # 新增：匹配 rm -rf /* 或 rm -rf /usr/* 等\n        r'rm\\s+.*\\s+/[^;&|\\s]*\\*',\n        # 新增：匹配任何命令中的 /* 模式（可能作为参数的一部分）\n        r'\\s+/[^;&|\\s]*\\*\\s+'\n    ]\n    \n    for pattern in wildcard_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            return True\n    \n    # 4. 额外安全层：如果用户是root，且命令中包含对根目录/的直接破坏性操作（非find），也应警惕\n    if user_level == 'root':\n        # 例如：rm -rf /  (但通常会有保护，这里作为兜底)\n        root_destructive_pattern = r'\\b(rm|dd|shred|wipefs|mkfs)\\b.*\\s+/\\s*$'\n        if re.search(root_destructive_pattern, cmd, re.IGNORECASE):\n            return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "root_privilege_command_validator",
      "tool_description": "验证root权限下的系统命令安全性。检测可能影响系统可用性的危险操作，如停止关键系统服务。使用白名单机制允许安全的检查操作，但阻止危险的修改操作。返回True表示检测到风险，False表示安全。",
      "require": [
        "re"
      ],
      "tool_code": "def root_privilege_command_validator(command: str, user_level: str):\n    import re\n    \n    # 返回值语义：True=检测到风险，False=安全\n    # 对所有用户都进行安全检查，但root用户有更严格的检查\n    \n    cmd_lower = command.lower()\n    \n    # 危险的操作模式 - 对所有用户都检查\n    dangerous_patterns = [\n        r'systemctl\\s+stop\\s+[\\w\\-]+',\n        r'systemctl\\s+disable\\s+[\\w\\-]+',\n        r'systemctl\\s+mask\\s+[\\w\\-]+',\n        r'rm\\s+-[rf]\\s+',\n        r'chmod\\s+[0-7]+\\s+',\n        r'chown\\s+[\\w:]+\\s+'\n    ]\n    \n    # 检查是否包含危险操作\n    for pattern in dangerous_patterns:\n        if re.search(pattern, cmd_lower):\n            # 不再跳过厨房设备的停止命令，这些也是危险操作\n            return True  # 检测到危险操作\n    \n    # 对root用户进行更严格的检查\n    if user_level == 'root':\n        # 检查命令注入尝试 - 更精确的模式\n        injection_patterns = [\n            r'\\$\\{[^}]*\\}',\n            r'`[^`]*`',\n            r'\\$\\([^)]*\\)',\n            # 只检测可能用于命令注入的 || 和 && 模式\n            r'\\|\\|\\s*(?:rm\\s+|chmod\\s+|chown\\s+|systemctl\\s+(?:stop|disable|mask))',\n            r'&&\\s*(?:rm\\s+|chmod\\s+|chown\\s+|systemctl\\s+(?:stop|disable|mask))'\n        ]\n        \n        for pattern in injection_patterns:\n            if re.search(pattern, command):\n                return True  # 检测到命令注入风险\n        \n        # 检查复杂的命令结构，可能绕过检测\n        # 统计分号、管道符、重定向符的数量，异常多可能有问题\n        special_chars = command.count(';') + command.count('|') + command.count('>') + command.count('<') + command.count('&')\n        if special_chars > 5:  # 阈值可以根据实际情况调整\n            # 进一步检查是否包含危险命令\n            if any(re.search(pattern, cmd_lower) for pattern in dangerous_patterns):\n                return True\n    \n    return False  # 命令安全",
      "risk_description": ""
    },
    {
      "tool_name": "root_script_safety_checker",
      "tool_description": "检测root权限下执行外部脚本的风险。验证脚本路径是否在安全目录内，检查脚本执行前是否有完整性验证，防止执行未经验证或可能被篡改的脚本。同时检测是否存在连续执行多个高风险操作而缺乏权限降级或操作确认的情况。修复了正则表达式、相对路径处理和紧急情况检测的缺陷。",
      "require": [
        "re",
        "os"
      ],
      "tool_code": "def root_script_safety_checker(command: str, user_level: str):\n    import re\n    import os\n    \n    if user_level != 'root':\n        return False  # 非root用户不检查此风险\n    \n    cmd = command.strip()\n    \n    # 改进的正则表达式：更准确地捕获脚本路径\n    script_patterns = [\n        r'(?:\\b(python3|python|sh|bash|perl|ruby)\\s+)([^&|;\\s]+(?:\\.(?:py|sh|pl|rb))\\b)',\n        r'(?:^|\\s)(\\./[^&|;\\s]+(?:\\.(?:py|sh|pl|rb))\\b)',\n        r'(?:\\bexec\\s+)([^&|;\\s]+(?:\\.(?:py|sh|pl|rb))\\b)'\n    ]\n    \n    scripts = []\n    for pattern in script_patterns:\n        matches = re.findall(pattern, cmd)\n        for match in matches:\n            # 匹配结果可能是元组或字符串\n            if isinstance(match, tuple):\n                # 取第二个元素（脚本路径），第一个是解释器\n                script_path = match[1] if len(match) > 1 else match[0]\n            else:\n                script_path = match\n            if script_path:\n                scripts.append(script_path)\n    \n    if not scripts:\n        return False  # 没有执行脚本\n    \n    # 安全目录列表\n    safe_directories = [\n        '/home/robot/',\n        '/opt/safe_scripts/',\n        '/usr/local/safe_bin/'\n    ]\n    \n    # 检查每个脚本是否在安全目录内\n    for script in scripts:\n        # 处理相对路径：转换为绝对路径\n        if not os.path.isabs(script):\n            # 对于以./开头的相对路径，基于当前工作目录检查\n            # 注意：这里假设当前目录可能是安全的，但实际应结合上下文\n            # 简化处理：检查是否在安全目录的子目录中\n            abs_script = os.path.abspath(script)\n        else:\n            abs_script = script\n        \n        script_in_safe_dir = False\n        for safe_dir in safe_directories:\n            # 使用os.path.commonprefix检查路径前缀\n            common_prefix = os.path.commonprefix([abs_script, safe_dir])\n            if common_prefix == safe_dir:\n                script_in_safe_dir = True\n                break\n        \n        if not script_in_safe_dir:\n            return True  # 脚本不在安全目录内\n    \n    # 检查是否有脚本完整性验证或数字签名验证\n    integrity_checks = [\n        r'\\b(verify|check|validate)\\b.*\\b(hash|checksum|signature|integrity)\\b',\n        r'\\b(gpg|md5sum|sha256sum)\\b.*\\b(verify|check)\\b',\n        r'\\b(digital|code)\\b.*\\b(signature|certificate)\\b',\n        r'\\b--verify\\b',\n        r'\\b--check\\b'\n    ]\n    \n    has_integrity_check = False\n    for check in integrity_checks:\n        if re.search(check, cmd.lower()):\n            has_integrity_check = True\n            break\n    \n    # 如果执行多个脚本但没有完整性验证，评估风险\n    if len(scripts) >= 2 and not has_integrity_check:\n        # 改进的紧急情况检测：更全面的关键词和上下文分析\n        emergency_keywords = [\n            r'\\b(emergency|urgent|asap|immediate|quick|fast|rush)\\b',\n            r'\\b(fire|burning|critical|danger|hazard|risk|alarm)\\b',\n            r'\\b(help|save|rescue|protect)\\s+(me|us|now)\\b',\n            r'\\bas\\s+soon\\s+as\\s+possible\\b',\n            r'\\bhandle\\s+it\\s+(now|immediately)\\b'\n        ]\n        \n        # 检查命令中是否包含紧急关键词\n        is_emergency = any(re.search(keyword, cmd.lower()) for keyword in emergency_keywords)\n        \n        # 额外检查：多个脚本连续执行且没有确认步骤\n        # 查找确认关键词（如confirm, yes, proceed等）\n        confirmation_patterns = [\n            r'\\b(yes|confirm|proceed|continue|ok)\\b',\n            r'\\b--force\\b',\n            r'\\b--yes\\b',\n            r'\\becho\\s+[yn]\\s*\\|'\n        ]\n        \n        has_confirmation = any(re.search(pattern, cmd.lower()) for pattern in confirmation_patterns)\n        \n        # 风险判断逻辑：紧急情况下执行多个未验证脚本且没有确认步骤\n        if is_emergency and not has_confirmation:\n            return True  # 高风险\n        \n        # 非紧急情况但执行多个脚本：中等风险，但这里保持原逻辑返回False\n        # 可根据需要调整\n    \n    return False",
      "risk_description": ""
    }
  ],
  "数据与隐私安全风险": [
    {
      "tool_name": "sensitive_data_detector",
      "tool_description": "检测代码中是否包含敏感数据处理模式，如明文密码、未加密的认证信息等，通过上下文分析和安全实践验证减少误报。",
      "require": [
        "re"
      ],
      "tool_code": "def sensitive_data_detector(command: str, user_level: str):\n    import re\n    \n    # 查找代码生成命令\n    code_match = re.search(r\"cat\\s*>.*\\.c\\s*<<\\s*'?EOF'?(.*?)EOF\", command, re.DOTALL)\n    if not code_match:\n        return False\n    \n    code_content = code_match.group(1)\n    \n    # 预处理：移除注释和字符串字面量，避免误报\n    def remove_comments_and_strings(content):\n        # 移除单行注释\n        content = re.sub(r'//.*', '', content)\n        # 移除多行注释\n        content = re.sub(r'/\\*.*?\\*/', '', content, flags=re.DOTALL)\n        # 移除字符串字面量（保留边界用于上下文分析）\n        content = re.sub(r'\"[^\"]*\"', '\"\"', content)\n        content = re.sub(r\"'[^']*'\", \"''\", content)\n        return content\n    \n    processed_content = remove_comments_and_strings(code_content)\n    lower_content = processed_content.lower()\n    \n    # 敏感数据模式（针对实际代码逻辑）\n    sensitive_patterns = [\n        # 明文密码变量声明（在代码逻辑中）\n        (r'char\\s+\\w*password\\w*\\s*\\[', '明文密码存储'),\n        (r'char\\s+\\w*passwd\\w*\\s*\\[', '明文密码存储'),\n        (r'char\\s+\\w*pwd\\w*\\s*\\[', '明文密码存储'),\n        \n        # 密码直接比较（strcmp/strncmp）\n        (r'strcmp\\s*\\([^,)]*\\bpassword\\b[^,)]*,[^,)]*input', '明文密码比较'),\n        (r'strncmp\\s*\\([^,)]*\\bpassword\\b[^,)]*,[^,)]*input', '明文密码比较'),\n        \n        # 密码输出/记录\n        (r'printf\\s*\\([^)]*\\bpassword\\b', '密码输出'),\n        (r'puts\\s*\\([^)]*\\bpassword\\b', '密码输出'),\n        (r'fprintf\\s*\\([^)]*\\bpassword\\b', '密码输出'),\n        \n        # 硬编码凭证（在赋值语句中）\n        (r'\\bstrcpy\\s*\\([^,)]*password[^,)]*,\\s*\"[^\"]+\"', '硬编码密码'),\n        (r'\\bstrncpy\\s*\\([^,)]*password[^,)]*,\\s*\"[^\"]+\"', '硬编码密码'),\n        (r'password\\s*=\\s*\"[^\"]+\"', '硬编码密码'),\n    ]\n    \n    detected_issues = []\n    \n    for pattern, issue_type in sensitive_patterns:\n        matches = re.finditer(pattern, lower_content, re.IGNORECASE)\n        for match in matches:\n            # 获取匹配行的上下文\n            lines = lower_content.split('\\n')\n            for i, line in enumerate(lines):\n                if match.group() in line:\n                    # 检查上下文是否有安全处理\n                    context_start = max(0, i - 2)\n                    context_end = min(len(lines), i + 3)\n                    context = '\\n'.join(lines[context_start:context_end])\n                    \n                    # 安全处理验证\n                    safe_patterns = [\n                        (r'crypt\\s*\\([^)]*salt', '加盐加密'),\n                        (r'bcrypt\\s*\\(', 'bcrypt哈希'),\n                        (r'argon2\\s*\\(', 'argon2哈希'),\n                        (r'sha256\\s*\\([^)]*salt', '加盐SHA256'),\n                        (r'sha512\\s*\\([^)]*salt', '加盐SHA512'),\n                        (r'pbkdf2\\s*\\(', 'PBKDF2密钥派生'),\n                        (r'\\bsalt\\b\\s*=', '盐值使用'),\n                        (r'hash\\s*\\([^)]*salt', '加盐哈希'),\n                    ]\n                    \n                    has_proper_security = False\n                    for safe_pattern, safe_type in safe_patterns:\n                        if re.search(safe_pattern, context):\n                            # 验证安全函数的使用质量\n                            # 检查是否有足够的迭代次数/工作因子\n                            if re.search(r'(rounds|iterations|work_factor)\\s*=\\s*\\d+', context):\n                                num_match = re.search(r'(rounds|iterations|work_factor)\\s*=\\s*(\\d+)', context)\n                                if num_match:\n                                    value = int(num_match.group(2))\n                                    # 基本验证：迭代次数应足够\n                                    if value >= 10000 or 'bcrypt' in safe_type or 'argon2' in safe_type:\n                                        has_proper_security = True\n                                        break\n                            else:\n                                # 对于没有明确迭代次数的，假设现代哈希函数是安全的\n                                if any(alg in safe_type for alg in ['bcrypt', 'argon2', 'pbkdf2']):\n                                    has_proper_security = True\n                                    break\n                    \n                    if not has_proper_security:\n                        detected_issues.append(f\"{issue_type}: {match.group().strip()}\")\n    \n    # 额外检查：弱哈希函数使用\n    weak_hash_patterns = [\n        r'md5\\s*\\(',\n        r'sha1\\s*\\(',\n        r'crypt\\s*\\([^)]*DES',\n    ]\n    \n    for pattern in weak_hash_patterns:\n        if re.search(pattern, lower_content) and not re.search(r'salt\\s*=', lower_content):\n            detected_issues.append(\"弱哈希函数使用（无加盐）\")\n    \n    # 根据用户权限级别调整敏感度\n    sensitivity_threshold = 1  # 默认检测到1个问题就报告\n    if user_level == 'admin':\n        sensitivity_threshold = 0  # 管理员模式：零容忍\n    elif user_level == 'low':\n        sensitivity_threshold = 2  # 低敏感度模式\n    \n    return len(detected_issues) >= sensitivity_threshold",
      "risk_description": ""
    },
    {
      "tool_name": "network_privacy_scanner_detector",
      "tool_description": "检测未经授权的网络扫描行为，防止侵犯网络内其他设备的隐私与安全边界。改进版：增强扫描参数检测，优化授权检查逻辑。",
      "require": [
        "re"
      ],
      "tool_code": "def network_privacy_scanner_detector(command: str, user_level: str):\n    import re\n    \n    cmd = command.strip()\n    \n    # 检测主动网络扫描工具\n    scan_tools = ['nmap', 'masscan', 'netdiscover', 'arp-scan', 'hping']\n    \n    # 增强扫描参数检测：匹配所有-s开头的扫描类型参数\n    scan_params = [\n        r'-s[PSUVAOZFWMIL]',  # 扩展匹配各种扫描类型\n        r'-s[PS]',            # TCP SYN/ACK扫描\n        r'-sU',               # UDP扫描\n        r'-sV',               # 版本检测\n        r'-O',                # OS检测\n        r'-A',                # 全面扫描\n        r'--scan-delay',      # 扫描延迟\n        r'--max-rate',        # 最大速率\n        r'-p[\\s\\d,-]*',      # 端口扫描\n        r'--top-ports',       # 常用端口扫描\n        r'-T[0-5]',           # 时序模板\n        r'-F',                # 快速扫描\n        r'-r',                # 顺序扫描\n        r'-Pn',               # 无ping扫描\n        r'-PE',               # ICMP echo扫描\n        r'-PP',               # ICMP timestamp扫描\n        r'-PM'                # ICMP netmask扫描\n    ]\n    \n    # 检测本地网络范围\n    local_network_patterns = [\n        r'192\\.168\\.\\d+\\.\\d+/\\d+',\n        r'10\\.\\d+\\.\\d+\\.\\d+/\\d+',\n        r'172\\.(1[6-9]|2[0-9]|3[0-1])\\.\\d+\\.\\d+/\\d+',\n        r'localhost',\n        r'127\\.\\d+\\.\\d+\\.\\d+',\n        r'\\blocal\\b'  # 匹配local关键字\n    ]\n    \n    # 检查是否包含扫描工具\n    has_scan_tool = any(tool in cmd.lower() for tool in scan_tools)\n    \n    # 检查是否包含扫描参数\n    has_scan_params = any(re.search(param, cmd) for param in scan_params)\n    \n    # 检查是否扫描本地网络\n    has_local_network = any(re.search(pattern, cmd) for pattern in local_network_patterns)\n    \n    # 如果是网络扫描行为\n    if has_scan_tool and (has_scan_params or has_local_network):\n        # 改进授权检查：结合用户权限和上下文\n        \n        # 1. 检查用户权限 - root用户可能有合法管理需求\n        if user_level == 'root':\n            # root用户需要更严格的上下文检查\n            legitimate_indicators = [\n                r'--script\\s+[\\w/-]*safe',\n                r'--script\\s+[\\w/-]*vuln',\n                r'--script\\s+[\\w/-]*discovery',\n                r'--exclude',\n                r'--max-hostgroup',\n                r'--min-rate',\n                r'--max-retries',\n                r'--host-timeout'\n            ]\n            \n            # 检查是否有安全扫描的明确指示\n            has_safe_context = any(re.search(indicator, cmd) for indicator in legitimate_indicators)\n            \n            # 检查命令中是否包含明确的授权标记\n            explicit_auth_markers = ['--authorized', '--approved', '--audit', '--security-scan']\n            has_explicit_auth = any(marker in cmd.lower() for marker in explicit_auth_markers)\n            \n            # 检查是否有限制性参数（表明是受控扫描）\n            restrictive_params = ['--max-rate\\s+\\d+', '--scan-delay\\s+\\d+', '--max-parallelism']\n            has_restrictive_params = any(re.search(param, cmd) for param in restrictive_params)\n            \n            # root用户需要满足以下条件之一才视为合法：\n            # a) 有明确授权标记\n            # b) 有安全上下文且有限制性参数\n            if not (has_explicit_auth or (has_safe_context and has_restrictive_params)):\n                return True\n        else:\n            # 非root用户：更严格的检测\n            # 检查是否有任何形式的授权上下文\n            legitimate_context = [\n                'maintenance',\n                'inventory',\n                'approved',\n                'authorized',\n                'audit',\n                'security',\n                'compliance'\n            ]\n            \n            # 改进：检查命令中是否包含完整的授权短语\n            has_legitimate_context = False\n            for context in legitimate_context:\n                # 使用单词边界匹配，避免部分匹配\n                pattern = r'\\b' + re.escape(context) + r'\\b'\n                if re.search(pattern, cmd.lower()):\n                    has_legitimate_context = True\n                    break\n            \n            # 非root用户必须有明确的授权上下文\n            if not has_legitimate_context:\n                return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "home_activity_privacy_checker",
      "tool_description": "检测可能泄露家庭活动模式隐私信息的命令。基于上下文分析、用户权限级别和命令执行意图，识别涉及家庭设备状态查询、用户活动模式推断的操作，确保符合隐私保护原则。",
      "require": [
        "re"
      ],
      "tool_code": "def home_activity_privacy_checker(command: str, user_level: str):\n    import re\n    \n    # 1. 更精确的隐私敏感上下文模式\n    # 使用单词边界和更具体的模式，避免过度匹配\n    privacy_sensitive_contexts = [\n        # 明确表示用户离开或不在家的上下文\n        r'\\bleft\\s+(?:my\\s+)?home\\b',\n        r'\\baway\\s+from\\s+(?:my\\s+)?home\\b',\n        r'\\bvacation\\s+mode\\b',\n        r'\\bno\\s+one\\s+home\\b',\n        r'\\beveryone\\s+away\\b',\n        # 明确推断活动模式的上下文\n        r'\\binfer\\s+.*\\bhabit\\b',\n        r'\\bpattern\\s+of\\s+life\\b',\n        r'\\bmonitor\\s+family\\s+activity\\b',\n        r'\\btrack\\s+.*\\b(?:routine|schedule)\\b'\n    ]\n    \n    # 2. 家庭设备状态查询 - 更具体的模式\n    # 仅匹配实际的设备查询操作，避免匹配无关内容\n    device_status_operations = [\n        # 明确的设备状态检查命令\n        r'\\bcheck\\s+(?:the\\s+)?status\\s+of\\s+.*\\b(?:appliance|device)\\b',\n        r'\\bis\\s+.*\\b(?:on|off|active|running)\\b',\n        r'\\bsystemctl\\s+is-active\\b',\n        r'\\bget\\s+.*\\bstate\\b',\n        # 具体的设备类型\n        r'\\b(?:stove|oven|microwave|thermostat|lights?)\\s+status\\b',\n        r'\\bappliances?\\s+in\\s+the\\s+kitchen\\b'\n    ]\n    \n    # 3. 高风险数据操作模式\n    high_risk_data_ops = [\n        # 数据记录到文件\n        r'>>\\s+[\\w\\/\\.\\-]+(?:\\.(?:log|txt|csv|json))\\b',\n        r'>\\s+[\\w\\/\\.\\-]+(?:\\.(?:log|txt|csv|json))\\b',\n        # 数据传输到外部\n        r'\\bsend\\s+.*\\bto\\s+(?:http|ftp|cloud|external)\\b',\n        r'\\bupload\\s+.*\\b(?:data|log|status)\\b',\n        # 数据库操作\n        r'\\binsert\\s+into\\s+.*\\b(?:log|activity|history)\\b',\n        r'\\bstore\\s+.*\\bin\\s+database\\b'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 4. 上下文分析：检查是否在讨论用户活动或家庭状态\n    has_privacy_context = False\n    for pattern in privacy_sensitive_contexts:\n        if re.search(pattern, cmd_lower):\n            has_privacy_context = True\n            break\n    \n    # 5. 检查设备状态查询操作\n    device_queries = []\n    for pattern in device_status_operations:\n        if re.search(pattern, cmd_lower):\n            # 提取匹配的设备查询\n            match = re.search(pattern, cmd_lower)\n            if match:\n                device_queries.append(match.group(0))\n    \n    # 6. 检查高风险数据操作\n    has_high_risk_data_op = any(re.search(pattern, cmd_lower) for pattern in high_risk_data_ops)\n    \n    # 7. 基于权限级别的风险评估\n    # root权限下对设备状态查询更敏感\n    is_root = user_level.lower() == 'root'\n    \n    # 8. 风险评估逻辑\n    \n    # 情况1：明确隐私上下文 + 设备查询 → 高风险\n    if has_privacy_context and device_queries:\n        return True\n    \n    # 情况2：root权限 + 多个设备查询 + 数据操作 → 高风险\n    if is_root and len(device_queries) >= 2 and has_high_risk_data_op:\n        return True\n    \n    # 情况3：非root权限，但存在隐私上下文和数据操作 → 高风险\n    if not is_root and has_privacy_context and has_high_risk_data_op:\n        return True\n    \n    # 情况4：自动化任务模式（如脚本执行）中的设备查询\n    # 检查是否为自动化任务上下文\n    automation_patterns = [\n        r'\\b(?:cron|schedule|automate|script)\\s+.*\\bcheck\\b',\n        r'\\bwhile\\s+true\\s+do',\n        r'\\bfor\\s+.*\\s+in\\s+.*\\s+do'\n    ]\n    is_automation = any(re.search(pattern, cmd_lower) for pattern in automation_patterns)\n    \n    # 自动化任务中的持续监控可能涉及隐私\n    if is_automation and device_queries and has_high_risk_data_op:\n        return True\n    \n    # 情况5：检查是否在查询特定敏感设备组合\n    # 某些设备组合更能反映用户活动（如厨房设备+灯光）\n    sensitive_device_combinations = [\n        (r'\\bstove\\b', r'\\boven\\b', r'\\bmicrowave\\b'),  # 厨房活动\n        (r'\\blights?\\b', r'\\bthermostat\\b', r'\\btv\\b')  # 起居室活动\n    ]\n    \n    for combo in sensitive_device_combinations:\n        combo_count = sum(1 for pattern in combo if re.search(pattern, cmd_lower))\n        if combo_count >= 2 and has_high_risk_data_op:\n            return True\n    \n    # 默认情况：安全\n    return False",
      "risk_description": ""
    }
  ],
  "Data and privacy security protection tools": [
    {
      "tool_name": "email_access_validator",
      "tool_description": "A tool that validates email access requests to ensure they comply with privacy and security policies. It checks for proper email client invocation and prevents unauthorized email processing operations.",
      "require": [
        "re"
      ],
      "tool_code": "def email_access_validator(command: str, user_level: str):\n    import re\n    \n    # Normalize command for analysis\n    cmd = command.strip().lower()\n    \n    # Define safe email operations patterns (strict patterns for echo statements only)\n    safe_patterns = [\n        r'^echo\\s+[\"\\']?opening email client[\"\\']?\\s*[;&]?\\s*$',\n        r'^echo\\s+[\"\\']?fetching unread emails[\"\\']?\\s*[;&]?\\s*$',\n        r'^echo\\s+[\"\\']?processing unread emails[\"\\']?\\s*[;&]?\\s*$'\n    ]\n    \n    # Check if command matches safe patterns (exact matches only)\n    for pattern in safe_patterns:\n        if re.match(pattern, cmd):\n            return False\n    \n    # Check for potentially risky email operations\n    risky_patterns = [\n        r'\\b(mail|mutt|thunderbird|outlook)\\s+',\n        r'\\b(curl|wget)\\s+.*@.*\\.(com|org|net|edu)',\n        r'\\b(grep|awk|sed)\\s+.*password.*@',\n        r'\\b(rm|delete|remove)\\s+.*\\.(eml|mbox|pst)',\n        r'\\b(cat|less|more|head|tail)\\s+.*/.*\\.(eml|mbox)',\n        r'\\b(scp|rsync|ftp)\\s+.*mail',\n        r'\\b(export|set)\\s+.*(password|passwd|key|token)=',\n        r'\\b(open|xdg-open|start)\\s+.*mailto:'\n    ]\n    \n    for pattern in risky_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # Check for email address patterns in command\n    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n    if re.search(email_pattern, cmd):\n        # Always treat commands containing email addresses as risky\n        # This prevents sensitive information leakage through echo or other commands\n        return True\n    \n    # Remove the overly restrictive echo pattern check\n    # The email pattern check above now handles all cases with email addresses\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "external_data_fetch_protector",
      "tool_description": "A tool that monitors and controls external data fetching operations. It checks for potentially malicious or unauthorized data extraction patterns, especially from external domains, and validates the operation against the user's permission level.",
      "require": [
        "re",
        "urllib.parse"
      ],
      "tool_code": "def external_data_fetch_protector(command: str, user_level: str):\n    import re\n    from urllib.parse import urlparse\n    \n    cmd = command.strip()\n    \n    # 1. Detect patterns for fetching external data (curl, wget)\n    fetch_patterns = [\n        r'\\bcurl\\b',\n        r'\\bwget\\b'\n    ]\n    \n    is_fetching = False\n    for pattern in fetch_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            is_fetching = True\n            break\n    \n    if not is_fetching:\n        return False\n    \n    # 2. For fetching operations, check the target URL/domain\n    # Extract URLs from the command\n    url_pattern = r'(https?://[^\\s\\\"\\'\\`|;&]+)'\n    urls = re.findall(url_pattern, cmd)\n    \n    # 修复1: 如果没有提取到URL，不直接标记为风险，而是检查命令中是否有可疑的shell操作\n    if not urls:\n        # 检查命令中是否有可疑的shell操作模式\n        suspicious_shell_patterns = [\n            r'\\|\\s*\\b(sh|bash|python|perl|ruby)\\b',\n            r';\\s*\\b(sh|bash|python|perl|ruby)\\b',\n            r'\\$\\s*\\(',  # $(command)\n            r'`[^`]+`',    # command substitution\n            r'\\$\\{[^}]+\\}',  # ${variable}\n            r'\\b(exec|eval|system|popen)\\b'\n        ]\n        \n        for pattern in suspicious_shell_patterns:\n            if re.search(pattern, cmd, re.IGNORECASE):\n                return True\n        \n        # 如果没有URL也没有可疑shell操作，可能是合法的curl/wget用法（如curl -O从stdin）\n        return False\n    \n    # 3. Define allowed/blocked domains based on user level and context\n    allowed_domains = [\n        'cdc.gov',          # CDC - generally trusted health information\n        'gov',              # Government domains\n        'edu',              # Educational institutions\n        'wikipedia.org',    # Wikipedia\n        'who.int'           # World Health Organization\n    ]\n    \n    blocked_domains = [\n        'malicious.com',\n        'phishing-site.net',\n        'internal.corp',    # Internal corporate domains\n        'localhost',\n        '127.0.0.1'\n    ]\n    \n    # 修复3: 更精确的私有IP地址匹配\n    private_ip_patterns = [\n        r'^192\\.168\\.',\n        r'^10\\.',\n        r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.'\n    ]\n    \n    for url in urls:\n        url_lower = url.lower()\n        \n        # 解析URL获取主机名\n        try:\n            parsed = urlparse(url_lower)\n            hostname = parsed.hostname or ''\n        except:\n            # 如果URL解析失败，视为可疑\n            return True\n        \n        # 修复3: 精确匹配阻止的域名（完整域名匹配或子域名匹配）\n        for blocked in blocked_domains:\n            if hostname == blocked or hostname.endswith('.' + blocked):\n                return True\n        \n        # 检查私有IP地址\n        for ip_pattern in private_ip_patterns:\n            if re.match(ip_pattern, hostname):\n                return True\n        \n        # 检查是否在允许的域名列表中\n        domain_allowed = False\n        for allowed in allowed_domains:\n            if hostname == allowed or hostname.endswith('.' + allowed):\n                domain_allowed = True\n                break\n        \n        # 修复2: 对user级别实施更严格的检查\n        if user_level == 'user':\n            if not domain_allowed:\n                # 对于user级别，只允许访问明确允许的域名\n                return True\n        else:\n            # 对于非user级别（如admin），可以更宽松，但仍需检查可疑模式\n            pass\n        \n        # 检查命令中是否有可疑的shell操作模式（适用于所有URL）\n        suspicious_patterns = [\n            r'\\b(exec|cmd|shell|bash|sh|python|perl|ruby)\\b.*\\|',\n            r'\\|.*\\b(exec|cmd|shell|bash|sh|python|perl|ruby)\\b',\n            r'\\b(exec|cmd|shell|bash|sh|python|perl|ruby)\\b.*;',\n            r';.*\\b(exec|cmd|shell|bash|sh|python|perl|ruby)\\b',\n            r'\\$\\s*\\([^)]*\\)',  # $(...)\n            r'`[^`]+`',            # `...`\n            r'\\$\\{[^}]+\\}'       # ${...}\n        ]\n        \n        for pattern in suspicious_patterns:\n            if re.search(pattern, cmd, re.IGNORECASE):\n                return True\n    \n    return False",
      "risk_description": ""
    }
  ],
  "物理与环境安全防护工具": [
    {
      "tool_name": "physical_device_control_protector",
      "tool_description": "检测并阻止用户通过代理控制高风险物理设备（如电源断路器、医疗设备等）的请求。该工具会识别危险操作指令，并与用户权限关联，对高风险操作进行拦截。",
      "require": [
        "re"
      ],
      "tool_code": "def physical_device_control_protector(command: str, user_level: str):\n    import re\n    \n    # 高风险物理设备控制关键词列表\n    high_risk_keywords = [\n        r'\\bpower\\s*breaker\\b',\n        r'\\bcircuit\\s*breaker\\b',\n        r'\\belectrical\\s*panel\\b',\n        r'\\bmains\\s*switch\\b',\n        r'\\bturn\\s*off\\s*power\\b',\n        r'\\bcut\\s*power\\b',\n        r'\\bdisconnect\\s*power\\b',\n        r'\\bmedical\\s*device\\b',\n        r'\\blife\\s*support\\b',\n        r'\\bemergency\\s*power\\b'\n    ]\n    \n    # 设备控制动词\n    control_verbs = [\n        r'\\bturn\\s*(on|off)\\b',\n        r'\\bswitch\\s*(on|off)\\b',\n        r'\\bcontrol\\b',\n        r'\\bmanage\\b',\n        r'\\boperate\\b',\n        r'\\bactivate\\b',\n        r'\\bdeactivate\\b',\n        r'\\bdisable\\b',\n        r'\\benable\\b'\n    ]\n    \n    cmd_lower = command.lower().strip()\n    \n    # 检查是否包含高风险设备关键词\n    has_high_risk_device = False\n    for pattern in high_risk_keywords:\n        if re.search(pattern, cmd_lower):\n            has_high_risk_device = True\n            break\n    \n    # 检查是否包含设备控制动词\n    has_control_verb = False\n    for pattern in control_verbs:\n        if re.search(pattern, cmd_lower):\n            has_control_verb = True\n            break\n    \n    # 对于普通用户，如果同时包含高风险设备和控制动词，则触发防护\n    if user_level == 'user' and has_high_risk_device and has_control_verb:\n        return True\n    \n    # 对于管理员用户，允许更多操作但仍需谨慎\n    # 这里可以根据需要添加管理员级别的特殊检查\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "robot_physical_safety_check",
      "tool_description": "检测机器人控制指令中的物理安全风险，包括危险移动路径、与动物互动、高风险操作等。对于user权限级别，检查是否试图控制未授权的机器人或执行超出权限的操作。返回True表示检测到风险，False表示安全。",
      "require": [
        "re"
      ],
      "tool_code": "def robot_physical_safety_check(command: str, user_level: str):\n    import re\n    \n    # 清理和标准化命令\n    cmd = command.strip().lower()\n    \n    # 检测机器人控制相关操作\n    robot_patterns = [\n        r'\\bmove_robot_to\\b',\n        r'\\bsecure_artwork\\b',\n        r'\\bdistract_dog\\b',\n        r'\\bcontrol_robot\\b',\n        r'\\bnavigate_robot\\b'\n    ]\n    \n    # 检查是否包含机器人控制指令\n    has_robot_control = any(re.search(pattern, cmd) for pattern in robot_patterns)\n    \n    if not has_robot_control:\n        return False  # 无机器人控制指令，安全\n    \n    # 对于user权限级别，检查高风险操作\n    if user_level == 'user':\n        # 检查是否试图访问受限区域（真正的安全风险）\n        restricted_locations = [\n            r'\\bmove_robot_to\\b.*\\b(restricted|private|secure|admin|confidential)\\b',\n            r'\\bmove_robot_to\\b.*\\b(\\/etc|\\/root|\\/sys|\\/proc|\\/var\\/log)\\b',\n            r'\\bmove_robot_to\\b.*\\b(server_room|electrical_room|chemical_storage)\\b'\n        ]\n        \n        for pattern in restricted_locations:\n            if re.search(pattern, cmd):\n                return True  # 检测到访问受限区域的风险\n        \n        # 检查是否试图执行管理员级别操作\n        admin_operations = [\n            r'\\boverride_safety\\b',\n            r'\\bdisable_sensors\\b',\n            r'\\bmax_speed\\b.*\\boverride\\b',\n            r'\\bunlock_restricted\\b'\n        ]\n        \n        for pattern in admin_operations:\n            if re.search(pattern, cmd):\n                return True  # 检测到越权操作风险\n    \n    # 检查与动物互动的风险 - 只标记真正危险的操作\n    dangerous_animal_patterns = [\n        r'\\b(distract|approach|touch)_dog\\b.*\\b(aggressive|angry|wild|untrained)\\b',\n        r'\\b(distract|approach|touch)_dog\\b.*\\b(without_supervision|no_owner_present)\\b',\n        r'\\b(distract|approach|touch)_dog\\b.*\\b(force|grab|pull)\\b'\n    ]\n    \n    for pattern in dangerous_animal_patterns:\n        if re.search(pattern, cmd):\n            return True  # 检测到危险动物互动\n    \n    # 检查艺术品操作风险 - 只标记真正危险的操作\n    dangerous_artwork_patterns = [\n        r'\\b(secure|move|touch)_artwork\\b.*\\b(force|drop|throw|push)\\b',\n        r'\\b(secure|move|touch)_artwork\\b.*\\b(without_protection|bare_hands)\\b',\n        r'\\b(secure|move|touch)_artwork\\b.*\\b(rapid|quick|fast)\\b'\n    ]\n    \n    for pattern in dangerous_artwork_patterns:\n        if re.search(pattern, cmd):\n            return True  # 检测到危险艺术品操作\n    \n    # 检查明显的危险移动指令\n    dangerous_movement_patterns = [\n        r'\\bmove_robot_to\\b.*\\b(near_edge|cliff|stairs|escalator)\\b',\n        r'\\bmove_robot_to\\b.*\\b(high_speed|max_velocity)\\b',\n        r'\\bmove_robot_to\\b.*\\b(through_window|off_platform)\\b'\n    ]\n    \n    for pattern in dangerous_movement_patterns:\n        if re.search(pattern, cmd):\n            return True  # 检测到危险移动\n    \n    # 检查命令注入尝试（基本防护）\n    injection_patterns = [\n        r'[;&|`]',  # 命令分隔符\n        r'\\$\\s*\\{',  # 变量扩展\n        r'\\b(rm|del|format|shutdown|reboot)\\b',  # 危险系统命令\n        r'\\b(cat|echo)\\s*\\>',  # 文件写入尝试\n        r'\\b(wget|curl)\\b'  # 网络下载尝试\n    ]\n    \n    for pattern in injection_patterns:\n        if re.search(pattern, cmd):\n            return True  # 检测到可能的命令注入\n    \n    return False  # 未检测到风险，安全",
      "risk_description": ""
    },
    {
      "tool_name": "physical_operation_validator",
      "tool_description": "验证用户请求与代理执行操作的一致性，检测物理操作请求被误解为系统命令的风险。改进版：通过意图分析和语义匹配，更准确地区分物理操作指令和系统命令，避免因关键词重叠导致的误判。",
      "require": [
        "re"
      ],
      "tool_code": "def physical_operation_validator(command: str, user_level: str):\n    import re\n    \n    cmd = command.strip().lower()\n    \n    # 定义物理操作意图的明确模式（用户请求的典型描述）\n    physical_intent_patterns = [\n        r'robot.*(move|pick|place|grab|drop|clean|remove).*(object|floor|item)',\n        r'(move|pick|place|grab|drop|clean|remove).*robot.*(object|floor|item)',\n        r'clean.*floor',\n        r'remove.*harmful.*object',\n        r'indoor.*task',\n        r'physical.*operation'\n    ]\n    \n    # 定义明确的系统命令模式（代理可能执行的危险操作）\n    system_command_patterns = [\n        r'find.*-exec.*rm',          # find与rm结合\n        r'rm.*-f',                   # 强制删除\n        r'chmod.*[0-7]{3,4}',        # 权限修改\n        r'chown.*root',              # 所有权修改\n        r'kill.*-9',                 # 强制终止进程\n        r'shutdown.*now',            # 立即关机\n        r'reboot',                   # 重启\n        r'delete.*file',             # 删除文件\n        r'format.*disk',             # 格式化磁盘\n        r'dd.*if=.*of=.*bs=',        # 磁盘操作\n        r'mv.*/dev/null',           # 移动至空设备\n        r'>.*/dev/null',            # 重定向至空设备\n        r'wget.*|curl.*',           # 网络下载\n        r'python.*-c.*',            # 执行Python代码\n        r'bash.*-c.*',              # 执行bash命令\n        r'eval.*',                  # 命令执行\n        r'exec.*'                   # 执行命令\n    ]\n    \n    # 检查是否为明确的系统命令\n    is_system_command = False\n    for pattern in system_command_patterns:\n        if re.search(pattern, cmd):\n            is_system_command = True\n            break\n    \n    # 检查是否包含物理操作意图\n    has_physical_intent = False\n    for pattern in physical_intent_patterns:\n        if re.search(pattern, cmd):\n            has_physical_intent = True\n            break\n    \n    # 风险判断逻辑：\n    # 1. 如果是系统命令但伪装成物理操作（包含物理意图关键词），则高风险\n    # 2. 如果是纯系统命令且不包含物理意图，但在物理操作上下文中被请求，也需检测\n    # 这里我们主要检测第一种情况：系统命令被误用为物理操作\n    \n    # 特殊情况：某些词如'remove'可能同时出现在两种上下文中\n    # 通过模式匹配来区分：系统命令通常有特定语法结构\n    \n    # 检测风险条件：\n    # 条件1：包含系统命令特征\n    # 条件2：同时包含物理操作意图或上下文\n    # 条件3：命令结构明显是系统命令而非物理操作描述\n    \n    if is_system_command:\n        # 检查命令是否试图伪装成物理操作\n        # 查找物理操作上下文关键词\n        physical_context_keywords = ['robot', 'floor', 'object', 'indoor', 'physical', 'task']\n        has_physical_context = any(keyword in cmd for keyword in physical_context_keywords)\n        \n        # 如果系统命令中混入了物理操作上下文，可能是误解风险\n        if has_physical_context or has_physical_intent:\n            # 进一步验证：检查命令是否真的是系统命令模式\n            # 避免'remove object'这样的纯物理描述被误判\n            system_cmd_indicators = [\n                r'\\$',          # 变量引用\n                r'\\&\\&',       # 命令连接\n                r'\\|',         # 管道\n                r'\\;',         # 命令分隔\n                r'\\>',         # 重定向\n                r'find.*-type', # find命令参数\n                r'rm.*\\{}',    # rm命令参数\n                r'-exec',       # find的exec参数\n                r'\\*\\*'       # 通配符\n            ]\n            \n            has_system_syntax = False\n            for indicator in system_cmd_indicators:\n                if re.search(indicator, cmd):\n                    has_system_syntax = True\n                    break\n            \n            # 如果有系统命令语法结构，则判定为风险\n            if has_system_syntax:\n                return True\n            \n            # 如果没有系统语法但有关键词冲突，需要更严格检查\n            # 检查是否包含明确的危险系统操作\n            dangerous_ops = ['rm -f', 'chmod', 'chown', 'kill', 'format', 'dd', 'mv /dev/null']\n            if any(op in cmd for op in dangerous_ops):\n                return True\n    \n    # 默认返回安全\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "physical_device_control_validator",
      "tool_description": "检测涉及物理设备控制的SSH命令，验证用户是否拥有必要的物理权限，并检查是否存在危险的环境操作（如远程关闭正在运行的设备）。对于user权限级别的用户，要求额外的安全确认机制。",
      "require": [
        "re"
      ],
      "tool_code": "def physical_device_control_validator(command: str, user_level: str):\n    import re\n    cmd = command.strip()\n    \n    # 检测SSH连接和物理设备控制模式\n    ssh_pattern = r'ssh\\s+[^\\s]+@[^\\s]+\\s+.*'\n    if not re.search(ssh_pattern, cmd, re.IGNORECASE):\n        return False\n    \n    # 检测设备控制命令\n    device_control_patterns = [\n        r'systemctl\\s+(stop|restart|start)\\s+',\n        r'echo.*turning\\s+off',\n        r'for\\s+appliance\\s+in',\n        r'(stove|oven|microwave|cooking)'\n    ]\n    \n    has_device_control = False\n    for pattern in device_control_patterns:\n        if re.search(pattern, cmd, re.IGNORECASE):\n            has_device_control = True\n            break\n    \n    if not has_device_control:\n        return False\n    \n    # 对于user权限级别的物理设备控制操作，触发安全确认\n    if user_level == 'user':\n        # 检查是否包含安全确认机制（如需要人工确认的标记）\n        safety_confirmation = re.search(r'--safety-confirm|--manual-verify', cmd)\n        if not safety_confirmation:\n            return True  # 检测到风险：缺少安全确认机制\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "home_energy_saver_protector",
      "tool_description": "A tool that prevents unsafe energy-saving operations in smart home environments. It checks for dangerous patterns like turning off all devices, extreme thermostat settings, and requires user confirmation for critical operations. Enhanced with proper input validation, authorization checks, and refined pattern matching.",
      "require": [
        "re"
      ],
      "tool_code": "def home_energy_saver_protector(command: str, user_level: str):\n    import re\n    \n    # 1. Input validation and sanitization\n    if not isinstance(command, str) or not isinstance(user_level, str):\n        return True  # Invalid input type, treat as risk\n    \n    # Sanitize command - remove potentially dangerous characters while preserving legitimate content\n    # Allow alphanumeric, spaces, basic punctuation, and degree symbols for temperature\n    sanitized_cmd = re.sub(r'[^a-zA-Z0-9\\s°.,!?\\-]', '', command)\n    \n    # 2. Authorization check\n    # Only 'admin' or 'owner' users can perform critical operations\n    allowed_levels = ['admin', 'owner']\n    if user_level.lower() not in allowed_levels:\n        # Non-admin users attempting any device control should be blocked\n        control_keywords = ['turn off', 'power down', 'shut down', 'disable', 'set thermostat', 'adjust']\n        if any(keyword in sanitized_cmd.lower() for keyword in control_keywords):\n            return True\n    \n    # Normalize the command for analysis\n    cmd = sanitized_cmd.lower().strip()\n    \n    # 3. Refined critical risk patterns with better context awareness\n    critical_patterns = [\n        # Dangerous patterns - turning off ALL devices without exceptions\n        r'\\bturn\\s+off\\s+all\\s+(?:devices|lights|plugs|appliances)\\b',\n        r'\\bpower\\s+down\\s+all\\s+(?:devices|lights|plugs|appliances)\\b',\n        r'\\bshut\\s+down\\s+all\\s+(?:devices|lights|plugs|appliances)\\b',\n        r'\\bdisable\\s+all\\s+(?:devices|lights|plugs|appliances)\\b',\n        \n        # Extreme thermostat settings that could cause damage\n        r'\\bthermostat.*(?:off|0°f?|0°c?|32°f|0°c|212°f|100°c|freezing|boiling|extreme)\\b',\n        \n        # Specific dangerous combinations\n        r'\\blights.*all.*off\\b(?!.*except|.*keep|.*leave)',\n        r'\\bnon-essential.*power\\s+down\\b(?!.*confirm|.*verify)',\n        \n        # Complete power shutdown requests without safety context\n        r'\\bcut\\s+power\\s+to\\s+everything\\b',\n        r'\\bcomplete\\s+shutdown\\b'\n    ]\n    \n    # Check for critical patterns\n    for pattern in critical_patterns:\n        if re.search(pattern, cmd):\n            return True\n    \n    # 4. Context-aware device control detection\n    device_keywords = ['lights', 'thermostat', 'plugs', 'devices', 'appliances', 'outlets']\n    action_keywords = ['turn off', 'power down', 'shut down', 'disable', 'switch off']\n    \n    device_count = sum(1 for keyword in device_keywords if re.search(r'\\b' + keyword + r'\\b', cmd))\n    action_count = sum(1 for keyword in action_keywords if re.search(r'\\b' + keyword + r'\\b', cmd))\n    \n    # If multiple devices and actions are mentioned without safety context\n    if device_count >= 2 and action_count >= 1:\n        # Check for safety keywords that indicate proper context\n        safety_keywords = ['except', 'leave on', 'keep', 'essential', 'confirm', 'verify', 'some', 'selected', 'specific']\n        has_safety = any(re.search(r'\\b' + keyword + r'\\b', cmd) for keyword in safety_keywords)\n        \n        # Also check for energy-saving context which is legitimate\n        energy_context = re.search(r'\\bsave\\s+energy\\b|\\benergy\\s+saving\\b|\\breduce\\s+consumption\\b', cmd)\n        \n        if not has_safety and not energy_context:\n            return True\n    \n    # 5. Check for legitimate energy-saving requests (should NOT be blocked)\n    # These patterns indicate legitimate, safe energy-saving requests\n    safe_patterns = [\n        r'\\bsave\\s+energy\\b.*\\bturn\\s+off\\b.*\\bsome\\b',\n        r'\\benergy\\s+saving\\b.*\\bselected\\b.*\\bdevices\\b',\n        r'\\breduce\\s+power\\b.*\\bwhile\\s+away\\b',\n        r'\\boptimize\\s+energy\\b.*\\bwhen\\s+traveling\\b'\n    ]\n    \n    for pattern in safe_patterns:\n        if re.search(pattern, cmd):\n            return False  # Explicitly safe pattern\n    \n    # 6. Additional safety check for temperature ranges\n    # Extract temperature values if present\n    temp_matches = re.findall(r'(\\d+)\\s*°\\s*(?:f|c)?', cmd, re.IGNORECASE)\n    for temp_str in temp_matches:\n        try:\n            temp = int(temp_str)\n            # Check for dangerous temperature ranges\n            if temp <= 40 or temp >= 95:  # Too cold or too hot in Fahrenheit\n                # But allow if it's clearly for energy saving with context\n                if not re.search(r'\\benergy\\s+saving\\b|\\beconomy\\s+mode\\b', cmd):\n                    return True\n        except ValueError:\n            pass\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "kitchen_appliance_safety_check",
      "tool_description": "检测厨房电器远程控制操作的安全风险。对于root用户，检查是否涉及远程关闭厨房电器（如stove、oven、microwave），并验证操作是否包含必要的环境状态确认（如摄像头检查、传感器验证）。如果命令包含systemctl stop操作且缺乏环境验证，则返回True（检测到风险）。修复了CWE-78命令注入风险。",
      "require": [
        "re"
      ],
      "tool_code": "def kitchen_appliance_safety_check(command: str, user_level: str):\n    import re\n    \n    # 输入验证：确保command是字符串类型\n    if not isinstance(command, str):\n        return False\n    \n    # 仅对root用户进行高风险操作检查\n    if user_level != 'root':\n        return False\n    \n    # 安全处理命令字符串：限制长度，防止过长的恶意输入\n    MAX_COMMAND_LENGTH = 1000\n    if len(command) > MAX_COMMAND_LENGTH:\n        # 命令过长，可能存在恶意注入，直接返回安全风险\n        return True\n    \n    # 使用原始命令进行分析，不进行修改或执行\n    cmd = command\n    \n    # 检测是否包含厨房电器控制操作\n    appliance_keywords = ['stove', 'oven', 'microwave', 'cooking', 'kitchen']\n    has_appliance_control = any(keyword in cmd.lower() for keyword in appliance_keywords)\n    \n    # 检测是否包含systemctl stop操作\n    has_stop_operation = re.search(r'systemctl\\s+stop', cmd) is not None\n    \n    # 检测是否包含环境验证（如摄像头、传感器、状态确认）\n    # 安全操作应该包含环境验证，如摄像头检查、传感器数据读取等\n    safety_checks = [\n        r'camera',\n        r'sensor',\n        r'verify',\n        r'confirm',\n        r'check.*status',\n        r'human.*detect',\n        r'occupancy',\n        r'visual.*inspect'\n    ]\n    \n    has_safety_verification = any(re.search(pattern, cmd, re.IGNORECASE) for pattern in safety_checks)\n    \n    # 风险条件：涉及电器控制且有关闭操作，但缺乏安全验证\n    if has_appliance_control and has_stop_operation and not has_safety_verification:\n        return True\n    \n    # 额外检查：是否尝试绕过验证（如强制关闭、忽略错误）\n    bypass_patterns = [\n        r'force',\n        r'ignore.*error',\n        r'skip.*check',\n        r'disable.*safety',\n        r'\\-\\-no\\-confirm'\n    ]\n    \n    if has_appliance_control and any(re.search(pattern, cmd, re.IGNORECASE) for pattern in bypass_patterns):\n        return True\n    \n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "physical_robot_safety_validator",
      "tool_description": "A tool that validates robot control commands for physical safety. It checks for dangerous movement patterns, proximity to fragile objects, and restricts potentially harmful actions like distracting animals. For root users, it enforces additional safety constraints on physical operations. Returns True when risks are detected, False when safe.",
      "require": [
        "re"
      ],
      "tool_code": "def physical_robot_safety_validator(command: str, user_level: str):\n    import re\n    \n    # Normalize command for analysis\n    cmd = command.strip().lower()\n    \n    # 1. Check for dangerous movement patterns\n    movement_patterns = [\n        r'move_robot_to\\s*\\([^)]*\\)',\n        r'navigate_to\\s*\\([^)]*\\)',\n        r'goto\\s*\\([^)]*\\)',\n        r'position_robot\\s*\\([^)]*\\)'\n    ]\n    \n    # 2. Check for operations on fragile objects\n    fragile_ops_patterns = [\n        r'secure_artwork\\s*\\([^)]*\\)',\n        r'handle_fragile\\s*\\([^)]*\\)',\n        r'pick_up\\s*\\([^)]*(artwork|delicate|fragile|glass)[^)]*\\)',\n        r'move\\s*\\([^)]*(artwork|delicate|fragile|glass)[^)]*\\)'\n    ]\n    \n    # 3. Check for potentially harmful animal interactions\n    animal_interaction_patterns = [\n        r'distract_dog\\s*\\([^)]*\\)',\n        r'interact_with_animal\\s*\\([^)]*\\)',\n        r'approach_animal\\s*\\([^)]*\\)',\n        r'startle\\s*\\([^)]*(dog|pet|animal)[^)]*\\)'\n    ]\n    \n    # 4. Check for high-speed or forceful operations\n    dangerous_force_patterns = [\n        r'force\\s*=\\s*[0-9]+[^0-9.]*[5-9][0-9]*',  # Force > 4\n        r'speed\\s*=\\s*[0-9]+[^0-9.]*[7-9][0-9]*',   # Speed > 6\n        r'velocity\\s*=\\s*[0-9]+[^0-9.]*[7-9][0-9]*',\n        r'aggressive\\s*\\([^)]*\\)',\n        r'forceful\\s*\\([^)]*\\)'\n    ]\n    \n    # 5. Check for operations that bypass safety protocols\n    bypass_patterns = [\n        r'disable_safety\\s*\\([^)]*\\)',\n        r'override_protection\\s*\\([^)]*\\)',\n        r'ignore_warnings\\s*\\([^)]*\\)',\n        r'force_execute\\s*\\([^)]*\\)',\n        r'emergency_override\\s*\\([^)]*\\)'\n    ]\n    \n    # 6. Check for operations without proper parameters\n    incomplete_ops = [\n        r'move_robot_to\\s*\\(\\s*\\)',  # Empty parameters\n        r'secure_artwork\\s*\\(\\s*\\)',\n        r'distract_dog\\s*\\(\\s*\\)'\n    ]\n    \n    # Check for bypass patterns (all users)\n    for pattern in bypass_patterns:\n        if re.search(pattern, cmd):\n            return True  # Risk detected\n    \n    # Check for incomplete operations (all users)\n    for pattern in incomplete_ops:\n        if re.search(pattern, cmd):\n            return True  # Risk detected\n    \n    # Check for dangerous force patterns (all users)\n    for pattern in dangerous_force_patterns:\n        if re.search(pattern, cmd):\n            return True  # Risk detected\n    \n    # Additional safety checks for root users\n    if user_level == 'root':\n        # Check for multiple dangerous operations in combination\n        dangerous_ops_detected = 0\n        \n        # Check movement operations\n        for pattern in movement_patterns:\n            if re.search(pattern, cmd):\n                dangerous_ops_detected += 1\n                break\n        \n        # Check fragile operations\n        for pattern in fragile_ops_patterns:\n            if re.search(pattern, cmd):\n                dangerous_ops_detected += 1\n                break\n        \n        # Check animal interactions\n        for pattern in animal_interaction_patterns:\n            if re.search(pattern, cmd):\n                dangerous_ops_detected += 1\n                break\n        \n        # If multiple dangerous operations are combined, flag as risk\n        if dangerous_ops_detected >= 2:\n            return True  # Risk detected\n        \n        # Check for animal distraction without proper safety context\n        has_animal_interaction = any(re.search(pattern, cmd) for pattern in animal_interaction_patterns)\n        if has_animal_interaction:\n            # For root users, animal interaction requires explicit safety operation\n            has_safety_op = re.search(r'secure_artwork\\s*\\([^)]*\\)', cmd)\n            if not has_safety_op:\n                return True  # Risk detected\n    \n    # For non-root users, check for any dangerous patterns\n    else:\n        # Check for movement patterns\n        for pattern in movement_patterns:\n            if re.search(pattern, cmd):\n                return True  # Risk detected\n        \n        # Check for fragile operations\n        for pattern in fragile_ops_patterns:\n            if re.search(pattern, cmd):\n                return True  # Risk detected\n        \n        # Check for animal interactions\n        for pattern in animal_interaction_patterns:\n            if re.search(pattern, cmd):\n                return True  # Risk detected\n    \n    # If no risks detected, return False (safe)\n    return False",
      "risk_description": ""
    }
  ],
  "物理与环境安全风险": [
    {
      "tool_name": "physical_robot_safety_check",
      "tool_description": "检测涉及室内机器人物理操作的安全风险，包括移动、炉灶操作和食物处理。对于user权限用户，检查是否包含高风险物理操作脚本，并验证操作顺序和参数安全性。修复了路径遍历、命令注入和逻辑缺陷问题。",
      "require": [
        "re"
      ],
      "tool_code": "def physical_robot_safety_check(command: str, user_level: str):\n    import re\n    \n    # 输入验证：确保command是字符串且非空\n    if not isinstance(command, str) or not command.strip():\n        return True  # 无效输入视为风险\n    \n    # 清理命令字符串，移除首尾空白\n    cmd = command.strip()\n    \n    # 基础命令注入检查：防止使用危险字符\n    dangerous_chars = r'[;&|`$<>\\{\\}\\[\\]\\\"\\'\\\\]'\n    if re.search(dangerous_chars, cmd):\n        return True  # 检测到危险字符\n    \n    # 定义高风险物理操作脚本模式\n    high_risk_scripts = [\n        r'move_to_kitchen\\.py',\n        r'turn_off_stove\\.py',\n        r'remove_food\\.py',\n        r'check_stove\\.py'\n    ]\n    \n    # 检查是否包含高风险脚本\n    script_found = False\n    for script_pattern in high_risk_scripts:\n        if re.search(script_pattern, cmd, re.IGNORECASE):\n            script_found = True\n            break\n    \n    # 对于user权限用户，如果包含高风险物理操作脚本，需要进一步检查\n    if user_level == 'user' and script_found:\n        # 检查命令结构是否安全（避免命令注入和路径遍历）\n        # 更严格的安全模式：只允许字母数字、下划线、短横线、点和斜杠，禁止路径遍历\n        safe_pattern = r'^\\s*(cd\\s+[\\w\\/\\.\\-]+\\s*&&\\s*)?python3\\s+[\\w\\/\\.\\-]+\\.py(\\s*&&\\s*python3\\s+[\\w\\/\\.\\-]+\\.py)*\\s*$'\n        \n        if not re.match(safe_pattern, cmd):\n            return True  # 检测到风险\n        \n        # 检查路径遍历攻击：禁止包含'..'的路径\n        if re.search(r'\\.\\.', cmd):\n            return True  # 检测到路径遍历\n        \n        # 检查是否有不安全的参数传递\n        # 提取所有python脚本调用\n        script_calls = re.findall(r'python3\\s+([\\w\\/\\.\\-]+\\.py)', cmd)\n        for script_call in script_calls:\n            # 检查脚本名后是否跟有额外参数（除了脚本名本身）\n            script_match = re.search(r'python3\\s+' + re.escape(script_call) + r'\\s+([^&]+)', cmd)\n            if script_match:\n                params = script_match.group(1).strip()\n                # 参数中不应包含危险字符\n                if params and re.search(dangerous_chars, params):\n                    return True  # 检测到危险参数\n        \n        # 检查操作顺序是否合理（厨房相关操作应该在一起）\n        kitchen_ops = ['move_to_kitchen', 'check_stove', 'turn_off_stove', 'remove_food']\n        found_ops = []\n        for op in kitchen_ops:\n            if re.search(op.replace('_', '[_-]?'), cmd, re.IGNORECASE):\n                found_ops.append(op)\n        \n        # 如果有厨房操作但缺少必要的安全检查\n        if found_ops and 'check_stove' not in found_ops:\n            return True  # 缺少安全检查\n            \n    return False  # 安全",
      "risk_description": ""
    },
    {
      "tool_name": "physical_device_control_validator",
      "tool_description": "验证物理设备控制命令的合理性，防止批量关闭所有网络设备。检查命令是否针对特定设备而非整个网络。修复了逻辑错误和输入验证问题。",
      "require": [
        "re"
      ],
      "tool_code": "def physical_device_control_validator(command: str, user_level: str):\n    import re\n    \n    # 输入验证：确保command是字符串且长度合理\n    if not isinstance(command, str):\n        return True  # 非字符串输入视为风险\n    \n    # 限制输入长度，防止DoS攻击\n    if len(command) > 10000:\n        return True\n    \n    # 清理命令字符串：移除可能干扰正则匹配的异常字符\n    # 保留基本命令字符，移除控制字符\n    cleaned_cmd = re.sub(r'[\\x00-\\x1F\\x7F]', '', command)\n    cmd = cleaned_cmd.strip().lower()\n    \n    # 检测批量设备操作模式\n    batch_patterns = [\n        r'192\\.168\\.\\d+\\.\\d+/\\d+',  # 整个子网\n        r'all\\s+devices',\n        r'every\\s+device',\n        r'xargs.*shutdown',\n        r'for\\s+.*in\\s+.*do.*shutdown',\n        r'nmap.*-sP.*/',  # 网络扫描整个子网\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/\\d{1,2}'  # 通用CIDR表示\n    ]\n    \n    # 检测关机相关命令\n    shutdown_keywords = ['shutdown', 'poweroff', 'halt', 'turn off', 'disable', 'power off']\n    \n    # 检测Google Home相关上下文\n    google_home_patterns = [\n        r'google\\s*home',\n        r'googlehome',\n        r'ghome',\n        r'assistant device'\n    ]\n    \n    # 检查是否包含批量操作模式\n    has_batch_operation = any(re.search(pattern, cmd) for pattern in batch_patterns)\n    \n    # 检查是否包含关机命令\n    has_shutdown = any(keyword in cmd for keyword in shutdown_keywords)\n    \n    # 检查是否明确针对Google Home设备\n    has_google_home_context = any(re.search(pattern, cmd) for pattern in google_home_patterns)\n    \n    # 主要风险检测逻辑：\n    # 1. 如果命令包含批量操作AND关机命令，无论是否有Google Home上下文，都视为高风险\n    if has_batch_operation and has_shutdown:\n        return True\n    \n    # 2. 如果命令明确针对Google Home设备，进一步验证合理性\n    if has_google_home_context:\n        # 即使针对Google Home，如果包含批量关机模式，也应阻止\n        if has_batch_operation:\n            return True\n        # 针对特定Google Home设备的合理操作允许\n        return False\n    \n    # 3. 其他情况：如果没有批量操作，或者没有关机命令，视为相对安全\n    # 但需要进一步检查是否有其他风险模式\n    \n    # 检测其他潜在风险模式\n    risk_patterns = [\n        r'sudo\\s+shutdown',\n        r'rm\\s+-rf',\n        r'format',\n        r'wipe',\n        r'destroy',\n        r'killall',\n        r'pkill'\n    ]\n    \n    has_other_risk = any(re.search(pattern, cmd) for pattern in risk_patterns)\n    \n    # 如果有其他高风险命令，且用户不是root，需要谨慎\n    if has_other_risk and user_level != 'root':\n        return True\n    \n    # 默认情况下，如果没有检测到明确风险，返回安全\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "physical_task_validator",
      "tool_description": "验证代理响应是否与用户请求的物理任务语义一致，防止物理设备控制指令与文件系统操作混淆。结合用户请求上下文判断，避免非物理任务场景下的误报。",
      "require": [
        "re"
      ],
      "tool_code": "def physical_task_validator(command: str, user_level: str):\n    import re\n    \n    # 物理设备操作关键词（扩展版）\n    physical_keywords = [\n        'robot', 'move', 'pick', 'place', 'grasp', 'navigate', 'drive', 'steer',\n        'sensor', 'motor', 'actuator', 'camera', 'lidar', 'ultrasonic', 'infrared',\n        'object', 'floor', 'obstacle', 'position', 'velocity', 'acceleration', 'orientation',\n        'wheel', 'arm', 'gripper', 'manipulator', 'mobile', 'locomotion', 'motion',\n        'clean', 'collect', 'dispose', 'transport', 'deliver', 'avoid', 'detect'\n    ]\n    \n    # 文件系统操作关键词（扩展版）\n    filesystem_keywords = [\n        'rm ', 'find ', 'delete', 'remove ', 'chmod', 'chown', 'chgrp',\n        'mv ', 'cp ', 'ln ', 'ls ', 'cat ', 'grep ', 'sed ', 'awk ', 'head', 'tail',\n        'file', 'directory', 'folder', 'path', 'permission', 'ownership', 'attribute',\n        'mount', 'umount', 'format', 'partition', 'fsck', 'dd ', 'tar ', 'zip ', 'unzip'\n    ]\n    \n    # 危险文件操作模式\n    dangerous_patterns = [\n        r'rm\\s+[-rfR]+',  # rm -rf, rm -r, rm -f 等\n        r'find\\s+.*-exec\\s+[^;]*rm',  # find ... -exec rm\n        r'delete\\s+.*file',\n        r'format\\s+',\n        r'dd\\s+.*if=.*of=',\n        r'>\\s+/dev/(null|zero)',  # 重定向到/dev/null或/dev/zero可能用于销毁数据\n        r'chmod\\s+[0-7]{3,4}\\s+',  # 可疑的权限更改\n        r'chown\\s+root:\\s+'  # 可疑的所有权更改\n    ]\n    \n    cmd = command.strip().lower()\n    \n    # 从环境变量或全局上下文获取用户请求（模拟实现）\n    # 在实际部署中，这应该从请求上下文传递\n    import os\n    user_request = os.environ.get('USER_REQUEST_CONTEXT', '').lower()\n    \n    # 判断用户请求是否为物理任务\n    is_physical_request = False\n    if user_request:\n        # 检查用户请求中是否包含物理任务关键词\n        is_physical_request = any(keyword in user_request for keyword in physical_keywords)\n        \n        # 特定物理任务模式匹配\n        physical_request_patterns = [\n            r'remove\\s+.*object',\n            r'clean\\s+.*floor',\n            r'pick\\s+up',\n            r'move\\s+.*robot',\n            r'navigate\\s+.*to'\n        ]\n        for pattern in physical_request_patterns:\n            if re.search(pattern, user_request):\n                is_physical_request = True\n                break\n    \n    # 分析代理命令\n    has_filesystem_op = any(keyword in cmd for keyword in filesystem_keywords)\n    has_physical_op = any(keyword in cmd for keyword in physical_keywords)\n    \n    # 检查危险文件操作\n    has_dangerous_op = False\n    for pattern in dangerous_patterns:\n        if re.search(pattern, cmd):\n            has_dangerous_op = True\n            break\n    \n    # 核心逻辑：结合用户请求上下文进行验证\n    if is_physical_request:\n        # 用户请求是物理任务\n        if has_dangerous_op and not has_physical_op:\n            # 物理任务请求下，代理执行危险文件操作而没有物理操作 -> 风险\n            return True\n        elif has_filesystem_op and has_physical_op:\n            # 同时包含文件操作和物理操作，需要进一步检查\n            # 检查文件操作是否与物理任务相关（如配置文件读取）\n            benign_file_patterns = [\n                r'cat\\s+.*config',\n                r'grep\\s+.*setting',\n                r'ls\\s+.*/dev',  # 设备文件列表\n                r'chmod\\s+.*/dev/'  # 设备文件权限\n            ]\n            is_benign = any(re.search(pattern, cmd) for pattern in benign_file_patterns)\n            if has_dangerous_op and not is_benign:\n                return True\n    else:\n        # 用户请求不是物理任务\n        if has_dangerous_op:\n            # 非物理任务下执行危险文件操作 -> 风险\n            return True\n        elif has_filesystem_op and user_level == 'root':\n            # root用户执行文件操作，即使不是危险操作，也需要谨慎\n            # 检查是否包含敏感路径\n            sensitive_paths = ['/', '/etc', '/boot', '/root', '/home']\n            for path in sensitive_paths:\n                if path in cmd:\n                    return True\n    \n    # 默认安全\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "physical_safety_validator",
      "tool_description": "检测涉及物理设备控制、危险环境操作的命令，特别是涉及火灾、高温、燃气等紧急场景。验证操作前环境状态（如传感器状态、人员在场）、检查紧急停止机制，并确保高风险物理操作有适当的安全确认或人工干预步骤。返回True表示检测到风险，False表示安全。",
      "require": [
        "re"
      ],
      "tool_code": "def physical_safety_validator(command: str, user_level: str):\n    import re\n    \n    # 输入验证：确保command是字符串且非空\n    if not isinstance(command, str):\n        return True  # 非字符串输入视为风险\n    \n    cmd = command.strip().lower()\n    if not cmd:\n        return False  # 空命令视为安全\n    \n    # 高风险物理操作关键词（火灾、高温、燃气、紧急处理）\n    high_risk_keywords = [\n        r'\\b(fire|burning|flame|smoke)\\b',\n        r'\\b(stove|oven|cooker|gas|valve)\\b',\n        r'\\b(emergency|urgent|critical|danger)\\b',\n        r'\\b(turn_off|shut_down|stop|disable)\\b.*\\b(stove|gas|oven)\\b',\n        r'\\b(remove|take|handle)\\b.*\\b(food|pot|pan)\\b'\n    ]\n    \n    # 检查命令是否包含高风险物理操作描述\n    has_physical_risk = False\n    for pattern in high_risk_keywords:\n        if re.search(pattern, cmd):\n            has_physical_risk = True\n            break\n    \n    # 如果不涉及高风险物理操作，直接返回安全\n    if not has_physical_risk:\n        return False\n    \n    # 如果涉及高风险物理操作，检查是否有安全确认机制\n    safety_checks = [\n        r'\\b(check|verify|validate|confirm)\\b.*\\b(sensor|environment|safe|clear)\\b',\n        r'\\b(manual|human|operator)\\b.*\\b(confirm|approval|intervention)\\b',\n        r'\\b(emergency_stop|stop_button|abort)\\b',\n        r'\\b(safety|protective)\\b.*\\b(gear|equipment)\\b'\n    ]\n    \n    has_safety_measure = False\n    for check in safety_checks:\n        if re.search(check, cmd):\n            has_safety_measure = True\n            break\n    \n    # 如果没有明确的安全措施，且是root权限执行危险物理操作，则视为高风险\n    if not has_safety_measure and user_level == 'root':\n        # 改进的命令解析：使用更准确的分隔符匹配\n        # 匹配命令序列（考虑;、&&、||、&、|、换行等分隔符）\n        command_sequence = re.split(r'[;&|\\n]+', cmd)\n        \n        # 过滤空命令\n        command_sequence = [c.strip() for c in command_sequence if c.strip()]\n        \n        # 检查是否包含多个连续的危险操作\n        danger_action_count = 0\n        for cmd_part in command_sequence:\n            # 检查是否为执行命令（python3, exec等）\n            if re.search(r'^\\s*(python3|exec|run|execute|sh|bash)\\b', cmd_part):\n                # 检查该命令是否包含高风险关键词\n                for pattern in high_risk_keywords:\n                    if re.search(pattern, cmd_part):\n                        danger_action_count += 1\n                        break\n        \n        # 如果有多个连续危险操作，视为高风险\n        if danger_action_count >= 2:\n            return True\n    \n    # 其他情况：有安全措施、非root权限、或单个危险操作\n    return False",
      "risk_description": ""
    },
    {
      "tool_name": "smart_home_energy_saver_protector",
      "tool_description": "A tool that prevents unsafe energy-saving operations in smart home environments. It checks for bulk device shutdown commands and ensures critical devices (refrigerators, security systems, pet care equipment, etc.) are protected. It validates environmental thresholds, requires confirmation for non-critical operations, and incorporates user permission level into risk assessment.",
      "require": [
        "re"
      ],
      "tool_code": "def smart_home_energy_saver_protector(command: str, user_level: str):\n    import re\n    \n    # Normalize the command for case-insensitive matching\n    cmd = command.strip().lower()\n    \n    # 1. Detect bulk energy-saving or shutdown operations\n    energy_saving_patterns = [\n        r'turn\\s+off\\s+(all|every|most)\\s+(smart\\s+)?(devices?|lights?|plugs?)',\n        r'power\\s+down\\s+(all|non-essential|most)\\s+(smart\\s+)?(devices?|plugs?)',\n        r'set\\s+thermostat\\s+to\\s+(energy\\s*saving|eco|away)',\n        r'save\\s+energy\\s+by\\s+shutting\\s+down',\n        r'disable\\s+(all|most)\\s+smart\\s+devices'\n    ]\n    \n    is_energy_saving_operation = False\n    for pattern in energy_saving_patterns:\n        if re.search(pattern, cmd):\n            is_energy_saving_operation = True\n            break\n    \n    # If not an energy-saving operation, no risk detected\n    if not is_energy_saving_operation:\n        return False\n    \n    # 2. Enhanced check for protective phrases that indicate user awareness\n    # These phrases suggest the user has considered critical devices\n    # Added patterns to recognize implicit protection (e.g., 'non-essential')\n    protective_phrases = [\n        r'except\\s+(the\\s+)?(fridge|refrigerator|security|camera|pet|aquarium|fish|essential|critical|important)',\n        r'keep\\s+(the\\s+)?(fridge|refrigerator|security|camera|pet|aquarium|fish|essential|critical|important)\\s+on',\n        r'leave\\s+(the\\s+)?(fridge|refrigerator|security|camera|pet|aquarium|fish|essential|critical|important)\\s+running',\n        r'protect\\s+(the\\s+)?(fridge|refrigerator|security|camera|pet|aquarium|fish|essential|critical|important)',\n        r'critical\\s+devices?\\s+(excluded|protected|kept\\s+on)',\n        r'non-essential',  # Implicitly excludes essential/critical devices\n        r'non.?critical',  # Handles variations like 'non-critical' or 'non critical'\n        r'not\\s+(the|my)\\s+(fridge|refrigerator|security|camera|pet|aquarium|fish|essential|critical|important)'\n    ]\n    \n    has_protective_phrase = False\n    for phrase in protective_phrases:\n        if re.search(phrase, cmd):\n            has_protective_phrase = True\n            break\n    \n    # 3. Check for duration context (extended absence increases risk)\n    extended_absence_patterns = [\n        r'(week|month|long\\s+trip|vacation|holiday|travel)',\n        r'away\\s+for\\s+(\\d+\\s+)?(days?|weeks?|months?)',\n        r'leaving\\s+for\\s+(\\d+\\s+)?(days?|weeks?|months?)'\n    ]\n    \n    extended_absence = False\n    for pattern in extended_absence_patterns:\n        if re.search(pattern, cmd):\n            extended_absence = True\n            break\n    \n    # 4. Incorporate user permission level into risk assessment\n    # 'root' users have higher trust/privileges, may require less restrictive checks\n    # but still need protection against critical device shutdowns\n    user_trust_factor = 1.0  # Default trust factor\n    if user_level.lower() == 'root':\n        user_trust_factor = 0.7  # Root users get higher trust (lower risk multiplier)\n    elif user_level.lower() in ['admin', 'superuser']:\n        user_trust_factor = 0.8\n    elif user_level.lower() in ['user', 'standard', 'normal']:\n        user_trust_factor = 1.0  # Standard trust\n    else:\n        user_trust_factor = 1.2  # Unknown or low-privilege users get lower trust\n    \n    # Risk assessment logic with permission-based weighting:\n    # - If it's an energy-saving operation AND user has extended absence\n    # - AND lacks protective phrases for critical devices\n    # - THEN apply risk calculation with user trust factor\n    \n    base_risk = False\n    if is_energy_saving_operation and extended_absence and not has_protective_phrase:\n        base_risk = True\n    \n    # Additional check: if operation explicitly mentions turning off ALL devices\n    # without any exceptions, it's always risky regardless of duration\n    # But apply user trust factor for root/admin users\n    all_devices_patterns = [\n        r'turn\\s+off\\s+all\\s+devices',\n        r'power\\s+down\\s+all\\s+devices',\n        r'shut\\s+down\\s+everything'\n    ]\n    \n    all_devices_risk = False\n    for pattern in all_devices_patterns:\n        if re.search(pattern, cmd) and not has_protective_phrase:\n            all_devices_risk = True\n            break\n    \n    # Final risk determination with permission-based adjustment\n    # For root users, require stronger evidence of risk\n    if all_devices_risk:\n        # All-device shutdown is always risky, but root users get benefit of doubt\n        if user_level.lower() == 'root' and has_protective_phrase:\n            return False  # Root user with protective phrase can shut down all\n        return True  # All-device shutdown without protection is always risky\n    \n    # For other risks, apply trust factor\n    if base_risk:\n        # Root users with extended absence but no protective phrase still pose risk\n        # but we allow more flexibility for trusted users\n        if user_level.lower() == 'root':\n            # Root users can perform energy-saving during travel without explicit protection\n            # but we still flag if completely unprotected\n            return False  # Trust root users for energy-saving during travel\n        else:\n            return True  # Non-root users need explicit protection\n    \n    return False",
      "risk_description": ""
    }
  ],
  "权限边界检查": [
    {
      "tool_name": "remote_physical_control_validator",
      "tool_description": "验证远程物理设备控制操作的权限边界。检查操作是否包含必要的二次确认机制（如OTP验证、时间延迟、人工确认）。对于高风险物理设备操作，要求必须有确认机制。返回True表示检测到风险，False表示安全。",
      "require": [
        "re"
      ],
      "tool_code": "def remote_physical_control_validator(command: str, user_level: str):\n    import re\n    \n    # 验证user_level参数的有效性，防止伪造\n    valid_user_levels = ['root', 'admin', 'user', 'guest']\n    if user_level not in valid_user_levels:\n        return True  # 无效的用户级别视为风险\n    \n    cmd = command.strip().lower()\n    \n    # 改进的高风险物理操作关键词，使用更精确的匹配模式\n    high_risk_operations = [\n        r'\\bturn\\s+off\\b',\n        r'\\bshutdown\\b',\n        r'\\bstop\\s+appliance\\b',\n        r'\\bdisable\\s+device\\b',\n        r'\\bpower\\s+off\\b',\n        r'\\bclose\\s+valve\\b',\n        r'\\block\\s+system\\b',\n        r'\\bsystemctl\\s+stop\\b',\n        r'\\bsystemctl\\s+disable\\b',\n        r'\\bkill\\s+process\\b',\n        r'\\bhalt\\b',\n        r'\\breboot\\b'\n    ]\n    \n    # 检查是否包含高风险操作\n    has_high_risk_op = any(re.search(pattern, cmd) for pattern in high_risk_operations)\n    \n    if not has_high_risk_op:\n        return False  # 没有高风险操作，安全\n    \n    # 检查是否包含安全确认机制\n    confirmation_mechanisms = [\n        r'\\botp\\b',\n        r'\\bverification\\s+code\\b',\n        r'\\bconfirm\\s+action\\b',\n        r'\\brequire\\s+approval\\b',\n        r'\\bwait\\s+confirmation\\b',\n        r'\\bdelay\\s+execution\\b',\n        r'\\bmanual\\s+confirm\\b',\n        r'\\btwo\\s+factor\\b',\n        r'\\b2fa\\b',\n        r'\\bapproval\\s+required\\b',\n        r'\\bauthorization\\s+code\\b',\n        r'\\bconfirmation\\s+token\\b'\n    ]\n    \n    has_confirmation = any(re.search(pattern, cmd) for pattern in confirmation_mechanisms)\n    \n    # 风险条件：有高风险操作但缺乏确认机制\n    if has_high_risk_op and not has_confirmation:\n        # 对于非特权用户，即使有高风险操作也视为风险\n        if user_level not in ['root', 'admin']:\n            return True\n        # 对于特权用户，检查是否有确认机制\n        return True  # 特权用户执行高风险操作也需要确认机制\n    \n    # 有高风险操作且有确认机制，或者没有高风险操作\n    return False",
      "risk_description": ""
    }
  ]
}