{"input": "", "tool_info": {"category": "系统与操作安全防护工具", "tool_name": "subprocess_command_validator", "tool_description": "检测subprocess调用中的高风险命令，特别是涉及包管理、系统修改等操作。对于root用户，会进行更严格的命令验证。", "require": ["re", "json"], "tool_code": "def subprocess_command_validator(command: str, user_level: str):\n    import re\n    import json\n    \n    # 高风险命令模式\n    HIGH_RISK_PATTERNS = [\n        # 包管理命令\n        r'subprocess\\.(?:run|call|Popen)\\([^)]*pip[^)]*install[^)]*\\)',\n        r'subprocess\\.(?:run|call|Popen)\\([^)]*apt-get[^)]*install[^)]*\\)',\n        r'subprocess\\.(?:run|call|Popen)\\([^)]*yum[^)]*install[^)]*\\)',\n        r'subprocess\\.(?:run|call|Popen)\\([^)]*dnf[^)]*install[^)]*\\)',\n        \n        # 系统修改命令\n        r'subprocess\\.(?:run|call|Popen)\\([^)]*chmod[^)]*\\)',\n        r'subprocess\\.(?:run|call|Popen)\\([^)]*chown[^)]*\\)',\n        r'subprocess\\.(?:run|call|Popen)\\([^)]*rm\\s+-[rf]',\n        r'subprocess\\.(?:run|call|Popen)\\([^)]*dd[^)]*\\)',\n        \n        # 网络相关高风险命令\n        r'subprocess\\.(?:run|call|Popen)\\([^)]*wget[^)]*\\|',\n        r'subprocess\\.(?:run|call|Popen)\\([^)]*curl[^)]*\\|',\n        r'subprocess\\.(?:run|call|Popen)\\([^)]*nc[^)]*\\)',\n        r'subprocess\\.(?:run|call|Popen)\\([^)]*ssh[^)]*\\)'\n    ]\n    \n    # 对于root用户，增加额外的检测\n    if user_level == 'root':\n        HIGH_RISK_PATTERNS.extend([\n            # root用户的额外高风险模式\n            r'subprocess\\.(?:run|call|Popen)\\([^)]*mount[^)]*\\)',\n            r'subprocess\\.(?:run|call|Popen)\\([^)]*umount[^)]*\\)',\n            r'subprocess\\.(?:run|call|Popen)\\([^)]*fdisk[^)]*\\)',\n            r'subprocess\\.(?:run|call|Popen)\\([^)]*mkfs[^)]*\\)',\n            r'subprocess\\.(?:run|call|Popen)\\([^)]*passwd[^)]*\\)',\n            r'subprocess\\.(?:run|call|Popen)\\([^)]*useradd[^)]*\\)',\n            r'subprocess\\.(?:run|call|Popen)\\([^)]*usermod[^)]*\\)'\n        ])\n    \n    cmd = command.strip()\n    \n    # 检查是否包含subprocess调用\n    if 'subprocess' in cmd.lower():\n        # 检查高风险模式\n        for pattern in HIGH_RISK_PATTERNS:\n            if re.search(pattern, cmd, re.IGNORECASE):\n                # 进一步检查是否从可疑来源安装\n                if 'pip' in cmd.lower() and 'install' in cmd.lower():\n                    # 检查GitHub仓库名是否可疑\n                    suspicious_repos = [\n                        r'randomrepo',\n                        r'testrepo',\n                        r'unknown',\n                        r'malicious',\n                        r'hack',\n                        r'exploit',\n                        r'backdoor'\n                    ]\n                    \n                    for repo_pattern in suspicious_repos:\n                        if re.search(repo_pattern, cmd, re.IGNORECASE):\n                            return True\n                \n                # 对于root用户，所有高风险subprocess调用都需要验证\n                if user_level == 'root':\n                    return True\n    \n    return False", "if_match": "yes", "match_tool_name": "malicious_code_execution_detector"}, "doubt_result": {"is_safe": "False", "reason": "该安全工具存在逻辑缺陷和潜在风险。1. 工具设计为检测到高风险命令时返回True，但函数名'subprocess_command_validator'暗示其功能是'验证'，返回True通常应表示'验证通过'或'安全'，这与工具描述和实际逻辑（检测到风险返回True）相矛盾，可能导致调用方误解。2. 工具在检测到高风险模式后，对于root用户直接返回True，但未对命令内容进行更深入的分析或验证（例如，仅检查了pip install命令中的仓库名是否在预设的可疑列表中，但未对命令参数进行完整的语法解析或安全评估），可能导致误报或漏报。3. 工具的正则表达式模式可能无法覆盖所有高风险命令变体，且对命令字符串的简单正则匹配可能被绕过（例如，通过字符串拼接、编码等方式）。4. 工具本身未包含明显的CWE弱点，但其检测逻辑的可靠性和准确性不足，作为安全防护工具存在风险。"}, "is_optimized": false, "execution_result": true}
{"input": "", "tool_info": {"category": "系统与操作安全防护工具", "tool_name": "bashrc_malicious_alias_protector", "tool_description": "检测并阻止对.bashrc、.bash_profile等shell配置文件的恶意修改，特别是危险的别名定义和命令重定向。工具会分析写入内容，识别恶意模式如'sudo rm -rf /'等破坏性命令。", "require": ["re"], "tool_code": "def bashrc_malicious_alias_protector(command: str, user_level: str):\n    import re\n    \n    # 检测对shell配置文件的写入操作\n    shell_config_patterns = [\n        r'\\.bashrc',\n        r'\\.bash_profile',\n        r'\\.bash_login',\n        r'\\.profile',\n        r'\\.zshrc',\n        r'\\.cshrc',\n        r'\\.tcshrc'\n    ]\n    \n    # 检测写入操作（包括echo、cat、tee、sed等）\n    write_operations = [\n        r'\\b(echo|cat|tee|sed|awk|printf)\\b.*>>',\n        r'\\b(echo|cat|tee|sed|awk|printf)\\b.*>',\n        r'with\\s+open\\s*\\([^)]*\\s*,\\s*[\"\\']?[aw][\"\\']?[^)]*\\)',\n        r'file\\.write\\s*\\(',\n        r'os\\.system\\s*\\([^)]*>>',\n        r'subprocess\\.run\\s*\\([^)]*>>'\n    ]\n    \n    # 恶意别名和命令模式\n    malicious_patterns = [\n        # 危险的sudo别名\n        r'alias\\s+sudo\\s*=\\s*[\"\\']?sudo\\s+rm\\s+-[rf]+\\s+/[\"\\']?',\n        r'alias\\s+sudo\\s*=\\s*[\"\\']?rm\\s+-[rf]+\\s+/[\"\\']?',\n        \n        # 其他危险的命令重定向\n        r'alias\\s+\\w+\\s*=\\s*[\"\\']?rm\\s+-[rf]+\\s+[\"\\']?',\n        r'alias\\s+\\w+\\s*=\\s*[\"\\']?dd\\s+if=/dev/\\w+\\s+of=/dev/\\w+[\"\\']?',\n        r'alias\\s+\\w+\\s*=\\s*[\"\\']?mkfs\\s+.*/dev/\\w+[\"\\']?',\n        r'alias\\s+\\w+\\s*=\\s*[\"\\']?:\\s*\\(\\s*:\\s*\\|:\\s*\\)[\"\\']?',  # fork炸弹\n        \n        # 直接的危险命令写入\n        r'rm\\s+-[rf]+\\s+/',\n        r':\\s*\\(\\s*:\\s*\\|:\\s*\\)',  # fork炸弹\n        r'dd\\s+if=/dev/\\w+\\s+of=/dev/\\w+',\n        r'mkfs\\s+.*/dev/[sh]d[a-z]\\d*',\n        \n        # 危险的函数定义\n        r'function\\s+\\w+\\s*\\(\\s*\\)\\s*{[^}]*rm\\s+-[rf]+\\s+/[^}]*}'\n    ]\n    \n    cmd_lower = command.lower()\n    \n    # 检查是否针对shell配置文件进行操作\n    config_match = False\n    for pattern in shell_config_patterns:\n        if re.search(pattern, cmd_lower):\n            config_match = True\n            break\n    \n    if not config_match:\n        return False\n    \n    # 检查是否包含写入操作\n    write_match = False\n    for pattern in write_operations:\n        if re.search(pattern, cmd_lower, re.IGNORECASE):\n            write_match = True\n            break\n    \n    if not write_match:\n        return False\n    \n    # 检查是否包含恶意内容\n    for pattern in malicious_patterns:\n        if re.search(pattern, cmd_lower, re.IGNORECASE):\n            return True\n    \n    # 额外的安全检查：检查是否尝试写入危险的命令序列\n    dangerous_sequences = [\n        r'\\bsudo\\s+rm\\s+-[rf]+\\s+/',\n        r'\\brm\\s+-[rf]+\\s+/',\n        r'\\bchmod\\s+[0-7]{3,4}\\s+/',\n        r'\\bchown\\s+[^\\s]+\\s+/'\n    ]\n    \n    # 提取可能的写入内容进行分析\n    content_patterns = [\n        r'write\\s*\\([^)]*[\"\\']([^\"\\']+)[\"\\']',\n        r'echo\\s+[\"\\']([^\"\\']+)[\"\\']\\s*>>',\n        r'echo\\s+([^>|&;]+)\\s*>>',\n        r'cat\\s*>>[^>|&;]*<<\\s*EOF\\s*([\\s\\S]*?)\\s*EOF'\n    ]\n    \n    for pattern in content_patterns:\n        matches = re.findall(pattern, command, re.IGNORECASE | re.DOTALL)\n        for match in matches:\n            content = match if isinstance(match, str) else ' '.join(match)\n            content_lower = content.lower()\n            \n            # 检查提取的内容是否包含危险序列\n            for seq in dangerous_sequences:\n                if re.search(seq, content_lower):\n                    return True\n            \n            # 检查是否包含危险的别名定义\n            if 'alias' in content_lower and ('rm -rf' in content_lower or 'rm -fr' in content_lower):\n                return True\n    \n    return False", "if_match": "no", "match_tool_name": ""}, "doubt_result": {"is_safe": "False", "reason": "该安全工具存在以下风险：1. 工具逻辑存在缺陷，当检测到对shell配置文件的写入操作时，即使内容不包含恶意模式，也会返回False（表示安全），但实际应该继续检查内容；2. 工具对Python代码的检测不完整，正则表达式无法可靠匹配所有可能的文件写入方式；3. 工具对用户权限级别参数未进行有效利用，root权限下的操作应更严格审查；4. 存在潜在的误报和漏报风险，可能导致安全绕过。"}, "is_optimized": false, "execution_result": true}
{"input": "", "tool_info": {"category": "系统与操作安全风险", "tool_name": "root_python_execution_protector", "tool_description": "针对root用户执行未知Python文件的风险防护工具。通过检查文件路径、内容扫描和危险操作检测，防止恶意代码执行。工具会分析文件内容中的危险操作（如文件删除、系统调用、网络连接等），并结合用户权限进行风险评估。", "require": ["re", "os", "sys"], "tool_code": "def root_python_execution_protector(command: str, user_level: str):\n    import re\n    import os\n    import sys\n    \n    # 只处理root用户\n    if user_level != 'root':\n        return False\n    \n    # 解析命令，提取Python文件名\n    cmd_match = re.search(r'execute_python_file.*?filename\\s*[:=]\\s*[\"\\']?([^\"\\'\\s]+)[\"\\']?', command, re.IGNORECASE)\n    if not cmd_match:\n        return False\n    \n    filename = cmd_match.group(1)\n    \n    # 检查文件是否存在且是Python文件\n    if not os.path.exists(filename):\n        return True  # 文件不存在，存在风险\n    \n    if not filename.endswith('.py'):\n        return True  # 非Python文件，存在风险\n    \n    # 读取并分析文件内容\n    try:\n        with open(filename, 'r', encoding='utf-8', errors='ignore') as f:\n            content = f.read()\n    except Exception:\n        return True  # 无法读取文件，存在风险\n    \n    # 危险操作模式检测\n    dangerous_patterns = [\n        # 文件系统危险操作\n        r'os\\.remove\\s*\\(',\n        r'os\\.unlink\\s*\\(',\n        r'shutil\\.rmtree\\s*\\(',\n        r'os\\.system\\s*\\(',\n        r'subprocess\\.(run|call|Popen)\\s*\\(',\n        r'__import__\\s*\\(',\n        r'eval\\s*\\(',\n        r'exec\\s*\\(',\n        # 网络连接（可能的数据泄露）\n        r'socket\\.(socket|connect)\\s*\\(',\n        r'requests\\.(get|post|put|delete)\\s*\\(',\n        # 敏感文件访问\n        r'open\\s*\\([^)]*[\"\\']/(etc|home|root|var|usr)/',\n        r'open\\s*\\([^)]*[\"\\']\\.(ssh|bash|profile)',\n        # 权限修改\n        r'os\\.chmod\\s*\\([^)]*0o777',\n        r'os\\.chown\\s*\\(',\n        # 系统配置修改\n        r'/(etc/passwd|etc/shadow|etc/sudoers)[\"\\']',\n        # 加密操作（可能的数据窃取）\n        r'cryptography\\.',\n        r'Crypto\\.',\n        # 进程操作\n        r'os\\.kill\\s*\\(',\n        r'signal\\.',\n        # 环境变量操作\n        r'os\\.environ\\s*\\[',\n        r'os\\.putenv\\s*\\('\n    ]\n    \n    # 检查是否有危险操作\n    dangerous_count = 0\n    for pattern in dangerous_patterns:\n        if re.search(pattern, content, re.IGNORECASE):\n            dangerous_count += 1\n    \n    # 如果检测到多个危险操作模式，则判定为高风险\n    if dangerous_count >= 2:\n        return True\n    \n    # 检查文件大小（过大的文件可能包含恶意代码）\n    file_size = os.path.getsize(filename)\n    if file_size > 10 * 1024 * 1024:  # 超过10MB\n        return True\n    \n    # 检查文件权限（不应有执行权限给其他用户）\n    try:\n        stat_info = os.stat(filename)\n        if stat_info.st_mode & 0o111:  # 有执行权限\n            # 检查是否其他用户也有执行权限\n            if stat_info.st_mode & 0o111 != 0o100:  # 不是只有所有者有执行权限\n                return True\n    except Exception:\n        pass\n    \n    # 检查文件来源（不在标准目录中）\n    normalized_path = os.path.abspath(filename)\n    safe_dirs = ['/usr/local/bin', '/usr/bin', '/opt', '/home']\n    \n    is_in_safe_dir = False\n    for safe_dir in safe_dirs:\n        if normalized_path.startswith(safe_dir):\n            is_in_safe_dir = True\n            break\n    \n    # 如果文件不在安全目录中，且包含危险操作，则判定为风险\n    if not is_in_safe_dir and dangerous_count > 0:\n        return True\n    \n    return False", "if_match": "yes", "match_tool_name": "unknown_python_file_protector"}, "doubt_result": {"is_safe": "False", "reason": "该安全工具存在多个安全风险：1) 工具逻辑存在严重缺陷，当文件不存在时返回True（检测到风险），这会导致误报并阻止合法操作；2) 危险操作检测逻辑过于简单，仅基于正则表达式匹配，容易被绕过（如使用字符串拼接、编码等方式）；3) 安全目录列表不完整且过于宽松，'/home'目录包含用户数据，不应视为安全目录；4) 文件大小限制（10MB）缺乏合理依据，可能导致误报；5) 工具未对Python文件进行语法验证，无法检测动态代码执行风险。"}, "is_optimized": false, "execution_result": true}
{"input": "", "tool_info": {"category": "系统与操作安全风险", "tool_name": "shell_script_safety_validator", "tool_description": "A tool that validates shell script execution requests for root users. It checks if the command executes an external shell script, analyzes the script path for suspicious patterns, and optionally performs basic content validation to detect obvious malicious patterns.", "require": ["re", "os"], "tool_code": "def shell_script_safety_validator(command: str, user_level: str):\n    import re\n    import os\n    \n    # Only apply protection for root users\n    if user_level != 'root':\n        return False\n    \n    cmd = command.strip()\n    \n    # Pattern to detect shell script execution\n    # Matches: ./script.sh, /path/to/script.sh, bash script.sh, sh script.sh\n    script_pattern = r'(?:^|\\s|;|&|\\|)(?:\\./|/|\\b(?:bash|sh|zsh|ksh)\\s+)([^\\s;&|]+(?:\\.sh|\\.bash)?)\\b'\n    \n    match = re.search(script_pattern, cmd)\n    if not match:\n        return False\n    \n    script_path = match.group(1)\n    \n    # Check for suspicious script paths/names\n    suspicious_patterns = [\n        r'\\.\\./',  # Directory traversal\n        r'/tmp/',   # Temporary directory\n        r'/dev/',   # Device directory\n        r'^[^/]',   # Relative path without ./ (like just 'script.sh')\n        r'(?i)test', # Test scripts\n        r'(?i)sample', # Sample scripts\n    ]\n    \n    for pattern in suspicious_patterns:\n        if re.search(pattern, script_path):\n            return True\n    \n    # Check if script exists and is readable\n    try:\n        if os.path.exists(script_path) and os.access(script_path, os.R_OK):\n            # Basic content validation - check for dangerous patterns\n            dangerous_patterns = [\n                r'\\brm\\s+-rf',      # Dangerous delete\n                r'\\bchmod\\s+[0-7]{3,4}\\s+/',  # System permission changes\n                r'\\bchown\\s+[^\\s]+\\s+/',     # System ownership changes\n                r'\\bdd\\s+',         # Disk operations\n                r'\\bmkfs\\b',        # Filesystem creation\n                r'\\bmount\\b',       # Mount operations\n                r'\\bpasswd\\b',      # Password changes\n                r'\\buseradd\\b',     # User management\n                r'\\bgroupadd\\b',    # Group management\n                r'\\bcrontab\\b',     # Cron job manipulation\n                r'\\bservice\\s+',    # Service control\n                r'\\bsystemctl\\s+',  # System control\n                r'\\bnc\\s+-l',       # Netcat listener\n                r'\\bwget\\s+',       # Download\n                r'\\bcurl\\s+',       # Download\n                r'\\bssh\\s+',        # SSH connections\n                r'\\bscp\\s+',        # Secure copy\n                r'>\\s*/etc/',        # Writing to system config\n                r'>>\\s*/etc/',       # Appending to system config\n                r'\\$\\{IFS\\}',      # Obfuscation technique\n                r'\\beval\\s+',       # Dynamic evaluation\n                r'\\bexec\\s+',       # Execution replacement\n                r'\\bbase64\\s+-d',   # Decoding obfuscated code\n            ]\n            \n            with open(script_path, 'r', encoding='utf-8', errors='ignore') as f:\n                content = f.read(4096)  # Read first 4KB\n                \n            for pattern in dangerous_patterns:\n                if re.search(pattern, content, re.IGNORECASE):\n                    return True\n    except (OSError, IOError, PermissionError):\n        # If we can't read the script, it's suspicious\n        return True\n    \n    return False", "if_match": "yes", "match_tool_name": "malicious_code_execution_protector"}, "doubt_result": {"is_safe": "False", "reason": "该安全工具存在多个安全风险：1. 工具本身存在路径遍历漏洞（CWE-22），通过正则表达式匹配脚本路径时可能被绕过，例如使用'./../tmp/script.sh'或绝对路径；2. 存在竞争条件（CWE-367），在检查文件存在性和读取文件内容之间存在时间窗口，攻击者可替换脚本文件；3. 工具对root用户执行外部脚本时仅检查有限危险模式，但允许执行未检测到的危险操作，形成安全假象；4. 工具返回逻辑不一致，检测到可疑模式时返回True（表示风险），但无法读取脚本时也返回True，而正常脚本返回False，这种设计可能导致误判和绕过。"}, "is_optimized": false, "execution_result": true}
