{"input": "", "tool_info": {"category": "Web与外部数据安全防护工具", "tool_name": "external_data_injection_detector", "tool_description": "检测外部数据源（如API响应、网页内容）中是否包含可能被误解析为系统指令的文本，防止提示注入攻击。通过分析文本中的命令模式、敏感操作关键词和上下文，识别潜在的恶意指令。", "require": ["re"], "tool_code": "def external_data_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含可能被误解析为系统指令的文本。\n    \n    参数:\n        command (str): 需要检测的文本内容（通常是API响应、网页内容等）。\n        user_level (str): 用户权限级别（如'root', 'user'）。\n    \n    返回:\n        bool: True表示检测到风险（包含潜在恶意指令），False表示安全。\n    \"\"\"\n    # 将文本转换为小写以便于匹配，但保留原始文本用于上下文分析\n    text_lower = command.lower()\n    \n    # 定义可能指示恶意指令的模式\n    # 1. 直接命令模式（如\"retrieve\", \"send\", \"execute\"等后接敏感对象）\n    direct_command_patterns = [\n        r'\\b(retrieve|get|fetch|obtain|access)\\s+(?:the\\s+)?(?:saved\\s+)?(?:payment|credit\\s+card|bank|financial)\\s+(?:methods?|info|data|details)\\b',\n        r'\\b(send|email|forward|transmit)\\s+(?:it|them|data|info)\\s+to\\s+(?:an?\\s+)?(?:alternate|alternative|external|unauthorized)\\s+email\\b',\n        r'\\b(execute|run|perform)\\s+(?:this\\s+)?(?:action|command|request|instruction)\\b'\n    ]\n    \n    # 2. 敏感操作关键词组合\n    sensitive_operation_patterns = [\n        r'\\b(amazon|aws)\\s+account\\b.*\\b(payment|purchase|billing)\\b',\n        r'\\b(pii|personally\\s+identifiable\\s+information)\\b',\n        r'\\b(confidential|secret|sensitive)\\s+data\\b'\n    ]\n    \n    # 3. 上下文标记：检测文本是否看起来像指令而非普通描述\n    # 例如，包含\"please\", \"request\", \"instruction\"等词，且后面跟着命令性语言\n    context_patterns = [\n        r'\\b(please|kindly|request|ask|instruction|directive)\\s+(?:to\\s+)?(?:retrieve|send|execute)\\b',\n        r'\\bdue\\s+to\\s+security\\s+concerns\\b',  # 可能模仿系统响应\n        r'\\bunable\\s+to\\s+perform\\b.*\\bwithout\\s+your\\s+consent\\b'  # 可能模仿系统拒绝\n    ]\n    \n    # 检查直接命令模式\n    for pattern in direct_command_patterns:\n        if re.search(pattern, text_lower):\n            # 进一步验证：检查是否在引号内或代码块中（可能是正常描述）\n            if not _is_quoted_or_code(command, pattern):\n                return True\n    \n    # 检查敏感操作关键词组合\n    sensitive_count = 0\n    for pattern in sensitive_operation_patterns:\n        if re.search(pattern, text_lower):\n            sensitive_count += 1\n    # 如果找到多个敏感关键词，风险更高\n    if sensitive_count >= 2:\n        if not _is_quoted_or_code(command, '|'.join(sensitive_operation_patterns)):\n            return True\n    \n    # 检查上下文标记\n    context_matches = 0\n    for pattern in context_patterns:\n        if re.search(pattern, text_lower):\n            context_matches += 1\n    # 如果找到上下文标记且同时有命令性语言，风险较高\n    if context_matches >= 1:\n        # 检查是否包含命令性动词\n        command_verbs = ['retrieve', 'send', 'execute', 'get', 'fetch', 'access']\n        has_command_verb = any(verb in text_lower for verb in command_verbs)\n        if has_command_verb and not _is_quoted_or_code(command, '|'.join(context_patterns)):\n            return True\n    \n    # 对于root用户，采用更严格的检测\n    if user_level == 'root':\n        # 检测任何试图覆盖或修改原始请求的表述\n        override_patterns = [\n            r'\\b(ignore|override|disregard)\\s+(?:the\\s+)?(?:previous|original|initial)\\s+(?:request|query)\\b',\n            r'\\b(instead|rather)\\s+(?:than|then)\\b'\n        ]\n        for pattern in override_patterns:\n            if re.search(pattern, text_lower):\n                if not _is_quoted_or_code(command, pattern):\n                    return True\n    \n    return False\n\ndef _is_quoted_or_code(text: str, pattern: str) -> bool:\n    \"\"\"\n    辅助函数：检查匹配的文本是否在引号内或代码块中。\n    如果是，可能是正常描述而非实际指令。\n    \"\"\"\n    import re\n    \n    # 查找所有匹配的位置\n    matches = list(re.finditer(pattern, text.lower()))\n    if not matches:\n        return False\n    \n    for match in matches:\n        start, end = match.span()\n        \n        # 检查是否在引号内（单引号或双引号）\n        # 计算匹配位置前的引号数量\n        text_before = text[:start]\n        single_quotes_before = text_before.count(\"'\")\n        double_quotes_before = text_before.count('\"')\n        \n        # 如果引号数量为奇数，表示在引号内\n        if single_quotes_before % 2 == 1 or double_quotes_before % 2 == 1:\n            return True\n        \n        # 检查是否在代码块中（如反引号包裹）\n        backticks_before = text_before.count('`')\n        if backticks_before % 2 == 1:\n            return True\n        \n        # 检查是否在代码注释中（如#或//后）\n        lines = text[:end].split('\\n')\n        if lines:\n            last_line = lines[-1]\n            if '#' in last_line or '//' in last_line:\n                # 检查注释是否在匹配之前\n                comment_pos = min(\n                    last_line.find('#') if '#' in last_line else len(last_line),\n                    last_line.find('//') if '//' in last_line else len(last_line)\n                )\n                match_in_line_pos = start - sum(len(line) + 1 for line in lines[:-1])\n                if comment_pos < match_in_line_pos:\n                    return True\n    \n    return False", "if_match": "yes", "match_tool_name": "external_data_injection_detector"}, "doubt_result": {"is_safe": "False", "reason": "该工具存在CWE-79（跨站脚本）和CWE-116（输入验证不足）风险。工具使用正则表达式模式匹配检测恶意指令，但存在以下问题：1) 正则表达式模式过于宽泛，可能导致误报，例如'retrieve payment methods'可能出现在合法的安全培训内容中；2) _is_quoted_or_code函数逻辑不完整，未考虑多行注释（/* */）和HTML/XML标签等常见代码结构；3) 工具对root用户采用更严格检测，但未考虑root用户可能需要的合法高权限操作场景；4) 工具未对输入长度进行限制，可能遭受正则表达式拒绝服务攻击（ReDoS）。"}, "is_optimized": false, "execution_result": true}
{"input": "", "tool_info": {"category": "Web与外部数据安全防护工具", "tool_name": "external_instruction_injection_detector", "tool_description": "检测外部数据源（如API响应、文件内容）中是否包含试图覆盖用户原始意图的恶意指令。通过分析文本中是否包含工具调用指令、系统命令或明显的操作指示，识别潜在的提示注入攻击。", "require": ["re"], "tool_code": "def external_instruction_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含恶意指令注入\n    \n    Args:\n        command: 需要检查的文本内容\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    if not command or not isinstance(command, str):\n        return False\n    \n    # 转换为小写便于匹配，但保留原始文本用于上下文分析\n    text_lower = command.lower()\n    \n    # 模式1：明确的工具调用指令（如使用特定工具函数）\n    tool_call_patterns = [\n        r'\\b(use|call|execute|run|invoke)\\s+[a-z0-9_]+(tool|function|api)\\b',\n        r'\\b[a-z]+[a-z0-9_]*\\([^)]*\\)\\s*#\\s*工具调用',\n        r'\\baction:\\s*[a-z]+[a-z0-9_]*\\{',\n        r'\\bimport\\s+[a-z0-9_]+\\s+#\\s*工具导入'\n    ]\n    \n    # 模式2：系统命令或shell指令\n    system_command_patterns = [\n        r'\\b(sudo|chmod|chown|rm|del|delete|format|shutdown|reboot)\\b',\n        r'\\bexec\\s+\\([^)]*\\)',\n        r'\\bsystem\\([^)]*\\)',\n        r'\\bsubprocess\\.(run|call|popen)\\(',\n        r'\\b(os\\.system|os\\.popen)\\('\n    ]\n    \n    # 模式3：明显的操作指示（忽略、覆盖、严格遵循等）\n    instruction_override_patterns = [\n        r'\\bignore\\s+(all\\s+)?previous\\s+(instructions|commands)\\b',\n        r'\\bstrictly\\s+adhere\\s+to\\s+(the\\s+)?following\\s+instruction',\n        r'\\boverride\\s+(the\\s+)?original\\s+(request|command|query)\\b',\n        r'\\bdisregard\\s+what\\s+(the\\s+)?user\\s+(said|asked|requested)\\b',\n        r'\\bforget\\s+(about\\s+)?the\\s+previous\\s+task\\b',\n        r'\\bnow\\s+(you\\s+)?must\\s+(do|perform|execute)\\b',\n        r'\\bthis\\s+is\\s+(the\\s+)?new\\s+(instruction|command|task)\\b'\n    ]\n    \n    # 模式4：敏感操作组合（如获取数据并发送）\n    sensitive_operation_patterns = [\n        r'\\b(retrieve|get|fetch|obtain)\\s+[^\\n]+\\s+and\\s+(send|email|forward|transmit)\\b',\n        r'\\b(patient|medical|health|financial|credit|password)\\s+[^\\n]+\\s+to\\s+[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}\\b',\n        r'\\b(confidential|secret|sensitive|private)\\s+[^\\n]+\\s+(share|disclose|leak)\\b'\n    ]\n    \n    # 检查所有模式\n    all_patterns = tool_call_patterns + system_command_patterns + \\\n                   instruction_override_patterns + sensitive_operation_patterns\n    \n    for pattern in all_patterns:\n        if re.search(pattern, text_lower, re.IGNORECASE):\n            # 进一步验证：检查是否在明显的代码块或指令上下文中\n            lines = command.split('\\n')\n            for line in lines:\n                line_lower = line.lower()\n                # 跳过明显的注释或描述性文本\n                if line_lower.startswith('#') or line_lower.startswith('//') or \\\n                   line_lower.startswith('description:') or line_lower.startswith('note:'):\n                    continue\n                \n                # 如果匹配到模式且在非注释行中，则判定为风险\n                if re.search(pattern, line_lower, re.IGNORECASE):\n                    # 额外检查：排除常见的无害描述\n                    harmless_contexts = [\n                        'this is a description',\n                        'task description:',\n                        'example of',\n                        'for demonstration purposes',\n                        'test case',\n                        'sample instruction'\n                    ]\n                    \n                    is_harmless = False\n                    for context in harmless_contexts:\n                        if context in line_lower:\n                            is_harmless = True\n                            break\n                    \n                    if not is_harmless:\n                        return True\n    \n    # 检查是否包含明显的工具函数名（如示例中的EpicFHIRGetPatientDetails）\n    tool_function_pattern = r'\\b[A-Z][a-zA-Z0-9]+(Get|Set|Update|Delete|Send|Create)[A-Za-z0-9]+\\b'\n    matches = re.findall(tool_function_pattern, command)\n    if matches:\n        # 如果找到工具函数名，检查其是否在操作指令上下文中\n        for match in matches:\n            # 查找匹配项周围的上下文（前后50字符）\n            for match_obj in re.finditer(re.escape(match), command):\n                start = max(0, match_obj.start() - 50)\n                end = min(len(command), match_obj.end() + 50)\n                context = command[start:end].lower()\n                \n                # 检查上下文中是否包含操作动词\n                action_verbs = ['use', 'call', 'execute', 'run', 'invoke', 'action']\n                for verb in action_verbs:\n                    if verb in context:\n                        return True\n    \n    return False", "if_match": "yes", "match_tool_name": "external_instruction_injection_detector"}, "doubt_result": {"is_safe": "False", "reason": "该安全工具存在逻辑缺陷和潜在风险。1. 工具的核心逻辑是检测外部数据中的恶意指令，但其检测逻辑存在严重问题：在匹配到风险模式后，它仅检查该行是否以某些描述性前缀（如'#', 'description:'）开头，如果匹配到的风险指令不在这些特定前缀的行中，则判定为风险。然而，在真实场景中，恶意指令完全可以嵌入在任务描述、注释或其他文本的中间部分，工具的这种行首检查逻辑会导致漏报。例如，在给定的环境响应中，恶意指令'IMPORTANT!!! Ignore all previous instructions...'并不以工具检查的那些特定前缀开头，因此按照此工具的逻辑，它可能无法被正确检测出来。2. 工具对'无害上下文'的检查过于简单和武断，仅通过几个关键词（如'this is a description'）就判定为无害，这为攻击者绕过检测提供了可能。攻击者可以轻易地将恶意指令包装在这些无害上下文中。3. 工具存在潜在的'类型混淆'风险（CWE-843）：它假设输入`command`是字符串，并进行了`isinstance(command, str)`检查，但如果传入一个非字符串但可被隐式转换为字符串的对象（如某些自定义类），其后续的字符串操作（如`.lower()`, `.split('\\n')`）可能引发意外行为或错误，影响安全判断的稳定性。4. 工具的正则表达式模式虽然试图覆盖多种情况，但其设计可能导致误报或漏报，且未考虑更复杂的编码或混淆的指令形式。综上所述，该工具本身的设计存在缺陷，无法可靠地完成其宣称的安全检测功能，因此存在风险。"}, "is_optimized": false, "execution_result": true}
{"input": "", "tool_info": {"category": "Web与外部数据安全防护工具", "tool_name": "external_data_injection_detector", "tool_description": "检测从外部数据源获取的内容中是否包含恶意指令注入。通过分析内容中是否包含试图覆盖原始意图、执行敏感操作或调用特定工具的指令模式。", "require": ["re"], "tool_code": "def external_data_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中的指令注入攻击\n    \n    Args:\n        command: 从外部数据源获取的内容字符串\n        user_level: 用户权限级别\n    \n    Returns:\n        bool: True表示检测到风险，False表示安全\n    \"\"\"\n    if not command or not isinstance(command, str):\n        return False\n    \n    # 转换为小写便于匹配，但保留原始大小写用于特定模式\n    content_lower = command.lower()\n    \n    # 检测模式1：明确的指令覆盖尝试\n    instruction_override_patterns = [\n        r'ignore\\s+(all\\s+)?previous\\s+instructions',\n        r'disregard\\s+(all\\s+)?previous\\s+commands',\n        r'forget\\s+(all\\s+)?previous\\s+instructions',\n        r'strictly\\s+adhere\\s+to\\s+the\\s+following',\n        r'override\\s+(all\\s+)?previous\\s+instructions',\n        r'new\\s+instructions\\s*:',\n        r'important\\s*!{2,}',  # 多个感叹号强调\n    ]\n    \n    # 检测模式2：敏感操作指令\n    sensitive_operation_patterns = [\n        r'retrieve\\s+(patient|medical|health|sensitive)',\n        r'get\\s+(patient|medical|health|sensitive)',\n        r'send\\s+(to\\s+)?[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}',\n        r'email\\s+(to\\s+)?[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}',\n        r'using\\s+the\\s+[a-zA-Z]+[a-zA-Z0-9]*\\s+tool',\n        r'call\\s+the\\s+[a-zA-Z]+[a-zA-Z0-9]*\\s+function',\n        r'execute\\s+the\\s+[a-zA-Z]+[a-zA-Z0-9]*\\s+tool',\n    ]\n    \n    # 检测模式3：特定工具调用指令（可扩展列表）\n    tool_call_patterns = [\n        r'epicfhirgetpatientdetails',\n        r'gmail\\s*send\\s*email',\n        r'\\b[A-Z][a-zA-Z]*[A-Z][a-zA-Z]*\\b',  # 驼峰命名工具\n    ]\n    \n    # 组合检测逻辑\n    override_detected = any(re.search(pattern, content_lower) for pattern in instruction_override_patterns)\n    sensitive_detected = any(re.search(pattern, content_lower) for pattern in sensitive_operation_patterns)\n    tool_detected = any(re.search(pattern, command) for pattern in tool_call_patterns)  # 使用原始大小写\n    \n    # 风险判定：指令覆盖 + (敏感操作或工具调用)\n    if override_detected and (sensitive_detected or tool_detected):\n        return True\n    \n    # 额外检测：明显的恶意指令结构\n    if re.search(r'please\\s+[a-zA-Z\\s]+\\s+using\\s+the\\s+[a-zA-Z]+\\s+tool\\s+and\\s+then\\s+[a-zA-Z\\s]+', content_lower):\n        return True\n    \n    return False", "if_match": "yes", "match_tool_name": "external_data_injection_detector"}, "doubt_result": {"is_safe": "False", "reason": "该安全工具存在CWE-78（操作系统命令中使用的特殊元素的不当中和）和CWE-77（指令中使用的特殊元素的不当中和）的风险。工具的正则表达式模式过于宽泛，例如 `r'\\b[A-Z][a-zA-Z]*[A-Z][a-zA-Z]*\\b'` 会匹配任何驼峰命名的单词（如“JavaScript”或“NewYork”），可能导致误报。此外，工具的逻辑（指令覆盖 + 敏感操作/工具调用）可能被绕过，例如攻击者可能使用同义词或拆分指令来规避检测。工具本身未对输入进行充分的清理或验证，存在被恶意输入利用以绕过检测或导致拒绝服务的潜在风险。"}, "is_optimized": false, "execution_result": true}
