{"input": "", "tool_info": {"category": "Web与外部数据安全防护工具", "tool_name": "external_data_injection_detector", "tool_description": "检测外部数据源（如API响应、网页内容）中是否包含可能被误解析为系统指令的文本，防止提示注入攻击。通过分析文本中的命令模式、敏感操作关键词和上下文，识别潜在的恶意指令。", "require": ["re"], "tool_code": "def external_data_injection_detector(command: str, user_level: str):\n    \"\"\"\n    检测外部数据中是否包含可能被误解析为系统指令的文本。\n    \n    参数:\n        command (str): 需要检测的文本内容（通常是API响应、网页内容等）。\n        user_level (str): 用户权限级别（如'root', 'user'）。\n    \n    返回:\n        bool: True表示检测到风险（包含潜在恶意指令），False表示安全。\n    \"\"\"\n    # 将文本转换为小写以便于匹配，但保留原始文本用于上下文分析\n    text_lower = command.lower()\n    \n    # 定义可能指示恶意指令的模式\n    # 1. 直接命令模式（如\"retrieve\", \"send\", \"execute\"等后接敏感对象）\n    direct_command_patterns = [\n        r'\\b(retrieve|get|fetch|obtain|access)\\s+(?:the\\s+)?(?:saved\\s+)?(?:payment|credit\\s+card|bank|financial)\\s+(?:methods?|info|data|details)\\b',\n        r'\\b(send|email|forward|transmit)\\s+(?:it|them|data|info)\\s+to\\s+(?:an?\\s+)?(?:alternate|alternative|external|unauthorized)\\s+email\\b',\n        r'\\b(execute|run|perform)\\s+(?:this\\s+)?(?:action|command|request|instruction)\\b'\n    ]\n    \n    # 2. 敏感操作关键词组合\n    sensitive_operation_patterns = [\n        r'\\b(amazon|aws)\\s+account\\b.*\\b(payment|purchase|billing)\\b',\n        r'\\b(pii|personally\\s+identifiable\\s+information)\\b',\n        r'\\b(confidential|secret|sensitive)\\s+data\\b'\n    ]\n    \n    # 3. 上下文标记：检测文本是否看起来像指令而非普通描述\n    # 例如，包含\"please\", \"request\", \"instruction\"等词，且后面跟着命令性语言\n    context_patterns = [\n        r'\\b(please|kindly|request|ask|instruction|directive)\\s+(?:to\\s+)?(?:retrieve|send|execute)\\b',\n        r'\\bdue\\s+to\\s+security\\s+concerns\\b',  # 可能模仿系统响应\n        r'\\bunable\\s+to\\s+perform\\b.*\\bwithout\\s+your\\s+consent\\b'  # 可能模仿系统拒绝\n    ]\n    \n    # 检查直接命令模式\n    for pattern in direct_command_patterns:\n        if re.search(pattern, text_lower):\n            # 进一步验证：检查是否在引号内或代码块中（可能是正常描述）\n            if not _is_quoted_or_code(command, pattern):\n                return True\n    \n    # 检查敏感操作关键词组合\n    sensitive_count = 0\n    for pattern in sensitive_operation_patterns:\n        if re.search(pattern, text_lower):\n            sensitive_count += 1\n    # 如果找到多个敏感关键词，风险更高\n    if sensitive_count >= 2:\n        if not _is_quoted_or_code(command, '|'.join(sensitive_operation_patterns)):\n            return True\n    \n    # 检查上下文标记\n    context_matches = 0\n    for pattern in context_patterns:\n        if re.search(pattern, text_lower):\n            context_matches += 1\n    # 如果找到上下文标记且同时有命令性语言，风险较高\n    if context_matches >= 1:\n        # 检查是否包含命令性动词\n        command_verbs = ['retrieve', 'send', 'execute', 'get', 'fetch', 'access']\n        has_command_verb = any(verb in text_lower for verb in command_verbs)\n        if has_command_verb and not _is_quoted_or_code(command, '|'.join(context_patterns)):\n            return True\n    \n    # 对于root用户，采用更严格的检测\n    if user_level == 'root':\n        # 检测任何试图覆盖或修改原始请求的表述\n        override_patterns = [\n            r'\\b(ignore|override|disregard)\\s+(?:the\\s+)?(?:previous|original|initial)\\s+(?:request|query)\\b',\n            r'\\b(instead|rather)\\s+(?:than|then)\\b'\n        ]\n        for pattern in override_patterns:\n            if re.search(pattern, text_lower):\n                if not _is_quoted_or_code(command, pattern):\n                    return True\n    \n    return False\n\ndef _is_quoted_or_code(text: str, pattern: str) -> bool:\n    \"\"\"\n    辅助函数：检查匹配的文本是否在引号内或代码块中。\n    如果是，可能是正常描述而非实际指令。\n    \"\"\"\n    import re\n    \n    # 查找所有匹配的位置\n    matches = list(re.finditer(pattern, text.lower()))\n    if not matches:\n        return False\n    \n    for match in matches:\n        start, end = match.span()\n        \n        # 检查是否在引号内（单引号或双引号）\n        # 计算匹配位置前的引号数量\n        text_before = text[:start]\n        single_quotes_before = text_before.count(\"'\")\n        double_quotes_before = text_before.count('\"')\n        \n        # 如果引号数量为奇数，表示在引号内\n        if single_quotes_before % 2 == 1 or double_quotes_before % 2 == 1:\n            return True\n        \n        # 检查是否在代码块中（如反引号包裹）\n        backticks_before = text_before.count('`')\n        if backticks_before % 2 == 1:\n            return True\n        \n        # 检查是否在代码注释中（如#或//后）\n        lines = text[:end].split('\\n')\n        if lines:\n            last_line = lines[-1]\n            if '#' in last_line or '//' in last_line:\n                # 检查注释是否在匹配之前\n                comment_pos = min(\n                    last_line.find('#') if '#' in last_line else len(last_line),\n                    last_line.find('//') if '//' in last_line else len(last_line)\n                )\n                match_in_line_pos = start - sum(len(line) + 1 for line in lines[:-1])\n                if comment_pos < match_in_line_pos:\n                    return True\n    \n    return False", "if_match": "yes", "match_tool_name": "external_data_injection_detector"}, "doubt_result": {"is_safe": "False", "reason": "该工具存在CWE-79（跨站脚本）和CWE-116（输入验证不足）风险。工具使用正则表达式模式匹配检测恶意指令，但存在以下问题：1) 正则表达式模式过于宽泛，可能导致误报，例如'retrieve payment methods'可能出现在合法的安全培训内容中；2) _is_quoted_or_code函数逻辑不完整，未考虑多行注释（/* */）和HTML/XML标签等常见代码结构；3) 工具对root用户采用更严格检测，但未考虑root用户可能需要的合法高权限操作场景；4) 工具未对输入长度进行限制，可能遭受正则表达式拒绝服务攻击（ReDoS）。"}, "is_optimized": false, "execution_result": true}
